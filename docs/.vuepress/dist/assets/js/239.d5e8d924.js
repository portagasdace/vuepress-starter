(window.webpackJsonp=window.webpackJsonp||[]).push([[239],{594:function(e,r,t){"use strict";t.r(r);var n=t(42),a=Object(n.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"实战篇-9-小程序订单支付-小程序支付"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战篇-9-小程序订单支付-小程序支付"}},[e._v("#")]),e._v(" 实战篇 9：小程序订单支付 —— 小程序支付")]),e._v(" "),t("p",[e._v("创建完订单，这一节，我们来实现小程序的支付功能，以完成一个商业应用的业务经营能力闭环。")]),e._v(" "),t("p",[e._v("微信小程序的主要交互图如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/30/16586e676781031e?w=686&h=572&f=jpeg&s=51527",alt:""}})]),e._v(" "),t("p",[e._v("要想实现支付的系统逻辑，最主要的是完成接下来的 4 个步骤：")]),e._v(" "),t("h3",{attrs:{id:"_1-小程序内调用登录接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-小程序内调用登录接口"}},[e._v("#")]),e._v(" 1.小程序内调用登录接口")]),e._v(" "),t("p",[e._v("小程序内调用登录接口，获取到用户的 openid，API 参见 "),t("a",{attrs:{href:"https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html?t=20161122",target:"_blank",rel:"noopener noreferrer"}},[e._v("小程序登录 API"),t("OutboundLink")],1),e._v(" 。")]),e._v(" "),t("p",[e._v("在面向小程序的 JWT 登录用户验证章节中，我们已经掌握了如何获取用户 openid 的调用流程与方法。")]),e._v(" "),t("h3",{attrs:{id:"_2-商户-server-调用支付统一下单"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-商户-server-调用支付统一下单"}},[e._v("#")]),e._v(" 2. 商户 server 调用支付统一下单")]),e._v(" "),t("p",[e._v("获取了用户的 openid 后，需要在商户的 server 调用微信的支付统一下单，以创建一条待支付的记录返回给小程序，以完成小程序客户端的支付能力唤起，进入到后续步骤。商户 server 调用支付统一下单，API 参见 "),t("a",{attrs:{href:"https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_1&index=1",target:"_blank",rel:"noopener noreferrer"}},[e._v("统一下单 API"),t("OutboundLink")],1),e._v(" 。")]),e._v(" "),t("p",[e._v("看过接口文档，我们发现微信接收的数据与返回的格式都是以 text/xml 的格式，而非 application/json ，所以，我们需要引入 xml2js 的插件帮助我们在 JavaScript 的 Ojbect 与 XML 的 Object 数据关系之间快速转换。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$ npm i xml2js\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// routers/order.js\n\n{\n  method: 'POST',\n  path: `/${GROUP_NAME}/{orderId}/pay`,\n  handler: async (request, reply) => {\n    // 从用户表中获取 openid\n    const user = await models.users.findOne({ where: { id: request.auth.credentials.userId } });\n      const { openid } = user;\n    // 构造 unifiedorder 所需入参\n    const unifiedorderObj = {\n      appid: config.wxAppid, // 小程序 id\n      body: '小程序支付', // 商品简单描述\n      mch_id: config.wxMchid, // 商户号\n      nonce_str: Math.random().toString(36).substr(2, 15), // 随机字符串\n      notify_url: 'https://yourhost.com/orders/pay/notify', // 支付成功的回调地址\n      openid, // 用户 openid\n      out_trade_no: request.params.orderId, // 商户订单号\n      spbill_create_ip: request.info.remoteAddress, // 调用支付接口的用户 ip\n      total_fee: 1, // 总金额，单位为分\n      trade_type: 'JSAPI', // 交易类型，默认\n    };\n    // 签名的数据\n    const getSignData = (rawData, apiKey) => {\n      let keys = Object.keys(rawData);\n      keys = keys.sort();\n      let string = '';\n      keys.forEach((key) => {\n        string += `&${key}=${rawData[key]}`;\n      });\n      string = string.substr(1);\n      return crypto.createHash('md5').update(`${string}&key=${apiKey}`).digest('hex').toUpperCase();\n    };\n    // 将基础数据信息 sign 签名\n    const sign = getSignData(unifiedorderObj, config.wxPayApiKey);\n    // 需要被 post 的数据源\n    const unifiedorderWithSign = {\n      ...unifiedorderObj,\n      sign,\n    };\n    // 将需要 post 出去的订单参数，转换位 xml 格式\n    const builder = new xml2js.Builder({ rootName: 'xml', headless: true });\n    const unifiedorderXML = builder.buildObject(unifiedorderWithSign);\n    const result = await axios({\n      url: 'https://api.mch.weixin.qq.com/pay/unifiedorder',\n      method: 'POST',\n      data: unifiedorderXML,\n      headers: { 'content-type': 'text/xml' },\n    });\n    // result 是一个 xml 结构的 response，转换为 jsonObject，并返回前端\n    xml2js.parseString(result.data, (err, parsedResult) => {\n      if (parsedResult.xml) {\n        if (parsedResult.xml.return_code[0] === 'SUCCESS'\n        && parsedResult.xml.result_code[0] === 'SUCCESS') {\n          // 待签名的原始支付数据\n          const replyData = {\n            appId: parsedResult.xml.appid[0],\n            timeStamp: (Date.now() / 1000).toString(),\n            nonceStr: parsedResult.xml.nonce_str[0],\n            package: `prepay_id=${parsedResult.xml.prepay_id[0]}`,\n            signType: 'MD5',\n          };\n          replyData.paySign = getSignData(replyData, config.wxPayApiKey);\n          reply(replyData);\n        }\n      }\n    });\n  },\n  config: {\n    tags: ['api', GROUP_NAME],\n    description: '支付某条订单',\n    validate: {\n      params: {\n        orderId: Joi.string().required(),\n      },\n      ...jwtHeaderDefine,\n    },\n  },\n},\n\n\n\n")])])]),t("h3",{attrs:{id:"_3-商户-server-调用再次签名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-商户-server-调用再次签名"}},[e._v("#")]),e._v(" 3. 商户 server 调用再次签名")]),e._v(" "),t("p",[e._v("商户 server 调用再次签名，公共 API 参见 "),t("a",{attrs:{href:"https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&index=3",target:"_blank",rel:"noopener noreferrer"}},[e._v("再次签名 API"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("此步骤由微信小程序前端客户端实现，将步骤 2 中，/orders/{orderId}/pay 接口返回的支付统一下单签名数据，依次填入 wx.requestPayment，即可在小程序的客户端唤起支付界面，并完成后续的支付操作流程。用户支付成功后，微信平台会自动触发步骤 4 中的支付成功推送。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("wx.requestPayment(\n{\n  'timeStamp': '',\n  'nonceStr': '',\n  'package': '',\n  'signType': 'MD5',\n  'paySign': '',\n  'success':function(res){},\n  'fail':function(res){},\n  'complete':function(res){}\n})\n\n")])])]),t("h3",{attrs:{id:"_4-商户-server-接收支付通知"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-商户-server-接收支付通知"}},[e._v("#")]),e._v(" 4. 商户 server 接收支付通知")]),e._v(" "),t("p",[e._v("用户完成支付行为后，商户 server 接收支付通知，API 参见 "),t("a",{attrs:{href:"https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_7",target:"_blank",rel:"noopener noreferrer"}},[e._v("支付结果通知 API"),t("OutboundLink")],1),e._v(" 。")]),e._v(" "),t("p",[e._v("微信对商户后台通知交互时，如果微信收到商户的应答不是成功或超时，微信认为通知失败，微信会通过一定的策略定期重新发起通知，尽可能提高通知的成功率，但不保证通知最终能成功。（通知频率为 15/15/30/180/1800/1800/1800/1800/3600，单位：秒。）")]),e._v(" "),t("p",[e._v("商户应答成功的返回数据结构是：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<xml>\n  <return_code><![CDATA[SUCCESS]]></return_code>\n  <return_msg><![CDATA[OK]]></return_msg>\n</xml>\n\n")])])]),t("p",[e._v("实现接口 POST /orders/pay/notify，在核对订单信息校验成功后，需要返回微信上述的 XML 字符串信息，否则返回 return_code 为 "),t("code",[e._v("FAIL")]),e._v("，并在 return_msg 中附带参数校验错误说明。/orders/pay/notify 在 hapi 的 API 接口中 config.auth 应该设置为 "),t("code",[e._v("false")]),e._v("，不进入 JWT 的用户认证流程。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n{\n  method: 'POST',\n  path: `/${GROUP_NAME}/pay/notify`,\n  handler: async (request, reply) => {\n    xml2js.parseString(request.payload, async (err, parsedResult) => {\n      if (parsedResult.xml.return_code[0] === 'SUCCESS') {\n        // 微信统一支付状态成功，需要检验本地数据的逻辑一致性\n        // 省略...细节逻辑校验\n        // 更新该订单编号下的支付状态未已支付\n        const orderId = parsedResult.xml.out_trade_no[0];\n        const orderResult = await models.orders.findOne({ where: { id: orderId } });\n        orderResult.payment_status = '1';\n        await orderResult.save();\n        // 返回微信，校验成功\n        const retVal = {\n          return_code: 'SUCCESS',\n          return_msg: 'OK',\n        };\n        const builder = new xml2js.Builder({\n          rootName: 'xml',\n          headless: true,\n        });\n        reply(builder.buildObject(retVal));\n      }\n    });\n  },\n  config: {\n    tags: ['api', GROUP_NAME],\n    description: '微信支付成功的消息推送',\n    auth: false,\n  },\n},\n\n\n\n")])])]),t("blockquote",[t("p",[t("strong",[e._v("GitHub 参考代码")]),e._v(" "),t("a",{attrs:{href:"https://github.com/yeshengfei/hapi-tutorial/tree/master/chapter13/hapi-tutorial-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("chapter13/hapi-tutorial-1"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),t("p",[e._v("关键词：微信支付，支付统一下单，支付通知，XML 数据通信")]),e._v(" "),t("p",[e._v("本小节围绕微信支付接入的四步骤，做了接入流程上的讲解。开发过程中尤其注意支付接入以 XML 格式数据进行数据交换，签名数据的算法一致性。剩下的对照着文档，小心翼翼地处理好字段的对应，便能顺利把流程走完。")]),e._v(" "),t("p",[t("strong",[e._v("本小节参考代码汇总")])]),e._v(" "),t("p",[e._v("小程序内调用登录接口："),t("a",{attrs:{href:"https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html?t=20161122",target:"_blank",rel:"noopener noreferrer"}},[e._v("小程序登录 API"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("商户 server 调用支付统一下单："),t("a",{attrs:{href:"https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_1&index=1",target:"_blank",rel:"noopener noreferrer"}},[e._v("统一下单 API"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("商户 server 调用再次签名："),t("a",{attrs:{href:"https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&index=3",target:"_blank",rel:"noopener noreferrer"}},[e._v("再次签名 API"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("商户 server 接收支付通知："),t("a",{attrs:{href:"https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_7",target:"_blank",rel:"noopener noreferrer"}},[e._v("支付结果通知 API"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("GitHub参考代码："),t("a",{attrs:{href:"https://github.com/yeshengfei/hapi-tutorial/tree/master/chapter13/hapi-tutorial-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("chapter13/hapi-tutorial-1"),t("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=a.exports}}]);