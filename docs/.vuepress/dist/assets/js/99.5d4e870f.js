(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{455:function(t,n,e){"use strict";e.r(n);var a=e(42),r=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"flutter-布局-widget-流式布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flutter-布局-widget-流式布局"}},[t._v("#")]),t._v(" Flutter 布局 Widget —— 流式布局")]),t._v(" "),e("p",[t._v("流式布局：页面元素的宽度可以按照屏幕分辨率进行适配调整，但整体布局不变。")]),t._v(" "),e("p",[t._v("在 Flutter 中的流式布局是： "),e("a",{attrs:{href:"https://docs.flutter.io/flutter/widgets/Wrap-class.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Wrap"),e("OutboundLink")],1)]),t._v(" "),e("ul",[e("li",[e("p",[t._v("为什么需要流式布局？")]),t._v(" "),e("p",[t._v("前面讲到的，在 Flex、Row、Column 中，当 子Widget 的大小超过 主轴的大小后，就会报 layout 的 overflowed 错误 ，会在界面上看到黄黑色的条。")])])]),t._v(" "),e("p",[t._v("这个问题也可以用流式布局解决，将上面代码的 Row 换成 Wrap:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import 'package:flutter/material.dart';\n\nmain() {\n  runApp(new MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialApp(\n        title: 'Test',\n        home: new Scaffold(\n            appBar: new AppBar(title: new Text('Flutter 布局Widget -- 流式布局')),\n            body: Wrap(\n              children: <Widget>[Text('Hello Flutter ' * 100)],\n            )));\n  }\n}\n\n")])])]),e("p",[t._v("运行后的效果就为：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/9/16a00277ff1f9ad0?w=836&h=950&f=jpeg&s=317364",alt:""}})]),t._v(" "),e("h1",{attrs:{id:"wrap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#wrap"}},[t._v("#")]),t._v(" Wrap")]),t._v(" "),e("p",[t._v("Wrap 会把超出屏幕显示范围的 Widget 自动换行，所以称为流式布局。")]),t._v(" "),e("h2",{attrs:{id:"代码所在位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码所在位置"}},[t._v("#")]),t._v(" 代码所在位置")]),t._v(" "),e("p",[t._v("flutter_widget_demo/lib/wrap/WrapWidget.dart")]),t._v(" "),e("h2",{attrs:{id:"wrap-的快速上手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#wrap-的快速上手"}},[t._v("#")]),t._v(" Wrap 的快速上手")]),t._v(" "),e("p",[t._v("Wrap 需要设置主轴方向，默认的主轴方向为水平方向，给其 children 参数添加 子Widget 即可，例如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Wrap(\n  direction: Axis.horizontal,\n  children: <Widget>[\n    ...\n  ]\n)\n\n\n")])])]),e("p",[t._v("Wrap 在一个页面使用的完整 Demo 如下:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import 'package:flutter/material.dart';\n\nmain() => runApp(new WrapWidget());\n\nclass WrapWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialApp(\n        title: 'Test',\n        home: new Scaffold(\n            appBar: new AppBar(title: new Text('Flutter 布局Widget -- 流式布局')),\n            body: Wrap(\n              direction: Axis.horizontal,\n              spacing: 8.0, // 主轴 方向间距\n              runSpacing: 12.0, // 交叉轴 方向间距\n              alignment: WrapAlignment.center,\n              runAlignment: WrapAlignment.start,\n              children: <Widget>[\n                new Chip(\n                  avatar: new CircleAvatar(\n                      backgroundColor: Colors.blue, child: Text('A')),\n                  label: new Text('AAAAAAAA'),\n                ),\n                new Chip(\n                  avatar: new CircleAvatar(\n                      backgroundColor: Colors.blue, child: Text('M')),\n                  label: new Text('BBBBBB'),\n                ),\n                new Chip(\n                  avatar: new CircleAvatar(\n                      backgroundColor: Colors.blue, child: Text('H')),\n                  label: new Text('CCCCCCCCC'),\n                ),\n                new Chip(\n                  avatar: new CircleAvatar(\n                      backgroundColor: Colors.blue, child: Text('J')),\n                  label: new Text('DDDDDDDD'),\n                ),\n                new Chip(\n                  avatar: new CircleAvatar(\n                      backgroundColor: Colors.blue, child: Text('J')),\n                  label: new Text('EEEEEEEE'),\n                ),\n                new Chip(\n                  avatar: new CircleAvatar(\n                      backgroundColor: Colors.blue, child: Text('J')),\n                  label: new Text('FFFFFFFFFFFFFFFF'),\n                ),\n              ],\n            )));\n  }\n}\n\n")])])]),e("p",[t._v("运行效果：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/9/16a002845670f9aa?w=860&h=668&f=jpeg&s=85897",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"wrap-的构造函数及参数说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#wrap-的构造函数及参数说明"}},[t._v("#")]),t._v(" Wrap 的构造函数及参数说明")]),t._v(" "),e("p",[t._v("Wrap 的构造函数为：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Wrap extends MultiChildRenderObjectWidget {\n  Wrap({\n    Key key,\n    this.direction = Axis.horizontal,\n    this.alignment = WrapAlignment.start,\n    this.spacing = 0.0,\n    this.runAlignment = WrapAlignment.start,\n    this.runSpacing = 0.0,\n    this.crossAxisAlignment = WrapCrossAlignment.start,\n    this.textDirection,\n    this.verticalDirection = VerticalDirection.down,\n    List<Widget> children = const <Widget>[],\n  }) : super(key: key, children: children);\n  ...\n}\n\n")])])]),e("p",[t._v("参数名字")]),t._v(" "),e("p",[t._v("参数类型")]),t._v(" "),e("p",[t._v("意义")]),t._v(" "),e("p",[t._v("必选 or 可选")]),t._v(" "),e("p",[t._v("key")]),t._v(" "),e("p",[t._v("Key")]),t._v(" "),e("p",[t._v("Widget 的标识")]),t._v(" "),e("p",[t._v("可选")]),t._v(" "),e("p",[t._v("direction")]),t._v(" "),e("p",[t._v("Axis")]),t._v(" "),e("p",[t._v("主轴的方向"),e("br"),t._v("\n默认是 Axis.horizontal")]),t._v(" "),e("p",[t._v("可选")]),t._v(" "),e("p",[t._v("alignment")]),t._v(" "),e("p",[t._v("WrapAlignment")]),t._v(" "),e("p",[t._v("子Widget 在主轴上的对齐方式，默认值为WrapAlignment.start"),e("br"),t._v("\nWrapAlignment 的值和 MainAxisAlignment 的一样")]),t._v(" "),e("p",[t._v("可选")]),t._v(" "),e("p",[t._v("runAlignment")]),t._v(" "),e("p",[t._v("WrapAlignment")]),t._v(" "),e("p",[t._v("Wrap 会自动换成或换列，runAlignment 就是每行或每列的对齐方式，如果主轴为水平方向，就是每行，如果主轴为竖直方向，就是每列，默认值为WrapAlignment.start"),e("br"),t._v("\nWrapAlignment 的值和 MainAxisAlignment 的一样")]),t._v(" "),e("p",[t._v("可选")]),t._v(" "),e("p",[t._v("runSpacing")]),t._v(" "),e("p",[t._v("double")]),t._v(" "),e("p",[t._v("每行或每列之间的间距"),e("br"),t._v("\n默认是0.0")]),t._v(" "),e("p",[t._v("可选")]),t._v(" "),e("p",[t._v("crossAxisAlignment")]),t._v(" "),e("p",[t._v("WrapCrossAlignment")]),t._v(" "),e("p",[t._v("子Widget 在交叉轴上的对齐方式，WrapCrossAlignment.start"),e("br"),t._v("\nWrapCrossAlignment 的值和 MainAxisAlignment 的一样")]),t._v(" "),e("p",[t._v("可选")]),t._v(" "),e("p",[t._v("textDirection")]),t._v(" "),e("p",[t._v("TextDirection")]),t._v(" "),e("p",[t._v("表示 子Widget 在主轴方向上的布局顺序")]),t._v(" "),e("p",[t._v("可选")]),t._v(" "),e("p",[t._v("verticalDirection")]),t._v(" "),e("p",[t._v("VerticalDirection")]),t._v(" "),e("p",[t._v("表示 子Widget 在交叉轴方向上的布局顺序")]),t._v(" "),e("p",[t._v("可选")]),t._v(" "),e("p",[t._v("children")]),t._v(" "),e("p",[t._v("List< Widget>")]),t._v(" "),e("p",[t._v("Wrap布局 里排列的内容")]),t._v(" "),e("p",[t._v("可选")])])}),[],!1,null,null,null);n.default=r.exports}}]);