(window.webpackJsonp=window.webpackJsonp||[]).push([[197],{551:function(e,t,n){"use strict";n.r(t);var a=n(42),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("上节我们说过，观察者模式作为一个超高频考点，在设计模式中具有举足轻重的地位。单从面试的维度来说，说它是最重要的设计模式也不为过。正因为如此，它的面试题变体可以说是五花八门。")]),e._v(" "),n("p",[e._v("不过面试题这东西，和数学题一样，看似变化多端，实则大同小异。大家如果经历的面试足够多，会发现观察者模式考来考去也就是那么几种考法，所谓的“变化多端”，也无非是改个条件改个变量的事情。本节在梳理了大量相关面试题的基础上，为大家总结了观察者模式的四个出题方向。相信有了本节的加持和下节的强化，大家再和面试官聊到观察者模式时，一定可以滔滔不绝、轻松拿下~")]),e._v(" "),n("h2",{attrs:{id:"vue数据双向绑定-响应式系统-的实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue数据双向绑定-响应式系统-的实现原理"}},[e._v("#")]),e._v(" Vue数据双向绑定（响应式系统）的实现原理")]),e._v(" "),n("h3",{attrs:{id:"解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解析"}},[e._v("#")]),e._v(" 解析")]),e._v(" "),n("p",[e._v("Vue 框架是热门的渐进式 JavaScript框架。在 Vue 中，当我们修改状态时，视图会随之更新，这就是Vue的数据双向绑定（又称响应式原理）。数据双向绑定是Vue 最独特的特性之一。如果读者没有接触过 Vue，强烈建议阅读"),n("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/reactivity.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue官方对响应式原理的介绍"),n("OutboundLink")],1),e._v("。此处我们用官方的一张流程图来简要地说明一下Vue响应式系统的整个流程：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/3/31/169d2aa6ea6dd122?w=1200&h=750&f=png&s=21308",alt:"Vue响应式系统"}})]),e._v(" "),n("p",[e._v("在 Vue 中，每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式。这道面试题考察了受试者对Vue底层原理的理解、对观察者模式的实现能力以及一系列重要的JS知识点，具有较强的综合性和代表性。")]),e._v(" "),n("p",[e._v("值得注意的是，在面试过程中，面试官多数情况下不会要求大家写出完整的响应式原理实现代码，而是要求你“说说自己的理解”。在本节，我们不会带大家一行一行写代码（具体深入Vue框架的相关知识，建议大家阅读"),n("a",{attrs:{href:"https://github.com/vuejs/vue",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue源码"),n("OutboundLink")],1),e._v("及这本"),n("a",{attrs:{href:"https://juejin.im/book/5a36661851882538e2259c0f",target:"_blank",rel:"noopener noreferrer"}},[e._v("专门写Vue的小册"),n("OutboundLink")],1),e._v("。），而是针对Vue响应式系统中与观察者模式紧密关联的这部分知识作讲解，帮助大家捋清楚整套流程里的来龙去脉、加深对观察者模式的理解。")]),e._v(" "),n("p",[e._v("在Vue数据双向绑定的实现逻辑里，有这样三个关键角色：")]),e._v(" "),n("ul",[n("li",[e._v("observer（监听器）：注意，此 observer 非彼 observer。在我们上节的解析中，observer 作为设计模式中的一个角色，代表“订阅者”。但在Vue数据双向绑定的角色结构里，所谓的 observer 不仅是一个数据监听器，它还需要对监听到的数据进行"),n("strong",[e._v("转发")]),e._v("——也就是说它"),n("strong",[e._v("同时还是一个发布者")]),e._v("。")]),e._v(" "),n("li",[e._v("watcher（订阅者）：observer 把数据转发给了"),n("strong",[e._v("真正的订阅者")]),e._v("——watcher对象。watcher 接收到新的数据后，会去更新视图。")]),e._v(" "),n("li",[e._v("compile（编译器）：MVVM 框架特有的角色，负责对每个节点元素指令进行扫描和解析，指令的数据初始化、订阅者的创建这些“杂活”也归它管~"),n("br"),e._v("\n这三者的配合过程如图所示：")])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/5/169ecc97fbcf1dc5?w=436&h=273&f=png&s=18329",alt:""}})]),e._v(" "),n("p",[e._v("OK，实现方案搞清楚了，下面我们给整个流程中"),n("strong",[e._v("涉及到发布-订阅这一模式的代码")]),e._v("来个特写：")]),e._v(" "),n("h3",{attrs:{id:"核心代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#核心代码"}},[e._v("#")]),e._v(" 核心代码")]),e._v(" "),n("h4",{attrs:{id:"实现observer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现observer"}},[e._v("#")]),e._v(" 实现observer")]),e._v(" "),n("p",[e._v("首先我们需要实现一个方法，这个方法会对需要监听的数据对象进行遍历、给它的属性加上定制的 getter 和 setter 函数。这样但凡这个对象的某个属性发生了改变，就会触发 setter 函数，进而通知到订阅者。这个 setter 函数，就是我们的监听器：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// observe方法遍历并包装对象属性\nfunction observe(target) {\n    // 若target是一个对象，则遍历它\n    if(target && typeof target === 'object') {\n        Object.keys(target).forEach((key)=> {\n            // defineReactive方法会给目标属性装上“监听器”\n            defineReactive(target, key, target[key])\n        })\n    }\n}\n\n// 定义defineReactive方法\nfunction defineReactive(target, key, val) {\n    // 属性值也可能是object类型，这种情况下需要调用observe进行递归遍历\n    observe(val)\n    // 为当前属性安装监听器\n    Object.defineProperty(target, key, {\n         // 可枚举\n        enumerable: true,\n        // 不可配置\n        configurable: false, \n        get: function () {\n            return val;\n        },\n        // 监听器函数\n        set: function (value) {\n            console.log(`${target}属性的${key}属性从${val}值变成了了${value}`)\n            val = value\n        }\n    });\n}\n\n")])])]),n("p",[e._v("下面实现订阅者 Dep：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 定义订阅者类Dep\nclass Dep {\n    constructor() {\n        // 初始化订阅队列\n        this.subs = []\n    }\n    \n    // 增加订阅者\n    addSub(sub) {\n        this.subs.push(sub)\n    }\n    \n    // 通知订阅者（是不是所有的代码都似曾相识？）\n    notify() {\n        this.subs.forEach((sub)=>{\n            sub.update()\n        })\n    }\n}\n\n")])])]),n("p",[e._v("现在我们可以改写 defineReactive 中的 setter 方法，在监听器里去通知订阅者了：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function defineReactive(target, key, val) {\n    const dep = new Dep()\n    // 监听当前属性\n    observe(val)\n    Object.defineProperty(target, key, {\n        set: (value) => {\n            // 通知所有订阅者\n            dep.notify()\n        }\n    })\n}\n\n")])])]),n("h2",{attrs:{id:"实现一个event-bus-event-emitter"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现一个event-bus-event-emitter"}},[e._v("#")]),e._v(" 实现一个Event Bus/ Event Emitter")]),e._v(" "),n("p",[e._v("Event Bus（Vue、Flutter 等前端框架中有出镜）和 Event Emitter（Node中有出镜）出场的“剧组”不同，但是它们都对应一个共同的角色——"),n("strong",[e._v("全局事件总线")]),e._v("。"),n("br"),e._v("\n全局事件总线，严格来说不能说是观察者模式，而是发布-订阅模式（具体的概念甄别我们会在下个小节着重讲）。它在我们日常的业务开发中应用非常广。")]),e._v(" "),n("p",[e._v("上节开篇我说过，如果只能考一个设计模式的面试题，我一定会出观察者模式。")]),e._v(" "),n("p",[e._v("这句话接着往下说，如果只能选一道题，那这道题一定是 Event Bus/Event Emitter 的代码实现——我都说这么清楚了，这个知识点到底要不要掌握、需要掌握到什么程度，就看各位自己的了。")]),e._v(" "),n("h3",{attrs:{id:"在vue中使用event-bus来实现组件间的通讯"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在vue中使用event-bus来实现组件间的通讯"}},[e._v("#")]),e._v(" 在Vue中使用Event Bus来实现组件间的通讯")]),e._v(" "),n("p",[e._v("Event Bus/Event Emitter 作为全局事件总线，它起到的是一个"),n("strong",[e._v("沟通桥梁")]),e._v("的作用。我们可以把它理解为一个事件中心，我们所有事件的订阅/发布都不能由订阅方和发布方“私下沟通”，必须要委托这个事件中心帮我们实现。"),n("br"),e._v("\n在Vue中，有时候 A 组件和 B 组件中间隔了很远，看似没什么关系，但我们希望它们之间能够通信。这种情况下除了求助于 Vuex 之外，我们还可以通过 Event Bus 来实现我们的需求。")]),e._v(" "),n("p",[e._v("创建一个 Event Bus（本质上也是 Vue 实例）并导出：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const EventBus = new Vue()\nexport default EventBus\n\n")])])]),n("p",[e._v("在主文件里引入EventBus，并挂载到全局：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import bus from 'EventBus的文件路径'\nVue.prototype.bus = bus\n\n")])])]),n("p",[e._v("订阅事件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 这里func指someEvent这个事件的监听函数\nthis.bus.$on('someEvent', func)\n\n")])])]),n("p",[e._v("发布（触发）事件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 这里params指someEvent这个事件被触发时回调函数接收的入参\nthis.bus.$emit('someEvent', params)\n\n")])])]),n("p",[e._v("大家会发现，整个调用过程中，没有出现具体的发布者和订阅者（比如上节的PrdPublisher和DeveloperObserver），全程只有bus这个东西一个人在疯狂刷存在感。这就是全局事件总线的特点——所有事件的发布/订阅操作，必须经由事件中心，禁止一切“私下交易”！")]),e._v(" "),n("p",[e._v("下面，我们就一起来实现一个Event Bus（注意看注释里的解析）：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class EventEmitter {\n  constructor() {\n    // handlers是一个map，用于存储事件与回调之间的对应关系\n    this.handlers = {}\n  }\n\n  // on方法用于安装事件监听器，它接受目标事件名和回调函数作为参数\n  on(eventName, cb) {\n    // 先检查一下目标事件名有没有对应的监听函数队列\n    if (!this.handlers[eventName]) {\n      // 如果没有，那么首先初始化一个监听函数队列\n      this.handlers[eventName] = []\n    }\n\n    // 把回调函数推入目标事件的监听函数队列里去\n    this.handlers[eventName].push(cb)\n  }\n\n  // emit方法用于触发目标事件，它接受事件名和监听函数入参作为参数\n  emit(eventName, ...args) {\n    // 检查目标事件是否有监听函数队列\n    if (this.handlers[eventName]) {\n      // 如果有，则逐个调用队列里的回调函数\n      this.handlers[eventName].forEach((callback) => {\n        callback(...args)\n      })\n    }\n  }\n\n  // 移除某个事件回调队列里的指定回调函数\n  off(eventName, cb) {\n    const callbacks = this.handlers[eventName]\n    const index = callbacks.indexOf(cb)\n    if (index !== -1) {\n      callbacks.splice(index, 1)\n    }\n  }\n\n  // 为事件注册单次监听器\n  once(eventName, cb) {\n    // 对回调函数进行包装，使其执行完毕自动被移除\n    const wrapper = (...args) => {\n      cb.apply(...args)\n      this.off(eventName, wrapper)\n    }\n    this.on(eventName, wrapper)\n  }\n}\n\n")])])]),n("p",[e._v("在日常的开发中，大家用到EventBus/EventEmitter往往提供比这五个方法多的多的多的方法。但在面试过程中，如果大家能够完整地实现出这五个方法，已经非常可以说明问题了，因此楼上这个EventBus希望大家可以熟练掌握。学有余力的同学，推荐阅读"),n("a",{attrs:{href:"https://github.com/facebook/emitter",target:"_blank",rel:"noopener noreferrer"}},[e._v("FaceBook推出的通用EventEmiiter库的源码"),n("OutboundLink")],1),e._v("，相信你会有更多收获。")]),e._v(" "),n("h2",{attrs:{id:"观察者模式与发布-订阅模式的区别是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式与发布-订阅模式的区别是什么"}},[e._v("#")]),e._v(" 观察者模式与发布-订阅模式的区别是什么？")]),e._v(" "),n("p",[e._v("在面试过程中，一些对细节比较在意的面试官可能会追问观察者模式与发布-订阅模式的区别。这个问题可能会引发一些同学的不适，因为在大量参考资料以及已出版的纸质书籍中，都会告诉大家“发布-订阅模式和观察者模式是同一个东西的两个名字”。本书在前文的叙述中，也没有突出强调两者的区别。其实这两个模式，要较起真来，确实不能给它们划严格的等号。")]),e._v(" "),n("p",[e._v("为什么大家都喜欢给它们强行划等号呢？这是因为就算划了等号，也不影响我们正常使用，毕竟两者在核心思想、运作机制上没有本质的差别。但考虑到这个问题确实可以成为面试题的一个方向，此处我们还是单独拿出来讲一下。")]),e._v(" "),n("p",[e._v("回到我们上文的例子里。韩梅梅把所有的开发者拉了一个群，直接把需求文档丢给每一位群成员，这种"),n("strong",[e._v("发布者直接触及到订阅者")]),e._v("的操作，叫观察者模式。但如果韩梅梅没有拉群，而是把需求文档上传到了公司统一的需求平台上，需求平台感知到文件的变化、自动通知了每一位订阅了该文件的开发者，这种"),n("strong",[e._v("发布者不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作，叫做发布-订阅模式")]),e._v("。")]),e._v(" "),n("p",[e._v("相信大家也已经看出来了，观察者模式和发布-订阅模式之间的区别，在于是否存在第三方、发布者能否直接感知订阅者（如图所示）。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/5/169ed4923a4f51b7?w=158&h=156&f=png&s=6280",alt:""}})]),e._v(" "),n("p",[e._v("观察者模式")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/5/169ed4a77700d98e?w=228&h=185&f=png&s=8296",alt:""}})]),e._v(" "),n("p",[e._v("发布-订阅模式")]),e._v(" "),n("p",[e._v("在我们见过的这些例子里，韩梅梅拉钉钉群的操作，就是典型的观察者模式；而通过EventBus去实现事件监听/发布，则属于发布-订阅模式。")]),e._v(" "),n("p",[e._v("既生瑜，何生亮？既然有了观察者模式，为什么还需要发布-订阅模式呢？")]),e._v(" "),n("p",[e._v("大家思考一下：为什么要有观察者模式？观察者模式，解决的其实是模块间的耦合问题，有它在，即便是两个分离的、毫不相关的模块，也可以实现数据通信。但观察者模式仅仅是减少了耦合，"),n("strong",[e._v("并没有完全地解决耦合问题")]),e._v("——被观察者必须去维护一套观察者的集合，这些观察者必须实现统一的方法供被观察者调用，两者之间还是有着说不清、道不明的关系。")]),e._v(" "),n("p",[e._v("而发布-订阅模式，则是快刀斩乱麻了——发布者完全不用感知订阅者，不用关心它怎么实现回调方法，事件的注册和触发都发生在独立于双方的第三方平台（事件总线）上。发布-订阅模式下，实现了完全地解耦。")]),e._v(" "),n("p",[e._v("但这并不意味着，发布-订阅模式就比观察者模式“高级”。在实际开发中，我们的模块解耦诉求"),n("strong",[e._v("并非总是需要它们完全解耦")]),e._v("。如果两个模块之间本身存在关联，且这种关联是稳定的、必要的，那么我们使用观察者模式就足够了。而在模块与模块之间独立性较强、且没有必要单纯为了数据通信而强行为两者制造依赖的情况下，我们往往会倾向于使用发布-订阅模式。")]),e._v(" "),n("p",[e._v("（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）")])])}),[],!1,null,null,null);t.default=s.exports}}]);