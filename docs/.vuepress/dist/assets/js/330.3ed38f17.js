(window.webpackJsonp=window.webpackJsonp||[]).push([[330],{685:function(e,t,n){"use strict";n.r(t);var r=n(42),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"redux-及中间件原理解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redux-及中间件原理解析"}},[e._v("#")]),e._v(" Redux 及中间件原理解析")]),e._v(" "),n("p",[e._v("在做这个项目的过程中，hooks 的 api 相当简洁，代码也容易理解，但 Redux 就不一样了，大量的样板代码，以及各种纯函数的限制，让刚刚上手的新人总会 感觉有些不适应。React 的开发，很大一部分的门槛在于 Redux。可能有人会说了，都 9012 年了，还用什么 Redux 管理数据啊，直接 hooks 一把撸。对于这些人的观点， 我已经小册中间的彩蛋部分给予了回应，我认为 Redux 由于出色的调试机制和完整的模块管理功能，是一个短时间不可被替代的状态管理方案。")]),e._v(" "),n("p",[e._v("因此我觉得我们在熟练使用 Redux 的同时，也有必要去研究它内部的原理，体会它的设计思想，这样不仅仅能够加深我们对于 Redux 本身的理解，也能够巩固原生 JS 的 功底，锤炼我们的编程思想。")]),e._v(" "),n("p",[e._v("还记得这些熟悉的代码吗？")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import {createStore, compose, applyMiddleware} from "redux";\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\nconst store = createStore (reducer, composeEnhancers (applyMiddleware (thunk)));\n\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import { combineReducers } from "redux-immutable";\nimport { reducer as recommendReducer } from "../application/Recommend/store/index";\n//...\n\nexport default combineReducers ({\n  recommend: recommendReducer,\n  //...\n});\n\n\n')])])]),n("p",[e._v("你知道 createStore 发生了什么？dispatch 执行后在内部怎么运作的？compose 函数做了什么事情？combineReducers 是如何合并不同的 reducer 的？applyMiddleware 是如何组织中间件的？")]),e._v(" "),n("p",[e._v("接下来我们就来一一拆解 Redux 在背后为我们做的这些事情。")]),e._v(" "),n("p",[e._v("首先要声明的是，为了把原理讲清楚，不可避免地会涉及到源码，但是源码有大量的类型判断和边界检查，如果一一列举，其一对我们理解 Redux 本身的原理没有帮助，其二分散我们的注意力、 浪费大量时间。因此凡是对我们理解 Redux 原理没有帮助的源码部分，我们不予考虑，如果真的很感兴趣可以 "),n("a",{attrs:{href:"https://github.com/reduxjs/redux",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitHub 仓库"),n("OutboundLink")],1),e._v(" 下载它的源码自己去看。")]),e._v(" "),n("h2",{attrs:{id:"createstore-揭秘"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#createstore-揭秘"}},[e._v("#")]),e._v(" createStore 揭秘")]),e._v(" "),n("p",[e._v("createStore，顾名思义，是要创建一个仓库，是 redux 的核心所在， 它最后要返回四个非常重要的属性，分别是 getState,subscribe,dispatch,replaceReducer。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default function createStore (reducer, preloadedState, enhancer) {\n  //...\n  return {\n    getState,// 获取到 state\n    subscribe,// 采用发布订阅模式，这个方法进行观察者的订阅\n    dispatch,// 派发 action\n    replaceReducer// 用新的 reducer 替换现在的\n  }\n}\n\n")])])]),n("p",[e._v("进入 createStore，第一步是检查参数，一共可以接收三个参数，reducer 表示改变 store 数据的纯函数，preloadedState 表示初始状态，第三个参数暂且不管，后面讲到中间件机制你就 明白它的用意了。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default function createStore (reducer, preloadedState, enhancer) {\n  //reducer 必须是函数\n  // 当前 reducer\n  let currentReducer = reducer\n  //state 数据，redux 的根本\n  let currentState = preloadedState\n  // 订阅者集合\n  let currentListeners = []\n  // 虽然不起眼，但是是一个关键的设计\n  let nextListeners = currentListeners\n  // 是否正在有 dispatch 在运行\n  let isDispatching = false\n\n  //...\n  //return 代码\n}\n\n")])])]),n("p",[e._v("首先看看它的 getState 方法:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function getState () {\n  // 如果有 dispatch 正在执行则报错\n  if (isDispatching) throw new Error ("xxxx 具体信息省略")\n  return currentState\n}\n\n')])])]),n("p",[e._v("它的 subscribe 方法其实是基于发布订阅模式的，我们想一想只有一个数组来存放订阅者的时候可能会出现什么问题。")]),e._v(" "),n("p",[e._v("假若有十个订阅者订阅了 store, 然后一旦条件触发 store 会依次执行所有的订阅者 (注意这里的订阅者 listener 都是方法，下面代码中的类型判断里面有提)。")]),e._v(" "),n("p",[e._v('这个时候第一个方法中干了一件特别 "孙子" 的事情，它把其他 9 个人全部退订了。那这个时候数组里面只剩下 1 个订阅者，但是循环还在继续啊，从数组后面的索引拿订阅者来执行，会报错，因为 已经不存在了。')]),e._v(" "),n("p",[e._v("当然还有更加复杂的情况，这些情况本质上是订阅者 (可以认为函数) 拥有订阅和退订的权利，也就是说，它可以改变订阅者数组。但是我们遍历订阅者的时候是基于最开始的那个订阅者数组。")]),e._v(" "),n("p",[e._v("因此我们需要缓存最开始的数组，在调用订阅者的时候，一切关于 currentListeners 的改变都不允许，但是可以拷贝一份同样的数组，让它来承担订阅者对数组的改变，那这个数组就是 nextListeners。")]),e._v(" "),n("p",[e._v("subscribe 方法如下定义:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function ensureCanMutateNextListeners () {\n  // 如果 next 和 current 数组是一个引用，那这种情况是危险的，原因上面已经谈到，我们需要 next 和 current 保持各自独立\n  if (nextListeners === currentListeners) {\n    nextListeners = currentListeners.slice ()\n  }\n}\n\nfunction subscribe (listener) {\n  if (typeof listener !== 'function') {\n    throw new Error ('Expected the listener to be a function.')\n  }\n  // 如果正在有 dispatch 执行则报错\n  if (isDispatching) {\n    throw new Error (\"xxx\")\n  }\n  let isSubscribed = true\n  ensureCanMutateNextListeners ()\n  nextListeners.push (listener)\n  // 返回的是一个退订的方法，将特定的 listener 从订阅者集合中删除\n  return function unsubscribe () {\n    // 已经退订了就不管了\n    if (!isSubscribed) return;\n    if (isDispatching) throw new Error (\"xxx 具体信息省略\")\n\n    isSubscribed = false\n    ensureCanMutateNextListeners ()\n    const index = nextListeners.indexOf (listener)\n    nextListeners.splice (index, 1)\n  }\n}\n\n")])])]),n("p",[e._v("值得注意的是每次调用这个函数的时候，都会产生一个闭包，里面存储着 isSubscribed 的值，调用 n 次就会产生 n 个这样的闭包，用来存储 n 个不同的订阅情况。 仔细想想还是比较巧妙的做法。")]),e._v(" "),n("p",[e._v("接下来是 dispatch 函数:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function dispatch (action) {\n  //action 必须是一个对象\n  //action.type 不能为 undefined\n\n  if (isDispatching) {\n    throw new Error ('Reducers may not dispatch actions.')\n  }\n\n  try {\n    isDispatching = true\n    // 看到没有？执行 reducer 后返回的状态直接成为 currentState 了\n    currentState = currentReducer (currentState, action)\n  } finally {\n    isDispatching = false\n  }\n\n  const listeners = (currentListeners = nextListeners)\n  for (let i = 0; i < listeners.length; i++) {\n    const listener = listeners [i]\n    listener ()\n  }\n\n  return action\n}\n\n")])])]),n("p",[e._v("接下来是 replaceReducer：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function replaceReducer (nextReducer) {\n  if (typeof nextReducer !== 'function') {\n    throw new Error ('Expected the nextReducer to be a function.')\n  }\n\n  currentReducer = nextReducer\n  // 此时无法匹配任何的 action，但是返回的状态可以将 currentState 给更新\n  // 也就是更新当前的 state，因为 reducer 更新了，老的 state 该换了！\n  dispatch ({ type: ActionTypes.REPLACE })\n}\n\n")])])]),n("h2",{attrs:{id:"combinereducer-做了些什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#combinereducer-做了些什么"}},[e._v("#")]),e._v(" combineReducer 做了些什么？")]),e._v(" "),n("p",[e._v("还记得我们怎么使用 combineReducer 的吗？")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import { combineReducers } from "redux-immutable";\nimport { reducer as recommendReducer } from "../application/Recommend/store/index";\nimport { reducer as singersReducer } from "../application/Singers/store/index";\n\nexport default combineReducers ({\n  recommend: recommendReducer,\n  singers: singersReducer,\n});\n\n\n')])])]),n("p",[e._v("combineReducer 用来组织不同模块的 reducer，那背后是怎么组织起来的呢？除去容错性的代码，我们看看 combineReducer 的核心源代码:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default function combineReducers (reducers) {\n  // 以项目中的例子来讲，reducerKeys 就是 ['recommend', 'singers']\n  const reducerKeys = Object.keys (reducers)\n  //finalReducers 是 reducers 过滤后的结果\n  // 确保 finalReducers 里面每一个键对应的值都是函数\n  const finalReducers = {}\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys [i]\n\n    if (typeof reducers [key] === 'function') {\n      finalReducers [key] = reducers [key]\n    }\n  }\n  const finalReducerKeys = Object.keys (finalReducers)\n\n  // 最后依然返回一个纯函数\n  return function combination (state = {}, action) {\n    // 这个标志位记录初始的 state 是否和经过 reducer 后是一个引用，如果不是则 state 被改变了\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys [i]\n      const reducer = finalReducers [key]\n      // 原来的状态树中 key 对应的值\n      const previousStateForKey = state [key]\n      // 调用 reducer 函数，获得该 key 值对应的新状态\n      const nextStateForKey = reducer (previousStateForKey, action)\n      nextState [key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    // 这个很简单理解吧？如果没改变直接把原始的 state 返回即可\n    return hasChanged ? nextState : state\n  }\n}\n\n\n")])])]),n("p",[e._v("很简单理解吧？好，我们现在进入最硬核的部分！")]),e._v(" "),n("h2",{attrs:{id:"compose-函数解读"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#compose-函数解读"}},[e._v("#")]),e._v(" compose 函数解读")]),e._v(" "),n("p",[e._v("compose 其实是一个工具，充分体现了高阶函数的技巧。源码如下:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default function compose (...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs [0]\n  }\n\n  return funcs.reduce ((a, b) => (...args) => a (b (...args)))\n}\n\n")])])]),n("p",[e._v("举个例子:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const f0 = (x) => { console.log (x) }\nconst f1 = () => { console.log (1) }\nconst f2 = () => { console.log (2) }\nlet fArr = [f2, f1, f0];\nconsole.log (compose (...fArr)(100)) // 执行 f2 (f1 (f0 (100))) 输出 100 1 2\n\n")])])]),n("p",[e._v("现在先埋下伏笔。之后在 applyMiddleware 中如何大显身手。")]),e._v(" "),n("h2",{attrs:{id:"applymiddleware-完全解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#applymiddleware-完全解析"}},[e._v("#")]),e._v(" applyMiddleware 完全解析")]),e._v(" "),n("p",[e._v("这个方法与中间件息息相关，一上来就干讲是很不容易理解的，现在我们以项目中用到的 redux-thunk 中间件为例来演示，先放出 redux-thunk 的源码 (你没看错，就这么一点儿):")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function createThunkMiddleware (extraArgument) {\n  // 这里将 middlewareAPI 给解构成了 { dispatch, getState }\n  return ({ dispatch, getState }) => next => action => {\n    if (typeof action === 'function') {\n      return action (dispatch, getState, extraArgument)\n    }\n\n    return next (action)\n  }\n}\n\nconst thunk = createThunkMiddleware ();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n\n")])])]),n("p",[e._v("现在我们来打开 applyMiddleware 的源代码:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default function applyMiddleware (...middlewares) {\n  return createStore => (...args) => {\n    const store = createStore (...args)\n    let dispatch = () => {\n      throw new Error (\n        'Dispatching while constructing your middleware is not allowed. ' +\n          'Other middleware would not be applied to this dispatch.'\n      )\n    }\n    //middlewareAPI 其实就是拿到 store 的信息\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch (...args)\n    }\n    // 参考上面的 thunk，其实就是传入 store 参数，剩下的部分为 next => action => { ... };\n    // 传入这个参数是必须的，因为需要拿到 store 的相关属性，如 thunk 拿了 getState\n    // 这里的意思就是每个中间件都能拿到 store 的数据\n    const chain = middlewares.map (middleware => middleware (middlewareAPI))\n    dispatch = compose (...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n\n")])])]),n("p",[e._v("加入现在还有一个 redux-logger 的中间件，调用 applyMiddleware (logger, thunk), 那么走到 compose 逻辑的时候，相当于 调用 logger (thunk (store.dispatch))。这样就完成了中间件的机制。仔细体会一下这中间的执行顺序，其实并不难。")]),e._v(" "),n("h2",{attrs:{id:"探究-createstore-留下来的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#探究-createstore-留下来的问题"}},[e._v("#")]),e._v(" 探究 createStore 留下来的问题")]),e._v(" "),n("p",[e._v("刚刚在 createStore 那一段提了下参数类型判断，但是第三个参数没有展开讲，那这里面究竟是如何来判断的呢？现在我觉得时机成熟了。")]),e._v(" "),n("p",[e._v("给出这一部分源代码:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default function createStore (reducer, preloadedState, enhancer) {\n  // 第二个参数为函数，但是第三个参数没传\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState  // 将第二个参数当做 enhancer \n    preloadedState = undefined\n  }\n  // 确保 enhancer 为函数\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error ('Expected the enhancer to be a function.')\n    }\n\n    return enhancer (createStore)(reducer, preloadedState)\n  }\n  //...\n}\n\n")])])]),n("p",[e._v("判断类型后返回 enhancer (...) 是针对什么样的场景的呢？")]),e._v(" "),n("p",[e._v("如果要用 thunk 中间件，那么 redux 官方文档是这么写的:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const store = createStore (reducer, applyMiddleware (thunk));\n\n")])])]),n("p",[e._v("看到没？这个时候其实 redux 内部的 enhancer 就变成了 applyMiddleware (thunk) 的结果。")]),e._v(" "),n("p",[e._v("运行流程其实变成了 applyMiddleware (thunk)(createStore)(reducer, preloadedState);")]),e._v(" "),n("p",[e._v("而返回的结果赋给了 store, 当前 store 中的 dispatch 属性已经成功被更改，一旦走入 dispatch，必然经过中间件。中间件成功地集成！")]),e._v(" "),n("p",[e._v("知道了原理后，相信你再写一个自己的 Redux 中间件也易如反掌了。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function createMyMiddleware (...arg) {\n  return ({ dispatch, getState }) => next => action => {\n    console.log ("我开发的 Redux 中间件")\n    return next (action);\n  }\n}\n\nconst myMiddleware = createMyMiddleware ()\n\nexport default myMiddleware;\n\n')])])]),n("p",[e._v("然后在 createStore 的时候应用:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import thunk from 'react-thunk';\nimport myMiddleware from 'my-middleware';\nconst store = createStore (reducer, applyMiddleware (thunk, myMiddleware));\n\n")])])]),n("p",[e._v("中间件里面具体编写什么内容，应该由业务场景来决定，这里就不展开了。")]),e._v(" "),n("h2",{attrs:{id:"redux-源码中一些有意思的工具函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redux-源码中一些有意思的工具函数"}},[e._v("#")]),e._v(" Redux 源码中一些有意思的工具函数")]),e._v(" "),n("h3",{attrs:{id:"_1-判断是否为普通的对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-判断是否为普通的对象"}},[e._v("#")]),e._v(" 1. 判断是否为普通的对象")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default function isPlainObject (obj) {\n  if (typeof obj !== 'object' || obj === null) return false\n\n  let proto = obj\n  while (Object.getPrototypeOf (proto) !== null) {\n    proto = Object.getPrototypeOf (proto)\n  }\n\n  return Object.getPrototypeOf (obj) === proto\n}\n\n")])])]),n("h3",{attrs:{id:"_2-生成随机字符串"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-生成随机字符串"}},[e._v("#")]),e._v(" 2. 生成随机字符串")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const randomString = () =>\n  Math.random ()\n    .toString (36)\n    .substring (7)\n    .split ('')\n    .join ('.')\n\n")])])]),n("p",[e._v("Redux 原理的解读就到这里了，其实理解它的源码也并没有那些难，但我觉得最重要还是将它的原理和使用结合起来，体会整个设计的思想，研究这些对个人的成长还有是很有帮助的，也希望这篇文章能够起到抛砖引玉的作用，让大家带着更多的好奇和兴趣去研究其他工具的原理，提升自己的思维层次和工程能力。大家加油！")])])}),[],!1,null,null,null);t.default=a.exports}}]);