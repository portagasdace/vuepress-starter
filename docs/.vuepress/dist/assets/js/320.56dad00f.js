(window.webpackJsonp=window.webpackJsonp||[]).push([[320],{677:function(n,t,e){"use strict";e.r(t);var s=e(42),a=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("blockquote",[e("p",[n._v("本节代码对应 GitHub 分支: chapter8")])]),n._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/sanyuan0704/react-cloud-music/tree/chapter8",target:"_blank",rel:"noopener noreferrer"}},[n._v("仓库传送门"),e("OutboundLink")],1)]),n._v(" "),e("p",[n._v("不是说两个播放器功能已经做完了吗？确实。但是作为一个精美的 APP，我们还要搞！事！情！")]),n._v(" "),e("p",[n._v("话不多说，直接上 gif 效果图：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/18/16dde187ddaf8cf6?w=368&h=666&f=gif&s=555679",alt:""}})]),n._v(" "),e("p",[n._v("是不是很酷炫？")]),n._v(" "),e("p",[n._v("这一节就让我们来开始来一波骚操作：）")]),n._v(" "),e("h2",{attrs:{id:"musicnote-动画组件封装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#musicnote-动画组件封装"}},[n._v("#")]),n._v(" musicNote 动画组件封装")]),n._v(" "),e("p",[n._v("我们先初始化组件:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//baseUI/music-note/index.js\nimport React, {useEffect, useImperativeHandle, useRef, forwardRef} from 'react';\nimport styled from'styled-components';\nimport { prefixStyle } from './../../api/utils';\nimport style from '../../assets/global-style';\n\nconst Container = styled.div`\n  .icon_wrapper {\n    position: fixed;\n    z-index: 1000;\n    margin-top: -10px;\n    margin-left: -10px;\n    color: ${style [\"theme-color\"]};\n    font-size: 14px;\n    display: none;\n    transition: transform 1s cubic-bezier (.62,-0.1,.86,.57);\n    transform: translate3d (0, 0, 0);\n    >div {\n      transition: transform 1s;\n    }\n  }\n`\n\nconst MusicNote = forwardRef ((props, ref) => {\n\n  const iconsRef = useRef ();\n  // 容器中有 3 个音符，也就是同时只能有 3 个音符下落\n  const ICON_NUMBER = 3;\n\n  const transform = prefixStyle (\"transform\");\n\n  // 原生 DOM 操作，返回一个 DOM 节点对象\n  const createNode = (txt) => {\n    const template = `<div class='icon_wrapper'>${txt}</div>`;\n    let tempNode = document.createElement ('div');\n    tempNode.innerHTML = template;\n    return tempNode.firstChild;\n  }\n\n  useEffect (() => {\n    for (let i = 0; i < ICON_NUMBER; i++){\n      let node = createNode (`<div class=\"iconfont\">&#xe642;</div>`);\n      iconsRef.current.appendChild (node);\n    }\n    // 类数组转换成数组，当然也可以用 [...xxx] 解构语法或者 Array.from ()\n    let domArray = [].slice.call (iconsRef.current.children);\n    domArray.forEach (item => {\n      item.running = false;\n      item.addEventListener ('transitionend', function () {\n        this.style ['display'] = 'none';\n        this.style [transform] = `translate3d (0, 0, 0)`;\n        this.running = false;\n\n        let icon = this.querySelector ('div');\n        icon.style [transform] = `translate3d (0, 0, 0)`;\n      }, false);\n    });\n    //eslint-disable-next-line\n  }, []);\n\n  return (\n    <Container ref={iconsRef}>\n    </Container>\n  )\n})\n\nexport default React.memo (MusicNote);\n\n")])])]),e("p",[n._v("接下来是下落动画的处理逻辑了:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('const startAnimation = ({x, y}) => {\n  for (let i = 0; i < ICON_NUMBER; i++) {\n    let domArray = [].slice.call (iconsRef.current.children)\n    let item = domArray [i]\n    // 选择一个空闲的元素来开始动画\n    if (item.running === false) {\n      item.style.left = x + "px";\n      item.style.top = y + "px";\n      item.style.display = "inline-block";\n\n      setTimeout (() => {\n        item.running = true;\n        item.style [transform] = `translate3d (0, 750px, 0)`;\n        let icon = item.querySelector ("div");\n        icon.style [transform] = `translate3d (-40px, 0, 0)`;\n      }, 20);\n      break;\n    }\n  }\n};\n// 外界调用的 ref 方法\nuseImperativeHandle (ref, () => ({\n  startAnimation\n}));\n\n')])])]),e("p",[n._v("解释一下我为什么要用定时器？")]),n._v(" "),e("ol",[e("li",[n._v("因为目前元素的 display 虽然变为了 inline-block, 但是元素显示出来需要・"),e("code",[n._v("浏览器的回流")]),n._v(" 过程，无法立即显示。 也就是说元素目前还是 "),e("code",[n._v("隐藏")]),n._v(" 的，那么 "),e("code",[n._v("元素的位置未知")]),n._v("，导致 transform 失效")]),n._v(" "),e("li",[n._v("用 setTimout 的本质将动画逻辑放到下一次的 "),e("code",[n._v("宏任务")]),n._v("。事实上，当本次的宏任务完成后， 会触发 "),e("code",[n._v("浏览器 GUI 渲染线程")]),n._v(" 的重绘工作，然后才执行下一次宏任务，那么下一次宏任务中元素就显示了，transform 便能生效。")])]),n._v(" "),e("p",[n._v("这个涉及 JS 的 eventLoop 机制，如果有点懵推荐一篇通俗易懂的 "),e("a",{attrs:{href:"https://juejin.im/post/5d5b4c2df265da03dd3d73e5",target:"_blank",rel:"noopener noreferrer"}},[n._v("文章"),e("OutboundLink")],1),n._v(":")]),n._v(" "),e("h2",{attrs:{id:"动画运用到组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动画运用到组件"}},[n._v("#")]),n._v(" 动画运用到组件")]),n._v(" "),e("p",[n._v("首先我们需要改造 SongsList 组件。SongsList 其实是一个相当关键的组件，在很多地方都需要复用，而且和播放器的数据有交互，因此单独封装成一个应用型的组件。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("import { changePlayList, changeCurrentIndex, changeSequecePlayList } from './../../application/Player/store/actionCreators';\nimport { connect } from 'react-redux';\n\n//...\nconst { changePlayListDispatch, changeCurrentIndexDispatch, changeSequecePlayListDispatch } = props;\n\n// 接受触发动画的函数\nconst { musicAnimation } = props;\n\nconst selectItem = (e, index) => {\n  changePlayListDispatch (songs);\n  changeSequecePlayListDispatch (songs);\n  changeCurrentIndexDispatch (index);\n  musicAnimation (e.nativeEvent.clientX, e.nativeEvent.clientY);\n}\n//...\n\n// 映射 dispatch 到 props 上\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    changePlayListDispatch (data){\n      dispatch (changePlayList (data));\n    },\n    changeCurrentIndexDispatch (data) {\n      dispatch (changeCurrentIndex (data));\n    },\n    changeSequecePlayListDispatch (data) {\n      dispatch (changeSequecePlayList (data))\n    }\n  }\n};\n\n// 将 ui 组件包装成容器组件\nexport default connect (null, mapDispatchToProps)(React.memo (SongsList));\n\n")])])]),e("p",[n._v("这样一来，我们就不用模拟 playList 的数据啦。我们把 player/reducer 中 defaultState 里的 playList 和 sequenceList 置为 []。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//player/index.js 中这份 mock 的代码也删除\nuseEffect (() => {\n  changeCurrentIndexDispatch (0);\n}, [])\n\n")])])]),e("h3",{attrs:{id:"歌手页音符实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#歌手页音符实现"}},[n._v("#")]),n._v(" 歌手页音符实现")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//Singer/index.js\nimport MusicNote from "../../baseUI/music-note/index";\n\n//...\nconst musicNoteRef = useRef ();\n\nconst musicAnimation = (x, y) => {\n  musicNoteRef.current.startAnimation ({ x, y });\n};\n\nreturn (\n  <CSSTransition>\n    <Contaniner>\n      //...\n        <SongsList\n          songs={songs}\n          showCollect={false}\n          musicAnimation={musicAnimation}\n        ></SongsList>\n      //...\n      <MusicNote ref={musicNoteRef}></MusicNote>\n    </Contaniner>\n  </CSSTransition>\n)\n\n')])])]),e("h3",{attrs:{id:"歌单详情页音符实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#歌单详情页音符实现"}},[n._v("#")]),n._v(" 歌单详情页音符实现")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//Album/index.js\nimport MusicNote from "../../baseUI/music-note/index";\n\n//...\nconst musicNoteRef = useRef ();\n\nconst musicAnimation = (x, y) => {\n  musicNoteRef.current.startAnimation ({ x, y });\n};\n\nreturn (\n  <CSSTransition>\n    <Contaniner>\n      //...\n        <SongsList\n          songs={currentAlbum.tracks}\n          collectCount={currentAlbum.subscribedCount}\n          showCollect={true}\n          showBackground={true}\n          musicAnimation={musicAnimation}\n        ></SongsList>\n      //...\n      <MusicNote ref={musicNoteRef}></MusicNote>\n    </Contaniner>\n  </CSSTransition>\n)\n\n')])])]),e("p",[n._v("现在就成功地集成了音符掉落的动画了！")])])}),[],!1,null,null,null);t.default=a.exports}}]);