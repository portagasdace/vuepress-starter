(window.webpackJsonp=window.webpackJsonp||[]).push([[321],{679:function(t,n,e){"use strict";e.r(n);var r=e(42),s=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("本节代码对应 GitHub 分支: chapter9")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/sanyuan0704/react-cloud-music/tree/chapter9",target:"_blank",rel:"noopener noreferrer"}},[t._v("仓库传送门"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_1-出现-mini-播放器时页面底部被遮挡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-出现-mini-播放器时页面底部被遮挡"}},[t._v("#")]),t._v(" 1. 出现 mini 播放器时页面底部被遮挡")]),t._v(" "),e("p",[t._v("问题如图:")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e0802235fe5aa9?w=368&h=173&f=gif&s=1218092",alt:""}})]),t._v(" "),e("p",[t._v("当 mini 播放器不出现的时候，还能够正常看到底部，但一出现，最下面就被遮住了，每个页都是如此。为什么？因为之前布局都是用 bottom: 0，但是在 mini 播放器出现后我们需要 改变这个 bottom 值，miniPlayer 高度为 60px，我们把 bottom 设为 60px，等于把下面的 60px 高度留给播放器。")]),t._v(" "),e("p",[t._v("因此对于每个页面 Container 的 bottom 值有无播放器需要分开处理。那怎么判断有无播放器出现呢？")]),t._v(" "),e("p",[t._v("有一个很简单的方式，就是判断当前 playList 的长度，如果大于 0 则正在播放，等于 0 则没有。")]),t._v(" "),e("p",[t._v("以 Recommend 组件为例:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Recommend (props){\n  const { songsCount } = props;\n  //...\n\n  <Content play={songsCount}>\n  //...\n}\n\nconst mapStateToProps = (state) => ({\n  //...\n  songsCount: state.getIn (['player', 'playList']).size,// 尽量减少 toJS 操作，直接取 size 属性就代表了 list 的长度\n});\n//...\n\n")])])]),e("p",[t._v("相应 style.js 中:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import styled from'styled-components';\n\nexport const Content = styled.div`\n  position: fixed;\n  top: 90px;\n  bottom: ${props => props.play > 0?\"60px\": 0};\n  width: 100%;\n`\n\n")])])]),e("p",[t._v("然后在 Singer、Singers、Rank、Album 组件中也是相同的操作，这里就不浪费篇幅了。大家可以自行完成，也可以参考 chapter8 分支的代码。")]),t._v(" "),e("h2",{attrs:{id:"_2-频繁切歌导致的异常"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-频繁切歌导致的异常"}},[t._v("#")]),t._v(" 2. 频繁切歌导致的异常")]),t._v(" "),e("p",[t._v("如果频繁切换歌曲，会出现这样的异常：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e08025e9568397?w=317&h=19&f=jpeg&s=3832",alt:""}})]),t._v(" "),e("p",[t._v("操作过快直接报错，这是完全无法接受的。所以我们必须究根溯源，把这个问题给解了。")]),t._v(" "),e("p",[t._v("解决的原理：其实从 audio 标签拿到 src 加载到能够播放之间有一个缓冲的过程，只有当控件能够播放时才能够切到下一首。如果在这个缓冲过程中切歌就会报错。")]),t._v(" "),e("p",[t._v("现在就来具体地来解决这个问题:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//Player/index.js\nconst songReady = useRef (true);\n\nuseEffect (() => {\n  if (\n    !playList.length ||\n    currentIndex === -1 ||\n    !playList [currentIndex] ||\n    playList [currentIndex].id === preSong.id ||\n    !songReady.current// 标志位为 false\n  )\n    return;\n  let current = playList [currentIndex];\n  setPreSong (current);\n  songReady.current = false; // 把标志位置为 false, 表示现在新的资源没有缓冲完成，不能切歌\n  changeCurrentDispatch (current);// 赋值 currentSong\n  audioRef.current.src = getSongUrl (current.id);\n  setTimeout (() => {\n    // 注意，play 方法返回的是一个 promise 对象\n    audioRef.current.play ().then (() => {\n      songReady.current = true;\n    });\n  });\n  togglePlayingDispatch (true);// 播放状态\n  setCurrentTime (0);// 从头开始播放\n  setDuration ((current.dt/ 1000) | 0);// 时长\n}, [playList, currentIndex]);\n\n")])])]),e("p",[t._v("同时再做一下异常处理:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('const handleError = () => {\n  songReady.current = true;\n  alert ("播放出错");\n};\n\n<audio\n  //...\n  onError={handleError}\n></audio>\n\n')])])]),e("p",[t._v("这样就能放心切歌，不会有报错啦！")])])}),[],!1,null,null,null);n.default=s.exports}}]);