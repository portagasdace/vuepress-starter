(window.webpackJsonp=window.webpackJsonp||[]).push([[314],{669:function(e,t,n){"use strict";n.r(t);var a=n(42),l=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("blockquote",[n("p",[e._v("本节代码对应 GitHub 分支: chapter7")])]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/sanyuan0704/react-cloud-music/tree/chapter7",target:"_blank",rel:"noopener noreferrer"}},[e._v("仓库传送门"),n("OutboundLink")],1)]),e._v(" "),n("h1",{attrs:{id:"交互逻辑实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#交互逻辑实现"}},[e._v("#")]),e._v(" 交互逻辑实现")]),e._v(" "),n("p",[e._v("JS 交互主要是滑动屏幕时的逻辑，现在有了 scroll 基础组件，我们可以直接写在 onScroll 的回调中。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<Scroll onScroll={handleScroll} ref={songScroll}>\n//...\n\n")])])]),n("p",[e._v("这里面需要一些 DOM 操作，我们先把 DOM 对象取出来。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import { HEADER_HEIGHT } from "./../../api/config";\nconst handleScroll = pos => {\n    let height = initialHeight.current;\n    const newY = pos.y;\n    const imageDOM = imageWrapper.current;\n    const buttonDOM = collectButton.current;\n    const headerDOM = header.current;\n    const layerDOM = layer.current;\n    const minScrollY = -(height - OFFSET) + HEADER_HEIGHT;\n\n    // 指的是滑动距离占图片高度的百分比\n    const percent = Math.abs (newY /height);\n\n}\n\n')])])]),n("p",[e._v("说明：在歌手页的布局中，歌单列表其实是没有自己的背景的，layerDOM 其实是起一个遮罩的作用，给歌单内容提供白色背景 因此在处理的过程中，随着内容的滚动，遮罩也跟着移动。")]),e._v(" "),n("p",[e._v("滑动主要分三种情况:")]),e._v(" "),n("ol",[n("li",[e._v("处理往下拉的情况，效果：图片放大，按钮跟着偏移")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('if (newY > 0) {\n  imageDOM.style ["transform"] = `scale (${1 + percent})`;\n  buttonDOM.style ["transform"] = `translate3d (0, ${newY}px, 0)`;\n  layerDOM.style.top = `${height - OFFSET + newY}px`;\n} \n\n')])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("往上滑动，但是遮罩还没超过 Header 部分")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('else if (newY >= minScrollY) {\n  layerDOM.style.top = `${height - OFFSET - Math.abs (newY)}px`;\n  // 这时候保证遮罩的层叠优先级比图片高，不至于被图片挡住\n  layerDOM.style.zIndex = 1;\n  imageDOM.style.paddingTop = "75%";\n  imageDOM.style.height = 0;\n  imageDOM.style.zIndex = -1;\n  // 按钮跟着移动且渐渐变透明\n  buttonDOM.style ["transform"] = `translate3d (0, ${newY}px, 0)`;\n  buttonDOM.style ["opacity"] = `${1 - percent * 2}`;\n} \n\n')])])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("往上滑动，但是遮罩超过 Header 部分")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("else if (newY < minScrollY) {\n  // 往上滑动，但是超过 Header 部分\n  layerDOM.style.top = `${HEADER_HEIGHT - OFFSET}px`;\n  layerDOM.style.zIndex = 1;\n  // 防止溢出的歌单内容遮住 Header\n  headerDOM.style.zIndex = 100;\n  // 此时图片高度与 Header 一致\n  imageDOM.style.height = `${HEADER_HEIGHT}px`;\n  imageDOM.style.paddingTop = 0;\n  imageDOM.style.zIndex = 99;\n}\n\n")])])]),n("p",[e._v("现在终于可以达到一个比较好的交互效果了。但是别忘了，handleScroll 作为一个传给子组件的方法，我们需要用 useCallback 进行包裹，防止不必要的重渲染。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const handleScroll = useCallback (pos => {\n  // 具体代码\n}, []);\n\n")])])])])}),[],!1,null,null,null);t.default=l.exports}}]);