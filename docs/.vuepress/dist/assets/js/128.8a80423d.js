(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{484:function(t,e,n){"use strict";n.r(e);var a=n(42),o=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"使用-bloc-对豆瓣电影app-进行重构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用-bloc-对豆瓣电影app-进行重构"}},[t._v("#")]),t._v(" 使用 BLoC 对豆瓣电影App 进行重构")]),t._v(" "),n("p",[t._v("本节使用 BLoc 对豆瓣电影 App 进行重构。")]),t._v(" "),n("h2",{attrs:{id:"重构后的工程路径"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#重构后的工程路径"}},[t._v("#")]),t._v(" 重构后的工程路径")]),t._v(" "),n("p",[t._v("StateManager/flutter_doubanmovie_bloc")]),t._v(" "),n("h2",{attrs:{id:"bloc-模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bloc-模式"}},[t._v("#")]),t._v(" BLoC 模式")]),t._v(" "),n("p",[t._v("BLoC 模式指的是一种开发模式，使用这种模式可以使代码的 UI 逻辑和业务逻辑完全分离，从而可以在多个平台（mobile、web、后台等）上重用代码，这里的代码重用指的是业务逻辑代码的重用。BLoC 模式第一次发表是在 2018 年的 DartConf 大会上，由 Google 的 Paolo Soares 和 Cong Hui 设计和提出。")]),t._v(" "),n("p",[t._v("BLoC 的全称是 "),n("strong",[t._v("B")]),t._v("usiness "),n("strong",[t._v("Lo")]),t._v("gic "),n("strong",[t._v("C")]),t._v("omponent，这个单词可以拆成两部分来看，第一部分是 Business Logic，就是业务逻辑，第二部分是 Component，就是组件，连起来就是业务逻辑组件，这里也可以看出 BLoC 其实指的就是业务逻辑组件，而且这里的业务逻辑组件是完全独立的，可以和 UI 逻辑进行完全分离。")]),t._v(" "),n("p",[t._v("BLoC 模式的核心思想是将 UI 逻辑和业务逻辑分开。在为了达到这一目的，BLoC 模式里使用了 "),n("code",[t._v("响应式编程")]),t._v("（Reactive Programming），先来介绍一下 "),n("code",[t._v("响应式编程")]),t._v("，看 "),n("code",[t._v("响应式编程")]),t._v(" 是如何实现 UI 逻辑和业务逻辑分离的。")]),t._v(" "),n("h3",{attrs:{id:"响应式编程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#响应式编程"}},[t._v("#")]),t._v(" 响应式编程")]),t._v(" "),n("p",[n("code",[t._v("响应式编程")]),t._v(" 使用异步数据流进行编程。在响应式编程里，所有的变化，不管是被动的还是主动的，比如 UI 的点击、变量的变化、数据请求等，都会向异步数据流管道里发送消息，同时，在其他地方会监听数据流，将会收到消息并产生适当的响应。")]),t._v(" "),n("p",[t._v("从这段描述里就可以看到，"),n("code",[t._v("响应式编程")]),t._v(" 里的数据不是通过参数传递来实现的，而是通过数据流管道来传送，因此数据的发送方和接收方就不需要有依赖关系，实现了解耦，这也是 UI 逻辑和业务逻辑分离的基础。")]),t._v(" "),n("h4",{attrs:{id:"代码所在位置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码所在位置"}},[t._v("#")]),t._v(" 代码所在位置")]),t._v(" "),n("p",[t._v("flutter_widget_demo/lib/reactive/CounterWidget.dart")]),t._v(" "),n("h4",{attrs:{id:"使用响应式编程开发"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用响应式编程开发"}},[t._v("#")]),t._v(" 使用响应式编程开发")]),t._v(" "),n("p",[t._v("Flutter 响应式编程的三元素是：")]),t._v(" "),n("ul",[n("li",[t._v("StreamController：数据流管道")]),t._v(" "),n("li",[t._v("StreamSink：发出消息")]),t._v(" "),n("li",[t._v("Stream：收到消息")])]),t._v(" "),n("p",[t._v("为了便于理解，这里写一个简单的例子：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import 'dart:async';\n\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(CounterWidget());\n\nclass CounterWidget extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() {\n    // TODO: implement createState\n    return CounterState();\n  }\n}\n\nclass CounterState extends State<CounterWidget> {\n  @override\n  Widget build(BuildContext context) {\n    // TODO: implement build\n    return MaterialApp(\n      title: \"Flutter Demo\",\n      theme: ThemeData(\n        primaryColor: Colors.blue,\n      ),\n      home: Scaffold(\n        appBar: AppBar(title: Text(\"Flutter 响应式编程\")),\n        body: Center(\n          child: Text('0'),\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}\n\n")])])]),n("p",[t._v("这里写了一个页面，中间是 Text，右下角还有一个 floatingActionButton，运行后的效果为：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/25/16aec36cd216e906?w=428&h=796&f=jpeg&s=29232",alt:""}})]),t._v(" "),n("p",[t._v("我们要在这个页面上使用响应式编程实现一个功能：点击 floatingActionButton，Text 里的值就会不断自增。我们需要实现响应式编程的三元素，首先在 StreamControlState 里实现 StreamController：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class CounterState extends State<CounterWidget> {\n\n  static final StreamController<int> _streamController =\n      StreamController<int>();\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: implement build\n    ...\n  }\n}\n\n")])])]),n("p",[t._v("StreamSink 通过 "),n("code",[t._v("_streamController.sink")]),t._v(" 获取，Stream 通过 "),n("code",[t._v("_streamController.stream")]),t._v(" 获取：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class CounterState extends State<CounterWidget> {\n\n  static final StreamController<int> _streamController =\n      StreamController<int>();\n  static final StreamSink<int> _sink = _streamController.sink;\n  static final Stream<int> _stream = _streamController.stream;\n  \n  ...\n}\n\n")])])]),n("p",[t._v("然后就可以通过 "),n("code",[t._v("_sink")]),t._v(" 发送消息，在 "),n("code",[t._v("_stream")]),t._v(" 处接受消息，这里你肯定会比较迷惑，发送一个消息，为什么搞的这么麻烦？这正是响应式编程的魅力所在，如果直接发送，那么就是同步的，如果要实现异步发送，按照正常的实现，就必须要写很多监听和回调，很容易陷入回调陷阱，而在响应式编程里，我们只需关心 "),n("code",[t._v("_sink")]),t._v(" 和 "),n("code",[t._v("_stream")]),t._v("，在 "),n("code",[t._v("_sink")]),t._v(" 里发送消息，在 "),n("code",[t._v("_stream")]),t._v(" 处接受消息，不需要写额外的监听和回调，StreamController 会帮我们处理，而且在 StreamController 里也可以对接受到的数据处理后在发送。")]),t._v(" "),n("p",[t._v("因为要写一个自增的功能，需要定义一个变量 "),n("code",[t._v("_count")]),t._v("，默认值为 0：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class CounterState extends State<CounterWidget> {\n  int _count = 0;\n\n  static final StreamController<int> _streamController =\n      StreamController<int>();\n  ...\n}\n\n")])])]),n("p",[t._v("在 floatingActionButton 点击的时候发送数据：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("floatingActionButton: FloatingActionButton(\n  child: Icon(Icons.add),\n  onPressed: () {\n    _sink.add(++_count);\n  },\n)\n\n")])])]),n("p",[t._v("Text 处接受信息，因为 Text 是 Widget，所以要使用 StreamBuilder：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("StreamBuilder(\n  stream: _stream,\n  initialData: 0,\n  builder: (context, snapShot) {\n    return Center(\n      child: Text('${snapShot.data}'),\n    );\n  },\n)\n\n")])])]),n("p",[t._v("StreamBuilder 里的 stream 赋值为 _stream，意思是接受 _stream 里的数据，initialData 为 0，表示默认的数据为 0，builder 里返回 Text，snapShot.data 表示的是接受到的数据。然后一个响应式编程的自增功能就实现了，点击 floatingActionButton，Text 里的数据就不断自增。")]),t._v(" "),n("p",[t._v("但是在这段代码里，floatingActionButton 里面还涉及到了具体的业务的逻辑：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("_sink.add(++_count);\n\n")])])]),n("p",[t._v("正确的做法应该是，floatingActionButton 不应该关心到底是自增还是自减这种具体的业务逻辑，它只要发送我被点击了这个通知，具体的业务逻辑在外面进行处理，所以这里可以这么改：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class CounterState extends State<CounterWidget> {\n  ...\n\n  @override\n  Widget build(BuildContext context) {\n\n    return MaterialApp(\n      ...\n        floatingActionButton: FloatingActionButton(\n          child: Icon(Icons.add),\n          onPressed: () {\n            _calculate();\n          },\n        ),\n      ...\n    );\n  }\n\n  void _calculate(){\n    _sink.add(++_count);\n  }\n}\n\n")])])]),n("p",[t._v("新增一个 "),n("code",[t._v("_calculate()")]),t._v(" 方法，在 floatingActionButton 里调用 "),n("code",[t._v("_calculate()")]),t._v(" 而不是直接使用 "),n("code",[t._v("_sink.add(++_count)")]),t._v("。这时候可能也有人有疑问，这不是闲着蛋疼吗，多写了一个方法，结果最后调用的代码都是一样的，不是变复杂了吗？")]),t._v(" "),n("p",[t._v("虽然确实多了几行代码，但是这几行代码对框架来说非常有意义，首先，floatingActionButton 就不用关心具体的业务，只负责发送事件；再者，假设功能由自增变为自减，在原来的代码里，你就得在 floatingActionButton 里把 ++ 改为 --，这里功能比较简单还好说，如果功能一旦复杂，这里修改就会比较麻烦，不仅破坏了原来的代码，使得功能不容易扩展，但是如果把 "),n("code",[t._v("_sink.add(++_count);")]),t._v(" 封装在 "),n("code",[t._v("_calculate()")]),t._v(" 方法里，这样如果功能有修改，只要在 "),n("code",[t._v("_calculate()")]),t._v(" 方法里写就好了，floatingActionButton 和 Text 都不会受影响。就因为多了这几行代码，floatingActionButton 和 Text 就不用关心业务，只需要做好 UI 展示就行，在保证了代码健壮性的同时也保证了代码的扩展性。")]),t._v(" "),n("p",[t._v("现在对这段代码画一个流程图：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/27/16af805991a8b007?w=1230&h=306&f=png&s=16229",alt:""}})]),t._v(" "),n("p",[t._v("在这个流程图里，floatingActionButton 被点击后，发送事件，触发 _calculate() 方法，_calculate() 方法负责业务逻辑，_count 自增，使用 sink 将数据发送出去， stream 收到数据 data，使 Text 用最新的 data 数据重建。")]),t._v(" "),n("p",[t._v("在这个流程里不仅用到了 "),n("code",[t._v("响应式编程")]),t._v("，为了将 floatingActionButton 和 Text 这两个 Widget 彻底和业务隔离，还抽象出了 _calculate() 方法和 data 数据，这两个进一步抽象，_calculate() 可以抽象成 event 事件，data 抽象成 state 状态。")]),t._v(" "),n("p",[t._v("接下来讲 BLoC 模式里的事件和状态流向图。")]),t._v(" "),n("h3",{attrs:{id:"bloc-模式里的事件和状态流向图"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bloc-模式里的事件和状态流向图"}},[t._v("#")]),t._v(" BLoC 模式里的事件和状态流向图")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/27/16af80bd2cbe3a04?w=1230&h=306&f=png&s=14084",alt:""}})]),t._v(" "),n("p",[t._v("上图是 BLoC 模式里的事件和状态流向图：")]),t._v(" "),n("ol",[n("li",[t._v("Widget 向 BLoC 发送事件")]),t._v(" "),n("li",[t._v("事件会触发 BLoC 里的 sink")]),t._v(" "),n("li",[t._v("然后 Stream 会把 State 通知给 Widget")])]),t._v(" "),n("p",[t._v("这里的 Event 是为了把 Widget 和具体的业务逻辑分离抽象出来的东西，State 就是 Widget 显示需要用到的数据，也是和业务逻辑分离的。")]),t._v(" "),n("p",[t._v("最终，由 BLoC 实现的业务逻辑层，具有以下的特点：")]),t._v(" "),n("ul",[n("li",[t._v("BLoC 依赖响应式编程")]),t._v(" "),n("li",[t._v("有 Event 和 State")])]),t._v(" "),n("p",[t._v("由此，BLoC 实现了业务逻辑层和 UI 逻辑的分离，为此带来了巨大的好处：")]),t._v(" "),n("ul",[n("li",[t._v("可以用对 App 影响最小的方式修改业务逻辑")]),t._v(" "),n("li",[t._v("可以修改 UI，而不用担心影响业务逻辑")]),t._v(" "),n("li",[t._v("更加方便单元测试")])]),t._v(" "),n("h3",{attrs:{id:"bloc-模式的架构图"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bloc-模式的架构图"}},[t._v("#")]),t._v(" BLoC 模式的架构图")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/27/16af81b6c86b3191?w=316&h=672&f=png&s=17893",alt:""}})]),t._v(" "),n("p",[t._v("上图是 BLoC 模式的架构图，看到这里你觉得和某个模式很像，没错就是 MVVM：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/27/16af820d7ce78716?w=700&h=676&f=png&s=31575",alt:""}})]),t._v(" "),n("p",[t._v("总共有四层，从上到下分别是：")]),t._v(" "),n("ul",[n("li",[t._v("UI Screen")]),t._v(" "),n("li",[t._v("BLoC")]),t._v(" "),n("li",[t._v("Repository")]),t._v(" "),n("li",[t._v("Network Provider")])]),t._v(" "),n("p",[t._v("Widget 对应的是 MVVM 里的 View，BLoC 对应的是 MVVM 里的 ViewModel，Repository 和 Network Provider 对应的是 MVVM 里的 Model。")]),t._v(" "),n("p",[t._v("从这里也可以看出，BLoC 其实指的是一种开发模式，BLoC 也有很多种实现，这里介绍一个第三方库 "),n("code",[t._v("flutter_bloc")]),t._v("，一个实现 BLoC 模式的 Flutter 库。")]),t._v(" "),n("h2",{attrs:{id:"flutter-bloc-的使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#flutter-bloc-的使用"}},[t._v("#")]),t._v(" flutter_bloc 的使用")]),t._v(" "),n("p",[n("code",[t._v("flutter_bloc")]),t._v(" 实现了 BLoC 模式，暴露出几个类，我们只要使用这几个类变可以轻松实现 BLoC 模式，这几个类分别是：")]),t._v(" "),n("ul",[n("li",[t._v("Bloc")]),t._v(" "),n("li",[t._v("BlocBuilder")]),t._v(" "),n("li",[t._v("BlocProvider")]),t._v(" "),n("li",[t._v("BlocProviderTree")]),t._v(" "),n("li",[t._v("BlocListener")]),t._v(" "),n("li",[t._v("BlocListenerTree")])]),t._v(" "),n("h4",{attrs:{id:"bloc"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bloc"}},[t._v("#")]),t._v(" Bloc")]),t._v(" "),n("p",[t._v("Bloc 类是用来实现如下模块的：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/27/16af827edee178ee?w=316&h=256&f=png&s=5306",alt:""}})]),t._v(" "),n("blockquote",[n("p",[t._v("在这里，请大家注意一下 BLoC 和 Bloc，BLoC 是大写，Bloc 是小写，BLoC 指的是 BLoC 开发模式，Bloc 指的是 BLoC 开发模式实现里的一个类。")])]),t._v(" "),n("p",[t._v("可以看到 Bloc 类里包含了 Event、State，也有 sink、stream 响应式编程，不过 sink、stream 响应式编程已经被 "),n("code",[t._v("flutter_bloc")]),t._v(" 框架实现，我们只要关心 Event 和 State 就行，这个在 Bloc 类的定义里也能体现出来，Bloc 类的定义为：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("abstract class Bloc<Event, State> {\n   ...\n}\n\n")])])]),n("p",[t._v("Bloc 类里有两个泛型：Event 和 State，Event 是从外部接受到的事件，State 是输出 Widget 关心的状态。")]),t._v(" "),n("p",[t._v("比如，要实现一个加减功能的 Bloc，那么我们可以这么实现：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("enum CounterEvent { increment, decrement }\n\nclass CounterBloc extends Bloc<CounterEvent, int> {\n  @override\n  int get initialState => 0;\n\n  @override\n  Stream<int> mapEventToState(CounterEvent event) async* {\n    switch (event) {\n      case CounterEvent.decrement:\n        yield currentState - 1;\n        break;\n      case CounterEvent.increment:\n        yield currentState + 1;\n        break;\n    }\n  }\n}\n\n")])])]),n("h4",{attrs:{id:"blocbuilder"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#blocbuilder"}},[t._v("#")]),t._v(" BlocBuilder")]),t._v(" "),n("p",[t._v("BlocBuilder 是一个 Widget，它的功能类似于前面讲的 StreamBuilder，但是使用起来更简单，BlocBuiler 监听 Bloc 的状态，当状态发生变化时，就重建 Widget，因此 BlocBuiler 有两个参数：Bloc 和 BlocWidgetBuilder，我们可以看一下 BlocBuiler 的构造函数：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const BlocBuilder({\n    Key key,\n    @required this.bloc,\n    @required this.builder,\n  })\n\n")])])]),n("p",[t._v("参数名字")]),t._v(" "),n("p",[t._v("参数类型")]),t._v(" "),n("p",[t._v("意义")]),t._v(" "),n("p",[t._v("必选 or 可选")]),t._v(" "),n("p",[t._v("key")]),t._v(" "),n("p",[t._v("Key")]),t._v(" "),n("p",[t._v("Widget 的标识")]),t._v(" "),n("p",[t._v("可选")]),t._v(" "),n("p",[t._v("bloc")]),t._v(" "),n("p",[t._v("Bloc<E, S>")]),t._v(" "),n("p",[t._v("监听已经实现的 Bloc 类")]),t._v(" "),n("p",[t._v("必选")]),t._v(" "),n("p",[t._v("builder")]),t._v(" "),n("p",[t._v("BlocWidgetBuilder")]),t._v(" "),n("p",[t._v("监听 Bloc 类里状态的变化，重建 Widget")]),t._v(" "),n("p",[t._v("必选")]),t._v(" "),n("p",[t._v("BlocWidgetBuilder 需要返回一个 Widget。")]),t._v(" "),n("p",[t._v("使用方法如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BlocBuilder(\n  bloc: BlocA(),\n  builder: (context, state) {\n    // return widget here based on BlocA's state\n    return WidgetA();\n  }\n)\n\n")])])]),n("h4",{attrs:{id:"blocprovider"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#blocprovider"}},[t._v("#")]),t._v(" BlocProvider")]),t._v(" "),n("p",[t._v("BlocProvider 是一个 Widget，可以将 Bloc 类提供给它的子 Widget。BlocProvider 经常用来作为依赖注入的部件，以便将单个 Bloc 类的实例，在多个 Widget 里共享。")]),t._v(" "),n("p",[t._v("使用方法如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BlocA blocA = BlocA();\n\nBlocProvider(\n  bloc: blocA,\n  child: ChildA(),\n)\n\n\nBlocProvider(\n  bloc: blocA,\n  child: ChildB(),\n)\n\n")])])]),n("p",[t._v("上面的使用方法，就将一个实例 blocA，分享到了 ChildA 和 ChildB 里。")]),t._v(" "),n("p",[t._v("然后如果想在 ChildA 或 ChildB 里拿到 BlocA 的实例，可以这么做：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BlocProvider.of<BlocA>(context)\n\n")])])]),n("h4",{attrs:{id:"blocprovidertree"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#blocprovidertree"}},[t._v("#")]),t._v(" BlocProviderTree")]),t._v(" "),n("p",[t._v("BlocProviderTree 也是一个 Widget，前面讲的 BlocProvider 是把一个 Bloc 实例共享到多个 Widget 里，有时候一个 Widget 也需要用到多个 Bloc。")]),t._v(" "),n("p",[t._v("假设 ChildA 需要用到 BlocA、BlocB、BlocC，如果用 BlocProvider 实现的话，就是：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BlocProvider<BlocA>(\n  bloc: BlocA(),\n  child: BlocProvider<BlocB>(\n    bloc: BlocB(),\n    child: BlocProvider<BlocC>(\n      value: BlocC(),\n      child: ChildA(),\n    )\n  )\n)\n\n")])])]),n("p",[t._v("使用 BlocProviderTree 可以把多个 BlocProvider 合成一个：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BlocProviderTree(\n  blocProviders: [\n    BlocProvider<BlocA>(bloc: BlocA()),\n    BlocProvider<BlocB>(bloc: BlocB()),\n    BlocProvider<BlocC>(bloc: BlocC()),\n  ],\n  child: ChildA(),\n)\n\n")])])]),n("h4",{attrs:{id:"bloclistener"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bloclistener"}},[t._v("#")]),t._v(" BlocListener")]),t._v(" "),n("p",[t._v("BlocListener 是一个 Widget，有两个参数：Bloc 和 BlocWidgetListener，类似于 BlocBuilder，需要接收一个 Bloc 类作为参数，但也有不同的地方， BlocBuilder 里的 BlocWidgetBuilder 需要返回 Widget，而 BlocWidgetListener 不用返回 Widget，它的返回类型是 void，所以用来做一些其他操作，例如：弹对话框、弹 SnackBar、跳转到新的页面等。")]),t._v(" "),n("p",[t._v("使用方法如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BlocListener(\n  bloc: _bloc,\n  listener: (context, state) {\n    if (state is Success) {\n      Navigator.of(context).pushNamed('/details');\n    }\n  }\n}\n\n")])])]),n("h4",{attrs:{id:"bloclistenertree"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bloclistenertree"}},[t._v("#")]),t._v(" BlocListenerTree")]),t._v(" "),n("p",[t._v("BlocListenerTree 是一个 Widget，用于将多个 BlockListener 合成一个 Widget。")]),t._v(" "),n("p",[t._v("例如：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BlocListener<BlocAEvent, BlocAState>(\n  bloc: BlocA(),\n  listener: (BuildContext context, BlocAState state) {},\n  child: BlocListener<BlocBEvent, BlocBState>(\n    bloc: BlocB(),\n    listener: (BuildContext context, BlocBState state) {},\n    child: BlocListener<BlocCEvent, BlocCState>(\n      bloc: BlocC(),\n      listener: (BuildContext context, BlocCState state) {},\n      child: ChildA(),\n    ),\n  ),\n)\n\n")])])]),n("p",[t._v("就可以用 BlocListenerTree 实现为：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BlocListenerTree(\n  blocListeners: [\n    BlocListener<BlocAEvent, BlocAState>(\n      bloc: BlocA(),\n      listener: (BuildContext context, BlocAState state) {},\n    ),\n    BlocListener<BlocBEvent, BlocBState>(\n      bloc: BlocB(),\n      listener: (BuildContext context, BlocBState state) {},\n    ),\n    BlocListener<BlocCEvent, BlocCState>(\n      bloc: BlocC(),\n      listener: (BuildContext context, BlocCState state) {},\n    ),\n  ],\n  child: ChildA(),\n)\n\n")])])]),n("h2",{attrs:{id:"使用-flutter-bloc-重构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用-flutter-bloc-重构"}},[t._v("#")]),t._v(" 使用 flutter_bloc 重构")]),t._v(" "),n("p",[t._v("接下来使用 "),n("code",[t._v("flutter_bloc")]),t._v(" 这个库对豆瓣电影App 进行重构。")]),t._v(" "),n("h4",{attrs:{id:"添加依赖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#添加依赖"}},[t._v("#")]),t._v(" 添加依赖")]),t._v(" "),n("p",[t._v("首先，在 pubspec.yaml 里添加 "),n("code",[t._v("flutter_bloc")]),t._v(" 库的依赖：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("dependencies:\n  ...\n  flutter_bloc: ^0.14.0\n\n")])])]),n("p",[t._v("在 VS Code 里使用快捷键保存后，会自动下载依赖库。")]),t._v(" "),n("h4",{attrs:{id:"目录调整"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#目录调整"}},[t._v("#")]),t._v(" 目录调整")]),t._v(" "),n("p",[t._v("然后开始重构，在 lib 根目录下新建一个 bloc 的文件夹和一个 ui 的文件夹，然后把除了 main.dart 的文件都移到 ui 的文件夹下，如图：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/27/16af8eba18eebe74?w=566&h=348&f=jpeg&s=19768",alt:""}})]),t._v(" "),n("p",[t._v("这样做的目的是把 bloc 和 ui 分开。")]),t._v(" "),n("h3",{attrs:{id:"bloc-的核心模块"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bloc-的核心模块"}},[t._v("#")]),t._v(" BLoC 的核心模块")]),t._v(" "),n("p",[t._v("现在开始写 BLoC 的核心模块，包括：")]),t._v(" "),n("ul",[n("li",[t._v("State")]),t._v(" "),n("li",[t._v("Event")]),t._v(" "),n("li",[t._v("Bloc")])]),t._v(" "),n("p",[t._v("在 bloc 文件夹下，新建一个文件 CityBloc.dart，BLoC 的核心模块都写到这个文件夹下。")]),t._v(" "),n("h4",{attrs:{id:"定义-state"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义-state"}},[t._v("#")]),t._v(" 定义 State")]),t._v(" "),n("p",[t._v("首先，要把共享的状态定义出来。因为有了前面两节重构的经验，这次我们直接对全局状态 "),n("code",[t._v("_curCity")]),t._v(" 进行重构，在 CityBloc.dart 里定义一个 CityState，代码为：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class CityState{\n  String _curCity;\n\n  get curCity => _curCity;\n\n  CityState(this._curCity);\n\n}\n\n")])])]),n("h4",{attrs:{id:"定义-evnet"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义-evnet"}},[t._v("#")]),t._v(" 定义 Evnet")]),t._v(" "),n("p",[t._v("在 CityBloc.dart 里定义一个 CityEvent，代码为：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\nclass CityState{\n  ...\n}\n\nclass CityEvent {\n  String _city;\n\n  get city => _city;\n\n  CityEvent(this._city);\n}\n\n")])])]),n("p",[t._v("CityEvent 用来更新当前选中的城市。")]),t._v(" "),n("h4",{attrs:{id:"写-bloc"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#写-bloc"}},[t._v("#")]),t._v(" 写 Bloc")]),t._v(" "),n("p",[t._v("然后在 CityBloc.dart 里开始写 Bloc 类，这里定义为 CityBloc，CityBloc 继承自 Bloc，代码为：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import 'package:bloc/bloc.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\n\n\nclass CityState{\n   ...\n}\n\nclass CityEvent {\n   ...\n}\n\nclass CityBloc extends Bloc<CityEvent, CityState> {\n\n  CityBloc() {\n    initData();\n  }\n\n  void initData() async {\n    final prefs = await SharedPreferences.getInstance(); //获取 prefs\n\n    String city = prefs.getString('curCity'); //获取 key 为 curCity 的值\n\n    dispatch(CityEvent(city));\n  }\n\n  @override\n  // TODO: implement initialState\n  get initialState => CityState(null); //默认值为空\n\n  @override\n  Stream<CityState> mapEventToState(CityEvent event) async*{\n    // TODO: implement mapEventToState\n    yield new CityState(event.city);\n  }\n}\n\n")])])]),n("p",[t._v("注意 CityBloc 实现里的泛型：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class CityBloc extends Bloc<CityEvent, CityState>\n\n")])])]),n("p",[t._v("代表的是接受的参数是 CityEvent，抛出的参数是 CityState，这里的 CityState 就是要共享的状态。")]),t._v(" "),n("p",[t._v("在 CityBloc 的默认构造函数里去读取本地的数据。initialState 里 CityState 的值默认为 null。")]),t._v(" "),n("p",[n("code",[t._v("mapEventToState")]),t._v(" 方法，是接受 Event，然后返回最新的状态。")]),t._v(" "),n("h3",{attrs:{id:"注入-bloc"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注入-bloc"}},[t._v("#")]),t._v(" 注入 Bloc")]),t._v(" "),n("p",[t._v("然后在 main.dart 里，给子 Widget 注入 CityBloc：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class _MyHomePageState extends State<MyHomePage> {\n  ...\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: BlocProvider<CityBloc>(\n        bloc: CityBloc(),\n        child: _widgetItems[_selectedIndex], //选中不同的选项显示不同的界面\n      ),\n      ...\n    );\n  }\n  ...\n}\n\n")])])]),n("p",[t._v("在 HotWidget 里使用 BlocBuilder 监听 CityBloc：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class HotWidgetState extends State<HotWidget> {\n  ...\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: implement build\n    print('HotWidgetState build');\n\n    return BlocBuilder(\n      bloc: BlocProvider.of<CityBloc>(context),\n      builder: (context, String curCity) {\n        if (curCity != null && curCity.isNotEmpty) {\n          //如果 curCity 不为空\n          ...\n        } else {\n          //如果 curCity 为空\n          ...\n        }\n      },\n    );\n  }\n\n  void _jumpToCitysWidget() async {\n    var selectCity =\n        await Navigator.pushNamed(context, '/Citys', arguments: BlocProvider.of<CityBloc>(context)..currentState.curCity);\n    if (selectCity == null) return;\n\n    final prefs = await SharedPreferences.getInstance();\n    prefs.setString('curCity', selectCity); //存取数据\n\n    //城市变化时，使用 CityBloc dispatch CityEvent\n    BlocProvider.of<CityBloc>(context).dispatch(CityEvent(selectCity));\n  }\n}\n\n")])])]),n("p",[t._v("当 CityBloc 状态发生变化时，就会创建 HotWidgetState 里的 Widget。这里在看一下 "),n("code",[t._v("_jumpToCitysWidget()")]),t._v(" 里的改动，在子 Widget 里通过 "),n("code",[t._v("BlocProvider.of<CityBloc>(context)")]),t._v(" 获取 CityBloc 实例，从而获取当前的城市：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BlocProvider.of<CityBloc>(context).currentState.curCity\n\n")])])]),n("p",[t._v("如果要改变城市，就是用 CityBloc 的 dispatch 方法：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BlocProvider.of<CityBloc>(context).dispatch(CityEvent(selectCity));\n\n")])])]),n("p",[t._v("CitysWidget 就不用重构了，因为 CitysWidget 采用参数传递的方法就没问题。至此，一个完整的 BLoC 模式的开发方式就展现在你的眼前。当然，我们的重构还没有结束，现在继续。")]),t._v(" "),n("h3",{attrs:{id:"hotmovieslistwidget-的-bloc-模式重构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hotmovieslistwidget-的-bloc-模式重构"}},[t._v("#")]),t._v(" HotMoviesListWidget 的 BLoC 模式重构")]),t._v(" "),n("p",[t._v("接下来对 HotMoviesListWidget 重构，这个是重点，因为 HotMoviesListWidget 里的状态是本地状态，而且前面两种方式对这里的重构，都不太好。")]),t._v(" "),n("p",[t._v("所以我们这里也要着重观察一下，BLoC 模式对本地状态的处理。")]),t._v(" "),n("p",[t._v("在 bloc 文件夹下新建文件 "),n("code",[t._v("HotMoviesListBloc")]),t._v("，代码为：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import 'package:bloc/bloc.dart';\nimport 'package:flutter_doubanmovie/bloc/HotMovieData.dart';\nimport 'package:flutter_doubanmovie/bloc/MoviesRepository.dart';\n\nclass HotMoviesListState{\n  List<HotMovieData> _list;\n\n  get list => _list;\n\n  HotMoviesListState(this._list);\n}\n\n\nclass HotMoviesEvent{\n  String _curCity;\n\n  get curCity => _curCity;\n\n  HotMoviesEvent(this._curCity);\n}\n\nclass HotMoviesListBloc extends Bloc<HotMoviesEvent,HotMoviesListState>{\n\n  final _movieRepository = MoviesRepository();\n\n  @override\n  // TODO: implement initialState\n  HotMoviesListState get initialState => HotMoviesListState(null);\n\n  @override\n  Stream<HotMoviesListState> mapEventToState(HotMoviesEvent event) async *{\n    // TODO: implement mapEventToState\n    List<HotMovieData> movies = await _movieRepository.fetchMoviesList(event.curCity);\n    yield HotMoviesListState(movies);\n  }\n\n}\n\n")])])]),n("p",[t._v("HotMoviesListBloc 和 CityBloc 类似，同样包含了：")]),t._v(" "),n("ul",[n("li",[t._v("State")]),t._v(" "),n("li",[t._v("Event")]),t._v(" "),n("li",[t._v("Bloc")])]),t._v(" "),n("p",[t._v("HotMoviesListBloc 接受的参数是 HotMoviesEvent，抛出的状态是 HotMoviesListState。")]),t._v(" "),n("p",[t._v("然后实现 MoviesRepository，同样在 bloc 文件夹下新建文件 MoviesRepository.dart，代码为：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import 'package:flutter_doubanmovie/bloc/HotMovieData.dart';\nimport 'package:flutter_doubanmovie/bloc/MoviesApiProvider.dart';\n\nclass MoviesRepository{\n  final _movieApiProvider = MoviesApiProvider();\n\n  Future<List<HotMovieData>> fetchMoviesList(String city) async {\n    return _movieApiProvider.fetchMoviesList(city);\n  }\n}\n\n")])])]),n("p",[t._v("在实现 MoviesApiProvider，同样在 bloc 文件夹下新建文件 MoviesApiProvider.dart，代码为：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import 'dart:convert';\n\nimport 'package:flutter_doubanmovie/bloc/HotMovieData.dart';\nimport 'package:http/http.dart' as http;\n\nclass MoviesApiProvider {\n  \n  Future<List<HotMovieData>> fetchMoviesList(String city) async {\n    List<HotMovieData> serverDataList = new List();\n    var response = await http.get(\n        'https://api.douban.com/v2/movie/in_theaters?apikey=0b2bdeda43b5688921839c8ecb20399b&city=' +\n            city +\n            '&start=0&count=10');\n    //成功获取数据\n    if (response.statusCode == 200) {\n      var responseJson = json.decode(response.body);\n      for (dynamic data in responseJson['subjects']) {\n        HotMovieData hotMovieData = HotMovieData.fromJson(data);\n        serverDataList.add(hotMovieData);\n      }\n    }\n\n    return serverDataList;\n  }\n}\n\n")])])]),n("p",[t._v("写完 HotMoviesListBloc 后，因为要给子 Widet 提供两个 bloc，所以在 main.dart 里改造为：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class _MyHomePageState extends State<MyHomePage> {\n  ...\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: BlocProviderTree(\n        blocProviders: [\n          BlocProvider<CityBloc>(bloc: CityBloc()),\n          BlocProvider<HotMoviesListBloc>(bloc: HotMoviesListBloc())\n        ],\n        child: _widgetItems[_selectedIndex], //选中不同的选项显示不同的界面\n      ),\n      ...\n    );\n  }\n  ...\n}\n\n")])])]),n("p",[t._v("HotMoviesListWidget 改为：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_doubanmovie/bloc/HotMoviesListBloc.dart';\nimport 'package:flutter_doubanmovie/ui/hot/hotlist/ui/item/HotMovieItemWidget.dart';\n\nclass HotMoviesListWidget extends StatefulWidget {\n\n  HotMoviesListWidget() {\n  }\n\n  @override\n  State<StatefulWidget> createState() {\n    // TODO: implement createState\n    return HotMoviesListWidgetState();\n  }\n}\n\nclass HotMoviesListWidgetState extends State<HotMoviesListWidget>\n    with AutomaticKeepAliveClientMixin {\n  @override\n  void initState() {\n    // TODO: implement initState\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: implement build\n\n    return BlocBuilder(\n      bloc: BlocProvider.of<HotMoviesListBloc>(context),\n      builder: (context,HotMoviesListState moviesListState) {\n        if (moviesListState == null || moviesListState.list == null || moviesListState.list.length == 0) {\n          return Center(\n            child: CircularProgressIndicator(),\n          );\n        } else {\n          return MediaQuery.removePadding(\n            removeTop: true,\n            context: context,\n            child: ListView.separated(\n              itemCount: moviesListState.list.length,\n              itemBuilder: (context, index) {\n                return HotMovieItemWidget(moviesListState.list[index]);\n              },\n              separatorBuilder: (context, index) {\n                return Divider(\n                  height: 1,\n                  color: Colors.black26,\n                );\n              },\n            ),\n          );\n        }\n      },\n    );\n  }\n\n  @override\n  // TODO: implement wantKeepAlive\n  bool get wantKeepAlive => true; //返回 true，表示不会被回收\n}\n\n\n")])])]),n("p",[t._v("这里首先把 HotMoviesListWidget 原来有参数的构造函数删掉了，这样 HotMoviesListWidget 彻底和业务隔开，它不需要知道现在是哪个城市，只需要显示就行，然后 HotMoviesListWidgetState 里的 build 改成了 BlocBuilder：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("return BlocBuilder(\n    bloc: BlocProvider.of<HotMoviesListBloc>(context),\n    builder: (context, HotMoviesListState moviesListState) {\n       ...\n    },\n);\n\n")])])]),n("p",[t._v("BlocBuilder 的 bloc 为 HotMoviesListBloc，builder 里的 moviesListState 就是 HotMoviesListWidget 的本地状态，里面有要展示的电影列表数据。")]),t._v(" "),n("p",[t._v("还有一个很关键的点，就是 HotMoviesListBloc 也需要一个地方，来发出事件，触发 HotMoviesListWidget 的重建，这里发出事件的地方选择在 HotWidget 里：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class HotWidgetState extends State<HotWidget> {\n  ...\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: implement build\n    print('HotWidgetState build');\n\n    return BlocBuilder(\n      bloc: BlocProvider.of<CityBloc>(context),\n      builder: (context, String curCity) {\n        if (curCity != null && curCity.isNotEmpty) {\n          //如果 curCity 不为空\n          BlocProvider.of<HotMoviesListBloc>(context)\n              .dispatch(HotMoviesEvent(curCity));\n          ...\n        \n        }\n        else {\n           ...\n        }\n      }\n    );\n }\n ...\n}\n\n")])])]),n("p",[t._v("至此，就重构完了，重构完后的目录结构为：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/27/16af925740de2fb9?w=802&h=908&f=jpeg&s=82743",alt:""}})])])}),[],!1,null,null,null);e.default=o.exports}}]);