(window.webpackJsonp=window.webpackJsonp||[]).push([[236],{588:function(e,t,a){"use strict";a.r(t);var s=a(42),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"实战篇-6-身份验证实现-使用-hapi-auth-jwt2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实战篇-6-身份验证实现-使用-hapi-auth-jwt2"}},[e._v("#")]),e._v(" 实战篇 6：身份验证实现 —— 使用 hapi-auth-jwt2")]),e._v(" "),a("p",[e._v("前一节，我们基本了解了 JWT 的技术特点、内容构成与安全校验等理论。这一节，我们先抛开小程序的场景使用特殊性，学习一种更为基础通用的 JWT 用户身份验证实现。小程序登录、微信微博第三方授权登录、短信验证码登录等，都是在该基础之上的二次开发。")]),e._v(" "),a("h2",{attrs:{id:"基于-jwt-的通用身份验证流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于-jwt-的通用身份验证流程"}},[e._v("#")]),e._v(" 基于 JWT 的通用身份验证流程")]),e._v(" "),a("p",[e._v("在实际的项目应用场景中，JWT 的身份验证流程大致如下：")]),e._v(" "),a("ol",[a("li",[e._v("用户使用用户名密码、或第三方授权登录后，请求应用服务器；")]),e._v(" "),a("li",[e._v("服务器验证用户信息是否合法；")]),e._v(" "),a("li",[e._v("对通过验证的用户，签发一个包涵用户 ID、其他少量用户信息（比如用户角色）以及失效时间的 JWT token；")]),e._v(" "),a("li",[e._v("客户端存储 JWT token，并在调用需要身份验证的接口服务时，带上这个 JWT token 值；")]),e._v(" "),a("li",[e._v("服务器验证 JWT token 的签发合法性，时效性，验证通过后，返回业务数据。")])]),e._v(" "),a("h2",{attrs:{id:"使用-jsonwebtoken-签发-jwt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-jsonwebtoken-签发-jwt"}},[e._v("#")]),e._v(" 使用 jsonwebtoken 签发 JWT")]),e._v(" "),a("p",[e._v("jsonwebtoken 是 Node.js 生态里用于签发与校验 JWT 的流行插件，本章节我们借助该插件来完成 JWT 字符串的生成签发。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("npm i jsonwebtoken\n\n")])])]),a("h3",{attrs:{id:"jwt-sign-签发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jwt-sign-签发"}},[e._v("#")]),e._v(" jwt.sign 签发")]),e._v(" "),a("p",[e._v("JWT 的签发语法是 "),a("code",[e._v("jwt.sign(payload, secretOrPrivateKey, [options, callback])")]),e._v("。默认的签发算法基于 HS256 (HMAC SHA256)，可以在 options 参数的 "),a("code",[e._v("algorithm")]),e._v(" 另行修改。JWT 签发规范中的一些标准保留字段比如 "),a("code",[e._v("exp")]),e._v("，"),a("code",[e._v("nbf")]),e._v("，"),a("code",[e._v("aud")]),e._v("，"),a("code",[e._v("sub")]),e._v("，"),a("code",[e._v("iss")]),e._v(" 等都没有默认值，可以一并在 payload 参数中按需声明使用，亦可以在第三个参数 options 中，通过 "),a("code",[e._v("expiresIn")]),e._v("，"),a("code",[e._v("notBefore")]),e._v("，"),a("code",[e._v("audience")]),e._v("，"),a("code",[e._v("subject")]),e._v("，"),a("code",[e._v("issuer")]),e._v(" 来分别赋值，但是不允许在两处同时声明。")]),e._v(" "),a("p",[e._v("下面是一个最简单的默认签发，1 小时后失效。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const jwt = require('jsonwebtoken');\n// 签发一条 1 小时后失效的 JWT\nconst token = jwt.sign(\n  {\n    foo: 'bar',\n    exp: Math.floor(Date.now() / 1000) + (60 * 60),\n  },\n  'your-secret'\n);\n\n")])])]),a("h3",{attrs:{id:"实现接口-post-users-createjwt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现接口-post-users-createjwt"}},[e._v("#")]),e._v(" 实现接口 POST /users/createJWT")]),e._v(" "),a("p",[e._v("继续完善我们的项目案例，实际应用中的 JWT 签发，我们会把便于识别用户的 userId 的信息，签发在 payload 中，并同时给予一个失效时间。")]),e._v(" "),a("p",[e._v("在 routes 目录下，新增一个 users.js 的路由，并增加一个 JWT 测试性质的签发接口定义 POST /users/createJWT。app.js 中记得将 users 路由模块注册引入。")]),e._v(" "),a("p",[e._v("注意: "),a("em",[e._v("jwt.sign 的第二个参数 secret 是一个重要的敏感信息，可以通过 .env 的配置 JWT_SECRET 来分离。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// routes/users.js\n\nconst JWT = require('jsonwebtoken');\n\nconst GROUP_NAME = 'users';\n\nmodule.exports = [{\n  method: 'POST',\n  path: `/${GROUP_NAME}/createJWT`,\n  handler: async (request, reply) => {\n    const generateJWT = (jwtInfo) => {\n      const payload = {\n        userId: jwtInfo.userId,\n        exp: Math.floor(new Date().getTime() / 1000) + 7 * 24 * 60 * 60,\n      };\n      return JWT.sign(payload, process.env.JWT_SECRET);\n    };\n    reply(generateJWT({\n      userId: 1,\n    }));\n  },\n  config: {\n    tags: ['api', GROUP_NAME],\n    description: '用于测试的用户 JWT 签发',\n    auth: false, // 约定此接口不参与 JWT 的用户验证，会结合下面的 hapi-auth-jwt 来使用\n  },\n}];\n\n\n")])])]),a("p",[e._v("访问 swagger-ui 测试 JWT 签发，可以得到 JWT 的测试签发结果。")]),e._v(" "),a("blockquote",[a("p",[e._v("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsImV4cCI6MTUzNTMyMjc0NSwiaWF0IjoxNTM0NzE3OTQ1fQ.6tOdn2R82bxJbXjAnwU5g4g9EKqGNe-qo4qCo6UZnQ4")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/20/1655452f9bba8239?w=1476&h=840&f=jpeg&s=155119",alt:""}})]),e._v(" "),a("p",[e._v("我们可以通过 "),a("a",{attrs:{href:"https://jwt.io",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://jwt.io"),a("OutboundLink")],1),e._v(" 来 decode JWT 中的 payload 信息，看能否拿到 userId。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/20/1655454c39e1d022?w=1720&h=878&f=jpeg&s=142959",alt:""}})]),e._v(" "),a("h2",{attrs:{id:"hapi-auth-jwt2-接口用户验证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hapi-auth-jwt2-接口用户验证"}},[e._v("#")]),e._v(" hapi-auth-jwt2 接口用户验证")]),e._v(" "),a("p",[e._v("接下来我们通过 hapi-auth-jwt2 插件，来赋予系统中的部分接口，需要用户登录授权后才能访问的能力。")]),e._v(" "),a("h3",{attrs:{id:"_1-安装-hapi-auth-jwt2-插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-安装-hapi-auth-jwt2-插件"}},[e._v("#")]),e._v(" 1. 安装 hapi-auth-jwt2 插件")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("npm i hapi-auth-jwt2@7\n\n")])])]),a("h3",{attrs:{id:"_2-引入-hapi-auth-jwt2-配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-引入-hapi-auth-jwt2-配置"}},[e._v("#")]),e._v(" 2. 引入 hapi-auth-jwt2 配置")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("├── plugins                       # hapi 插件配置\n│ ├── hapi-auth-jwt2.js           # jwt 配置插件\n\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const config = require('../config');\n\nconst validate = (decoded, request, callback) => {\n  let error;\n  /*\n    接口 POST /users/createJWT 中的 jwt 签发规则\n\n    const payload = {\n      userId: jwtInfo.userId,\n      exp: Math.floor(new Date().getTime() / 1000) + 7 * 24 * 60 * 60,\n    };\n    return JWT.sign(payload, process.env.JWT_SECRET);\n  */\n\n  // decoded 为 JWT payload 被解码后的数据\n  const { userId } = decoded;\n\n  if (!userId) {\n    return callback(error, false, userId);\n  }\n  const credentials = {\n    userId,\n  };\n  // 在路由接口的 handler 通过 request.auth.credentials 获取 jwt decoded 的值\n  return callback(error, true, credentials);\n};\n\nmodule.exports = (server) => {\n  server.auth.strategy('jwt', 'jwt', {\n    // 需要自行在 config/index.js 中添加 jwtSecret 的配置，并且通过 process.env.JWT_SECRET 来进行 .git 版本库外的管理。\n    key: config.jwtSecret,\n    validateFunc: validate,\n  });\n  server.auth.default('jwt');\n};\n\n\n")])])]),a("p",[e._v("在 app.js 中注册 hapi-auth-jwt2 插件。")]),e._v(" "),a("p",[e._v("hapi-auth-jwt2 的注册使用方式与其他插件略有不同，是在插件完成 register 注册之后，通过获取 server 实例后才完成最终的配置，所以，在代码书写上，存在一个先后顺序问题。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  const hapiAuthJWT2 = require('hapi-auth-jwt2');\n  const pluginHapiAuthJWT2 = require('./plugins/hapi-auth-jwt2');\n\n  const init = async () => {\n    // ... 省略上下文\n    await server.register([\n      hapiAuthJWT2\n    ])\n    pluginHapiAuthJWT2(server);\n    // ... 省略上下文\n  }\n\n")])])]),a("p",[e._v("一旦在 app.js 中，引入 hapi-auth-jwt 插件后，所有的接口都默认开启 JWT 认证，需要我们在接口调用的过程中，在 header 中添加带有 JWT 的 authorization 的字段。此时通过 Swagger 文档访问我们先前的 shops 任意接口，由于没有传输 JWT ，接口都会返回 "),a("code",[e._v("401")]),e._v(" 的错误。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  "statusCode": 401,\n  "error": "Unauthorized",\n  "message": "Missing authentication"\n}\n\n')])])]),a("p",[e._v("如果希望一些特定接口不通过 JWT 验证，比如店铺和商品列表并不希望用户登录后才能访问。可以在 router 中的 config 定义 auth=false 的配置，再通过 Swagger 文档试试对应配置的接口")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  config: {\n    auth: false,\n  }\n\n")])])]),a("p",[e._v("同步更新 validate 中针对 authorization 的 header 入参校验，在 Swagger 文档中也会同步自动更新。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("config: {\n  validate: {\n    headers: Joi.object({\n      authorization: Joi.string().required(),\n    }).unknown(),\n  }\n}\n\n")])])]),a("h3",{attrs:{id:"_3-迅速重构整理公共的-header-定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-迅速重构整理公共的-header-定义"}},[e._v("#")]),e._v(" 3. 迅速重构整理公共的 header 定义")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("├── utils                       # hapi 插件配置\n│ ├── router-helper.js          # 一个 helper 的工具类来实现公共代码\n\n")])])]),a("p",[e._v("utils/router-helper.js")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const Joi = require('joi')\n\nconst jwtHeaderDefine = {\n  headers: Joi.object({\n    authorization: Joi.string().required(),\n  }).unknown(),\n}\n\nmodule.exports = { jwtHeaderDefine }\n\n")])])]),a("p",[e._v("在需要使用到 authorization 的 header 配置处只需要使用如下语法即可：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("config: {\n  validate: {\n    ...jwtHeaderDefine\n  }\n}\n\n")])])]),a("h3",{attrs:{id:"_4-handler-中使用-jwt-的获取-userid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-handler-中使用-jwt-的获取-userid"}},[e._v("#")]),e._v(" 4. handler 中使用 JWT 的获取 userId")]),e._v(" "),a("p",[e._v("上文 3.2 中所提到的 plugins/hapi-auth-jwt2.js， 会通过 callback(error, true, credentials) 的第三个参数，将 JWT 解码过所需要露出的数据字段与值追加到 "),a("code",[e._v("request.auth")]),e._v(" 中，然后在路由 handler 的生命周期中，通过 "),a("code",[e._v("request.auth.credentials")]),e._v(" 来获取对应的信息。")]),e._v(" "),a("p",[e._v("我们使用 POST /users/createJWT 来生成一段 JWT。 再通过 tests/hello-hapi.js 的接口 tests/ 做一个实验性验证。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const { jwtHeaderDefine } = require('../utils/router-helper');\n\nmodule.exports = [\n  {\n    method: 'GET',\n    path: '/',\n    handler: (request, reply) => {\n      /*\n      plugins/hapi-auth-jwt2.js 中的 credentials 定义\n\n      const credentials = {\n        userId,\n      };\n      */\n      console.log(request.auth.credentials); // 控制台输出 { userId: 1}\n      reply('hello hapi');\n    },\n    config: {\n      tags: ['api', 'tests'],\n      description: '测试hello-hapi',\n      validate: {\n        ...jwtHeaderDefine, // 增加需要 jwt auth 认证的接口 header 校验\n      },\n    },\n  },\n];\n\n")])])]),a("p",[e._v("获取到其中的 userId 数据，后续就可以继续完成我们的业务逻辑流程了。")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("GitHub 参考代码")]),e._v(" "),a("a",{attrs:{href:"https://github.com/yeshengfei/hapi-tutorial/tree/master/chapter10/hapi-tutorial-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("chapter10/hapi-tutorial-1"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),a("p",[e._v("关键词：hapi-auth-jwt2，JWT 签发，JWT handler 解码")]),e._v(" "),a("p",[e._v("本小节，我们通过实现 POST /users/createJWT 的方法，来掌握 JWT 的签发实现。并且利用 hapi-auth-jwt2 插件，在不对路由配置做任何修改的前提下，来对系统中的所有接口统一赋能 JWT 用户验证。不需要验证的接口则通过 config.auth = false 的方式来标记放行。利用插件统一的用户验证机制，能够帮助我们更好地聚焦业务实现的本身。")]),e._v(" "),a("p",[e._v("思考：我们利用 swagger-ui 的调试功能，以几秒的时间间隔，从 /users/createJWT，先后获取两个不同的 JWT。最早获取的第一个 JWT，在当下的系统实现中，会否因为第二个 JWT 的签发而失效？背后的原因本质又是什么？")]),e._v(" "),a("p",[a("strong",[e._v("本小节参考代码汇总")])]),e._v(" "),a("p",[e._v("hapi-auth-jwt2 实现 JWT 用户身份验证： "),a("a",{attrs:{href:"https://github.com/yeshengfei/hapi-tutorial/tree/master/chapter10/hapi-tutorial-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("chapter10/hapi-tutorial-1"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);