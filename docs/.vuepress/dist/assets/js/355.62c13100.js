(window.webpackJsonp=window.webpackJsonp||[]).push([[355],{711:function(t,e,a){"use strict";a.r(e);var n=a(42),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"导读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#导读"}},[t._v("#")]),t._v(" 导读")]),t._v(" "),a("p",[t._v("本节标题：「建造毛坯」- 双端数据同构")]),t._v(" "),a("p",[t._v("本节主旨： 不可缺少的副作用处理，实现双端异步数据的获取，数据脱水，数据注水，重点在于如何利用同构来实现")]),t._v(" "),a("p",[t._v("本节配套代码：")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-dataiso",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-dataiso"),a("OutboundLink")],1)]),t._v(" "),a("h1",{attrs:{id:"正文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[t._v("#")]),t._v(" 正文")]),t._v(" "),a("p",[t._v("上一节我们实现了应用骨架的路由同构，这一节我们来实现非常重要的一个环节 - "),a("strong",[t._v("数据同构")]),t._v("。")]),t._v(" "),a("h1",{attrs:{id:"什么是数据同构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是数据同构"}},[t._v("#")]),t._v(" 什么是数据同构")]),t._v(" "),a("p",[t._v("整体来说，组件的一些数据需要从接口异步获取后进行渲染，数据同构就是服务端和客户端能够使用同一个数据请求处理方法（一套代码），同一份数据进行组件的渲染。")]),t._v(" "),a("p",[t._v("我们前面实现的组件直出只是将组件转换为了 "),a("code",[t._v("html")]),t._v("字符串，但是并没有具体的数据，顶多就是个静态页。")]),t._v(" "),a("p",[t._v("比如现在有这么一个需求，要从接口获取数据并且渲染到页面上。")]),t._v(" "),a("p",[t._v("以往在单页应用中，我们一般都将数据的数据的请求处理放在"),a("code",[t._v("compoentDidMount")]),t._v("生命周期内，得到数据后更改状态，随之渲染。")]),t._v(" "),a("p",[t._v("异步获取数据")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" \n  componentDidMount(){\n        ...\n        fetchData().then(res=>{\n            this.setState({\n                list:res.list\n            });\n        })\n    }\n\n\n")])])]),a("p",[t._v("在 "),a("code",[t._v("render")]),t._v(" 方法内组织数据")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" render() {\n        ....\n        let {list} = this.state;\n        .....\n        return <>\n        {list&&list.map(item=>{\n            return <div>{item.title}</div>\n        })}\n        </>\n    }\n\n")])])]),a("p",[t._v("上面的代码我们都非常熟悉，以上代码也能在 "),a("code",[t._v("ssr")]),t._v(" 模式中执行，但是无法得到我们期望的效果，数据只能在客户端得到，达不到数据直出的效果，查看网页源代码也没有我们想要的数据。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/12/31/16f59f29ddc061e1?w=830&h=383&f=png&s=92478",alt:""}})]),t._v(" "),a("p",[t._v("在小册开始的时候我们介绍过一些原理，"),a("code",[t._v("componentDidMount")]),t._v("生命周期只会在浏览器端执行，所以如果想让数据也能在服务端渲染就需要做一些特殊的处理。")]),t._v(" "),a("p",[t._v("接下来我们来实现 "),a("code",[t._v("react ssr")]),t._v(" 本应用骨架内的数据同构。")]),t._v(" "),a("h1",{attrs:{id:"数据预取"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据预取"}},[t._v("#")]),t._v(" 数据预取")]),t._v(" "),a("p",[t._v("在客户端，我们在"),a("code",[t._v("componentDidMount")]),t._v("生命周期内执行数据请求方法从接口拿到数据。")]),t._v(" "),a("p",[t._v("在服务端渲染组件的时候要想在直出的组件内容也包含数据，那就需要提前得到数据，然后将数据作为属性传递给组件，在"),a("code",[t._v("constructor")]),t._v("内对组件 "),a("code",[t._v("state")]),t._v(" 进行初始化。")]),t._v(" "),a("p",[t._v("当组件有了数据，服务端渲染直出的时候自然就会有数据。")]),t._v(" "),a("p",[a("strong",[t._v("以上这个在服务端渲染前得到数据的过程就是数据预取。")])]),t._v(" "),a("p",[a("strong",[t._v("思考两个问题：")])]),t._v(" "),a("p",[t._v("问题1：客户端和服务端组件渲染执行的声明周期不同，双端如何使用一套代码，代码如何组织呢？")]),t._v(" "),a("p",[t._v("问题2：真实开发中，浏览器的 "),a("code",[t._v("fetch api")]),t._v(" 无法在"),a("code",[t._v("node")]),t._v(" 端使用,如何统一呢？")]),t._v(" "),a("p",[t._v("以上两个问题都可以通过同构来解决。")]),t._v(" "),a("p",[t._v("先说问题2，因为比较简单，现在已经有很多同构的库来解决。")]),t._v(" "),a("p",[t._v("比如:"),a("code",[t._v("isomorphic-fetch")]),t._v("，"),a("code",[t._v("axios")]),t._v("，这里我推荐使用"),a("code",[t._v("axios")]),t._v(",对开发者非常友好，可以无差别使用。")]),t._v(" "),a("p",[t._v("那现在回到问题1，解决这个问题前需要回顾下以往的知识。")]),t._v(" "),a("p",[a("code",[t._v("js")]),t._v("里无论是函数还是类，到底都是函数，同时都是特殊的对象。")]),t._v(" "),a("p",[t._v("所以我们可以为这些函数添加属性，这个属性也可以被称作为类的静态方法。")]),t._v(" "),a("p",[t._v("静态方法有什么特点？")]),t._v(" "),a("p",[t._v("不需要实例化就可以访问,像下面这样。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Foo {\n   run(){\n       .....\n       console.log('hello');\n   }\n}\n\nFoo.method=function(){\n    console.log('hello method');\n}\n\n")])])]),a("p",[t._v("这有什么作用呢？")]),t._v(" "),a("p",[t._v("上面的代码可以在浏览器端执行，当然也可在 "),a("code",[t._v("node")]),t._v(" 端执行。")]),t._v(" "),a("p",[t._v("其实以上思路就是解决问题2的办法，可以把"),a("code",[t._v("Foo")]),t._v("想象成我们的"),a("code",[t._v("react")]),t._v(" 组件。")]),t._v(" "),a("p",[t._v("我们可以在 "),a("code",[t._v("node")]),t._v(" 端找到这个路由对应的组件，然后调用这个组件的静态方法来实现数据的预取。")]),t._v(" "),a("p",[a("strong",[t._v("梳理下完整的思路")])]),t._v(" "),a("ul",[a("li",[t._v("约定并为组件添加数据预取的静态方法")]),t._v(" "),a("li",[t._v("在服务端查找到当前路由对应的组件")]),t._v(" "),a("li",[t._v("调用组件的数据预取方法得到数据")]),t._v(" "),a("li",[t._v("将数据作为属性传入组件")]),t._v(" "),a("li",[t._v("组件内render做相应的处理")]),t._v(" "),a("li",[t._v("服务端直出组件")]),t._v(" "),a("li",[t._v("浏览器接管页面，完成渲染")])]),t._v(" "),a("h1",{attrs:{id:"手膜手实现数据同构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手膜手实现数据同构"}},[t._v("#")]),t._v(" 手膜手实现数据同构")]),t._v(" "),a("h2",{attrs:{id:"约定数据预取方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#约定数据预取方法"}},[t._v("#")]),t._v(" 约定数据预取方法")]),t._v(" "),a("p",[t._v("首先我们模拟一个异步获取数据的方法，返回一个列表数据。")]),t._v(" "),a("p",[t._v("我这里准备了一份从掘金采集的信息，作为假数据。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// ./src/client/pages/list/data.js\n\nconst data = [{\n    "title": "深入浅出TypeScript：从基础知识到类型编程",\n    "desc": "Vue3 源码及开发必备基础，从基础知识到类型工具设计，从理论到实战，手把手让你从零基础成为进阶使用者。",\n    "img": "https://user-gold-cdn.xitu.io/2019/11/8/16e4ab5d6aff406a?imageView2/1/w/200/h/280/q/95/format/webp/interlace/1"\n}, {\n    "title": "SVG 动画开发实战手册",\n    "desc": "从0到1，学习SVG动画开发知识，快速高效完成SVG动画效果开发。",\n    "img": "https://user-gold-cdn.xitu.io/2019/9/26/16d6bda264ac27e4?imageView2/1/w/200/h/280/q/95/format/webp/interlace/1"\n}, {\n    "title": "预售JavaScript 设计模式核⼼原理与应⽤实践",\n    "desc": "通俗易懂的编程“套路“学。带你深入看似高深实则接地气的设计模式原理，在实际场景中内化设计模式的”道“与”术“。学会驾驭代码，而非被其奴役。",\n    "img": "https://user-gold-cdn.xitu.io/2019/9/16/16d382e623923d91?imageView2/1/w/200/h/280/q/95/format/webp/interlace/1"\n}\n]\n\n')])])]),a("p",[t._v("另外我们约定所有页面组件内的数据预取方法为"),a("code",[t._v("getInitialProps")]),t._v(",用于双端调用。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//src/client/pages/list/index.js\n//List 页面 组件\n\nimport React from 'react';\nimport {Link} from 'react-router-dom';\n//导入  - 假数据\nimport tempData from './data';\n//组件\nexport default class Index extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n    //静态方法  数据预取方法\n    static async  getInitialProps() {\n        //模拟数据请求方法\n        const fetchData=()=>{\n            return new Promise(resolve=>{\n                setTimeout(() => {\n                    resolve({\n                        code:0,\n                        data: tempData\n                    })\n                }, 100);\n            })\n        }\n\n        let res = await fetchData();\n\n        return res;\n    }\n\n    handlerClick(){\n        alert('一起来玩 react 服务端渲染');\n    }\n\n    render() {\n        return <div onClick={this.handlerClick}>hello world。</div>\n    }\n}\n\n\n")])])]),a("p",[t._v("数据预取方法设置已完成，下一步需要在服务端调用这个方法。")]),t._v(" "),a("h2",{attrs:{id:"服务端数据预取实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端数据预取实现"}},[t._v("#")]),t._v(" 服务端数据预取实现")]),t._v(" "),a("p",[a("code",[t._v("server")]),t._v(" 端接到客户端的请求，通过"),a("code",[t._v("req url path")]),t._v(" 来进行路由匹配，然后得到需要渲染的组件后调用数据预取方法。")]),t._v(" "),a("h3",{attrs:{id:"路由如何匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由如何匹配"}},[t._v("#")]),t._v(" 路由如何匹配?")]),t._v(" "),a("p",[t._v("到这里我们又遇到了个问题 - 路由如何匹配。")]),t._v(" "),a("p",[t._v("每个路由都有 "),a("code",[t._v("path")]),t._v(" 属性，所以完全可以根据路由的 "),a("code",[t._v("path")]),t._v(" 去匹配。")]),t._v(" "),a("p",[t._v("最简单的方式无疑就是遍历路由配置，对比 "),a("code",[t._v("req path")]),t._v(" 和路由"),a("code",[t._v("path")]),t._v(" 。")]),t._v(" "),a("p",[t._v("参考代码")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//路由配置文件\n\nimport Index from '../pages/index';\nimport List from '../pages/list';\n\n\nexport default [\n\n    {\n        path:'/index',\n        component:Index\n    },\n    {\n        path: '/list',\n        component: List\n    }\n]\n\n\n//根据请求 path 查找路由\nconst matchRoute=(path,routeList)=>{\n    let route;\n    for(var item of routeList){\n        if(item.path===path){//路由匹配\n            route = item;\n        }\n        break;\n    }\n\n    return route;\n}\n\n\n")])])]),a("p",[t._v("上面的代码看着没什么问题,但只能处理静态路由，如果是动态路由的话上面的方法就无能为力了。")]),t._v(" "),a("p",[t._v("静态路由")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(' <Route path="/item"  exact={true} component={Item}></Route>\n\n')])])]),a("p",[t._v("动态路由")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<Route path="/item/:id"  exact={true} component={Root}></Route>\n\n')])])]),a("p",[t._v("当然我们都知道这种动态 "),a("code",[t._v("path")]),t._v(" 就需要正则来进行匹配了。")]),t._v(" "),a("p",[a("strong",[t._v("path-to-regexp")])]),t._v(" "),a("p",[t._v("此时我们就需要使用工具来处理了。")]),t._v(" "),a("p",[t._v("该工具库用来处理 "),a("code",[t._v("url")]),t._v(" 中地址与参数，可以将动态路径转换为所对应的正则。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const keys = [];\n\nconst regexp = pathToRegexp(\"/foo/:bar\", keys);\n\n// regexp = /^\\/foo\\/([^\\/]+?)\\/?$/i\n// keys = [{ name: 'bar', prefix: '/', suffix: '', pattern: '[^\\\\/#\\\\?]+?', modifier: '' }]\n\n")])])]),a("p",[t._v("还可以直接用于路径匹配")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const regexp = pathToRegexp(\"/:foo/:bar\");\n// keys = [{ name: 'foo', prefix: '/', ... }, { name: 'bar', prefix: '/', ... }]\n \nregexp.exec(\"/test/route\");\n//=> [ '/test/route', 'test', 'route', index: 0, input: '/test/route', groups: undefined ]\n\n")])])]),a("p",[t._v("说到这里相信我们的问题已经解决了。")]),t._v(" "),a("p",[t._v("不过上面只是介绍下原理，具体的应用其实"),a("code",[t._v("react-router")]),t._v("内已经内置了，而且内部处理机制也是利用"),a("code",[t._v("pathToRegexp")]),t._v("这个库。")]),t._v(" "),a("p",[a("strong",[t._v("matchPath 方法")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import { matchPath } from "react-router";\n\n')])])]),a("p",[t._v("该方法主要就是用于路由的匹配。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('const match = matchPath("/users/123", {\n  path: "/users/:id",\n  exact: true,\n  strict: false\n});\n\n')])])]),a("p",[t._v("完善下组件匹配方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//根据请求 path 匹配路由，结果返回该路由\nconst matchRoute=(opt)=>{\n    let {path} = opt;\n    let route;\n    for(var item of routeList){\n       if(matchPath(path,item)){\n        route = item;\n        break;\n       }\n    }\n    return route;\n}\n\n")])])]),a("p",[a("strong",[t._v("完成数据预取")])]),t._v(" "),a("ul",[a("li",[t._v("查找到组件后，调用组件的数据预取方法得到数据")]),t._v(" "),a("li",[t._v("得到数据后，将数据传递给组件")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export default  async (ctx,next)=>{\n\n    const path = ctx.request.path;\n\n    //查找到的目标路由对象\n    let targetRoute = matchRoute(path,routeList);\n\n    //数据预取 -> fetchResult\n    let fetchDataFn = targetRoute.component.getInitialProps;\n    let fetchResult = {};\n    if(fetchDataFn){\n        fetchResult = await fetchDataFn();\n    }\n\n     //将预取数据在这里传递过去 组内通过props.staticContext获取\n    const context = {\n        initialData: fetchResult\n    };\n\n    html = renderToString(<StaticRouter location={path} context={context}>\n        <App routeList={routeList}></App>\n    </StaticRouter>);\n    //....\n\n    await next();\n}\n\n")])])]),a("h2",{attrs:{id:"组件-render-逻辑处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件-render-逻辑处理"}},[t._v("#")]),t._v(" 组件 render 逻辑处理")]),t._v(" "),a("p",[t._v("组件从"),a("code",[t._v("props.staticContext.initialData")]),t._v("得到数据。")]),t._v(" "),a("p",[a("code",[t._v("render")]),t._v("方法增加渲染逻辑")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//list 页面 组件\nexport default class Index extends React.Component {\n    constructor(props) {\n        super(props);   \n        //得到初始化数据\n        + initialData = props.staticContext.initialData||{};\n        \n        + this.state=initialData;\n    }\n\n    static async  getInitialProps() {\n        //...\n    }\n\n    render() {\n        //渲染逻辑\n        + const {code,data}=this.state;\n        \n        return <div>\n        + {data && data.map((item,index)=>{\n            return <div key={index}>\n                <h3>{item.title}</h3>\n                <p>{item.desc}</p>\n            </div>\n        })}\n        {!data&&<div>暂无数据</div>}\n        </div>\n    }\n}\n\n")])])]),a("p",[t._v("到这里，服务端的数据直出就处理完成了，查看网页源代码已经能看到直出的数据。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/2/16f66a00d7a31c23?w=699&h=454&f=png&s=337886",alt:""}})]),t._v(" "),a("p",[t._v("但是如果查看页面效果的话，页面内容会一闪而过，最终页面只显示一个"),a("code",[t._v("暂无数据")]),t._v(" 。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/12/31/16f57be0705b4ac8?w=1000&h=1068&f=png&s=255526",alt:""}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/2/16f66ad212f41af6?w=500&h=375&f=png&s=20589",alt:""}})]),t._v(" "),a("h1",{attrs:{id:"数据脱水"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据脱水"}},[t._v("#")]),t._v(" 数据脱水")]),t._v(" "),a("p",[t._v("继续分析，出现以上问题的原因。")]),t._v(" "),a("p",[t._v("导致这个问题的原因是因为在浏览器端进行渲染的时候，没有该数据。")]),t._v(" "),a("p",[t._v("结果导致双端节点对比失败，最终采用的是客户端的渲染结果。")]),t._v(" "),a("p",[t._v("所以，浏览器端也需要有相同的数据，使组件可以渲染出和服务端相同的结构，才能够通过双端节点对比。才不会被客户端的结构覆盖,从而使用服务端直出的 "),a("code",[t._v("html")]),t._v(" 结构。")]),t._v(" "),a("p",[a("strong",[t._v("浏览器端组件渲染前如何才能得到服务端的数据呢？")])]),t._v(" "),a("p",[a("strong",[t._v("得到了数据如何传递给组件呢？")])]),t._v(" "),a("p",[t._v("第一排除通过接口请求，那就是重复请求了,没意义。")]),t._v(" "),a("p",[t._v("服务端返回相应数据后页面就被浏览器接管了，所以只能在接管之前做一些操作。")]),t._v(" "),a("p",[t._v("我们可以直接把数据也吐给浏览器，将数据序列化后作为字符串直出到页面，这样在浏览器端就可以在组件渲染前很方便的得到数据。")]),t._v(" "),a("p",[t._v("为了防止 "),a("code",[t._v("xss")]),t._v(" 攻击，咱们这里将数据放到了"),a("code",[t._v("textarea")]),t._v("标签内。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('//...\n\n    ctx.body=`<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>my react ssr</title>\n</head>\n<body>\n    <div id="root">\n       ${html}\n    </div>\n    + <textarea id="ssrTextInitData" style="display:none;">\n    ${JSON.stringify(fetchResult)}\n    </textarea>\n</body>\n</html>\n</body>\n\n//.....\n\n')])])]),a("p",[t._v("ok，经过我们上面的分析和实现，我们在直出组件的时候同时将数据源也输出给浏览器，而这个过程就叫做"),a("code",[t._v("数据脱水")]),t._v("。")]),t._v(" "),a("h1",{attrs:{id:"数据注水"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据注水"}},[t._v("#")]),t._v(" 数据注水")]),t._v(" "),a("p",[t._v("现在还差最后一步，浏览器端得到了数据后，如何使用该数据呢？")]),t._v(" "),a("ul",[a("li",[t._v("浏览器端在组件渲染前，得到初始化数据")]),t._v(" "),a("li",[t._v("将数据作为属性传递给组件")])]),t._v(" "),a("h2",{attrs:{id:"得到初始化数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#得到初始化数据"}},[t._v("#")]),t._v(" 得到初始化数据")]),t._v(" "),a("p",[t._v("这个很简单了，直接上代码")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//初始数据\nlet initialData =JSON.parse( document.getElementById('ssrTextInitData').value);\n\n")])])]),a("h2",{attrs:{id:"将数据作为属性传递给组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#将数据作为属性传递给组件"}},[t._v("#")]),t._v(" 将数据作为属性传递给组件")]),t._v(" "),a("p",[t._v("如何将数据作为属性传递给组件呢？")]),t._v(" "),a("p",[t._v("方法其实有很多种，下面算是其中一个方法。")]),t._v(" "),a("p",[t._v("可以根据当前的 "),a("code",[t._v("path")]),t._v("匹配到目标路由，然后在路由的"),a("code",[t._v("render")]),t._v("方法内将数据传递给组件即可。")]),t._v(" "),a("p",[t._v("ps:因为在服务端渲染的时候我们传入初始数据的属性为"),a("code",[t._v("initialData")]),t._v(",所以客户端最好使用同一个属性来传递。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// ./src/client/app/index.js\n//浏览器端页面结构渲染入口\n\nimport React from 'react';\nimport ReactDom from 'react-dom';\nimport App from '../router/index';\nimport { BrowserRouter} from 'react-router-dom';\nimport routeList from '../router/route-config';\n\nfunction clientRender() {\n    //初始数据\n    let initialData =JSON.parse( document.getElementById('ssrTextInitData').value);\n\n    //查找路由\n    let route = matchRoute(document.location.pathname,routeList);\n\n    //设置组件初始化数据 [关键点]\n    route.initialData =initialData;\n\n    //渲染index\n    ReactDom.hydrate(<BrowserRouter>\n            <App routeList={routeList}/>\n    </BrowserRouter>\n        , document.getElementById('root'))\n\n}\n//渲染入口\nclientRender();\n\n\n")])])]),a("p",[t._v("然后看下在"),a("code",[t._v("App")]),t._v("组件内做的一些处理。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('function App({routeList}) {\n    return (\n            <Layout> \n               <Switch>\n                {\n                    routeList.map(item=>{\n                        //判断是否有初始数据\n                        return item.initialData ? <Route key={item.path} exact={item.exact} path={item.path}  render={(props)=>{\n                            props.initialData = item.initialData;\n                            return <item.component {...props}></item.component>\n                        }}></Route> : <Route key={item.path} {...item}></Route>\n                    })\n                }\n                <Route to="*" component={Page404}></Route>\n            </Switch>\n            </Layout>\n    );\n}\n\n')])])]),a("p",[t._v("到这里，我们进入到"),a("code",[t._v("/list")]),t._v("页面,它的渲染结果已经正常，数据也能够正常的显示。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/12/31/16f57cab0429996d?w=1000&h=946&f=png&s=234480",alt:""}})]),t._v(" "),a("p",[t._v("这个将数据和组件调和渲染的过程就是"),a("code",[t._v("数据注水")]),t._v("。")]),t._v(" "),a("h1",{attrs:{id:"彻底解决问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#彻底解决问题"}},[t._v("#")]),t._v(" 彻底解决问题")]),t._v(" "),a("p",[t._v("到这里，首次访问的结果是正常了，但是仍然有问题，在这里我们彻底解决它。")]),t._v(" "),a("p",[t._v("在上图中我们页面中有两个链接，分别是首页和列表页。")]),t._v(" "),a("p",[t._v("上面访问的是"),a("code",[t._v("/list")]),t._v("列表页，但是如果我们第一次就访问"),a("code",[t._v("/index")]),t._v("路由，再点击列表页链接，列表页的数据竟然消失了。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/12/31/16f5a22c7535e623?w=500&h=375&f=png&s=21762",alt:""}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/12/31/16f5a233370d47ab?w=500&h=375&f=png&s=26541",alt:""}})]),t._v(" "),a("p",[t._v("这是什么原因？")]),t._v(" "),a("p",[t._v("我们都知道首次进入页面走服务端 "),a("code",[t._v("ssr")]),t._v("，后续访问就"),a("code",[t._v("spa")]),t._v("。")]),t._v(" "),a("p",[t._v("现在列表页的数据只能在"),a("code",[t._v("ssr")]),t._v(" 模式下才能拿到，如果是 "),a("code",[t._v("spa")]),t._v(" 就拿不到了。")]),t._v(" "),a("p",[t._v("如何处理？")]),t._v(" "),a("p",[t._v("这个就比较简单了，和我们平时开发"),a("code",[t._v("spa")]),t._v("一样。")]),t._v(" "),a("p",[t._v("我们可以在"),a("code",[t._v("componentDidMount")]),t._v("内获取数据然后更新 "),a("code",[t._v("state")]),t._v("。")]),t._v(" "),a("p",[t._v("ps: 实现比较简单，但是需要做个容错，判断下是否有初始化数据，以免重复请求，浪费资源。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  componentDidMount(){\n        if(!this.state.data){//判断是否有初始化数据\n            //进行数据请求\n            Index.getInitialProps().then(res=>{\n                this.setState({\n                    data:res.data||[]\n                })\n            })\n        }\n    }\n\n")])])]),a("p",[t._v("到这里，页面的整体数据同构渲染已经完成，效果已经达到预期。")]),t._v(" "),a("h1",{attrs:{id:"公共方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#公共方法"}},[t._v("#")]),t._v(" 公共方法")]),t._v(" "),a("p",[t._v("上面的实现过程中，服务端和浏览器端都用到了路由的匹配，所以我们可以将这个方法提出来，供双端调用。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\n// src/share/match-route.js\n// 根据 path， 匹配路由 \n\nimport { matchPath} from 'react-router';\n\nexport default (path,routeList)=>{ \n        let route;\n        for (var item of routeList) {\n            if (matchPath(path, item)) {\n                route = item;//查找到第一个路由后停止查找\n                break;\n            }\n        }\n        return  route;\n}\n\n")])])]),a("h1",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[t._v("本节主要使用一个小需求来抛砖引玉，带出来了一系列的问题，让我们逐步的分析和实现了数据同构。")]),t._v(" "),a("p",[t._v("关键步骤如下:")]),t._v(" "),a("ul",[a("li",[t._v("方法同构： 为组件声明"),a("code",[t._v("getInitialProps")]),t._v("静态方法，这是一个同构方法，用于双端的数据获取")]),t._v(" "),a("li",[t._v("数据预取：在服务端通过路由匹配找到目标的组件，然后调用组件的数据预取方法得到数据")]),t._v(" "),a("li",[t._v("将初始化数据作为属性传递给组件")]),t._v(" "),a("li",[t._v("数据脱水：将数据序列化,和 "),a("code",[t._v("html")]),t._v("字符串 一起直出返回给浏览器端")]),t._v(" "),a("li",[t._v("数据注水:浏览器端得到服务端直出的数据，也通过属性将数据传给组件")]),t._v(" "),a("li",[t._v("如果初始化数据不存在，则可以在"),a("code",[t._v("componentDidMount")]),t._v("生命周期内请求一次数据")])]),t._v(" "),a("p",[t._v("本节内容较多，但并不复杂，重要的是理清思路。")]),t._v(" "),a("p",[t._v("本节代码已上传")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-dataiso",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-dataiso"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("感谢你的阅读。")]),t._v(" "),a("p",[t._v("如果有问题欢迎留言，也欢迎在留言区留下你的想法和思考。")])])}),[],!1,null,null,null);e.default=s.exports}}]);