(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{477:function(e,t,a){"use strict";a.r(t);var r=a(42),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"flutter-性能监控工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flutter-性能监控工具"}},[e._v("#")]),e._v(" Flutter 性能监控工具")]),e._v(" "),a("p",[e._v("写完 Flutter APP 后，在发布之前，需要对 APP 的性能进行测试，这部分就讲一下 Flutter 的性能监控工具。")]),e._v(" "),a("p",[e._v("本次所讲的 Flutter 性能监控工具有两个：")]),e._v(" "),a("ol",[a("li",[e._v("PerformanceOverlay")]),e._v(" "),a("li",[e._v("Observatory")])]),e._v(" "),a("h2",{attrs:{id:"performanceoverlay-介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#performanceoverlay-介绍"}},[e._v("#")]),e._v(" PerformanceOverlay 介绍")]),e._v(" "),a("p",[e._v("PerformanceOverlay 是在 app 上显示性能统计数据的浮窗。PerformanceOverlay 是一个 Widget，有几个属性，用于控制开启哪些功能。")]),e._v(" "),a("h3",{attrs:{id:"performanceoverlay-分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#performanceoverlay-分析"}},[e._v("#")]),e._v(" PerformanceOverlay 分析")]),e._v(" "),a("p",[e._v("PerformanceOverlay 的源码是：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("~/flutter/packages/flutter/lib/src/widgets/performance_overlay.dart\n\n")])])]),a("p",[e._v("可以看出PerformanceOverlay有以下的属性：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("optionsMask")]),e._v(" "),a("p",[e._v("用于标记哪些功能打开的flag，有四个值:")]),e._v(" "),a("ul",[a("li",[e._v("displayRasterizerStatistics ：显示光栅化器统计信息（GPU）")]),e._v(" "),a("li",[e._v("visualizeRasterizerStatistics ：可视化光栅化器统计信息(GPU)")]),e._v(" "),a("li",[e._v("displayEngineStatistics ：显示引擎统计（CPU）")]),e._v(" "),a("li",[e._v("visualizeEngineStatistics ：可视化引擎统计（CPU）")])])]),e._v(" "),a("li",[a("p",[e._v("rasterizerThreshold")]),e._v(" "),a("p",[e._v("光栅化的阈值，用于捕获SkPicture跟踪以进行进一步分析，它的值代表每隔几帧捕获一次，默认是0，代表功能是关闭的")])]),e._v(" "),a("li",[a("p",[e._v("checkerboardRasterCacheImages")]),e._v(" "),a("p",[e._v("检查缓存图片的情况")])]),e._v(" "),a("li",[a("p",[e._v("checkerboardOffscreenLayers 检查不必要的setlayer")])])]),e._v(" "),a("h3",{attrs:{id:"开启-performanceoverlay"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开启-performanceoverlay"}},[e._v("#")]),e._v(" 开启 PerformanceOverlay")]),e._v(" "),a("p",[e._v("开启 Performance Overlay 的方法有两种：")]),e._v(" "),a("ol",[a("li",[e._v("使用 IDE 里集成的 Flutter Inspector 工具")]),e._v(" "),a("li",[e._v("使用代码设置")])]),e._v(" "),a("h4",{attrs:{id:"_1、-使用-ide-里集成的-flutter-inspector-工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、-使用-ide-里集成的-flutter-inspector-工具"}},[e._v("#")]),e._v(" 1、 使用 IDE 里集成的 Flutter Inspector 工具")]),e._v(" "),a("p",[e._v("Flutter Inspector 是集成在 IDE 里的一个强大的工具，Performance Overlay 的功能也集成在 Flutter Inspector 里。")]),e._v(" "),a("p",[e._v("需要我们运行 Flutter APP 后才可以使用，")]),e._v(" "),a("ol",[a("li",[e._v("在 Android Studio 里")])]),e._v(" "),a("p",[e._v("选择 View > Tool Windows > Flutter Inspector，就可以打开 Flutter Inspector，可以看到有很多功能，如下图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/28/1689018ea5935178?w=517&h=189&f=png&s=32861",alt:""}})]),e._v(" "),a("p",[e._v("然后选择 Performance Overlay。")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("在 VS Code里")])]),e._v(" "),a("p",[e._v("通过 View > Command Palette 或者 "),a("code",[e._v("cmd+p")]),e._v(" 打开命令板，输入 "),a("code",[e._v("performance")]),e._v(" 然后选择 Toggle Performance Overlay 就行。")]),e._v(" "),a("h4",{attrs:{id:"_2-使用代码设置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用代码设置"}},[e._v("#")]),e._v(" 2. 使用代码设置")]),e._v(" "),a("p",[e._v("通过给 MaterialApp 或者 WidgetsApp 设置参数来开启 PerformanceOverlay 的功能。")]),e._v(" "),a("p",[e._v("要将MaterialApp 或者 WidgetsApp 的showPerformanceOverlay 属性设置为true，如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      showPerformanceOverlay: true,\n      title: 'My Awesome App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: MyHomePage(title: 'My Awesome App'),\n    );\n  }\n}\n\n")])])]),a("h3",{attrs:{id:"在-performanceoverlay-里查看-gpu、cpu-统计信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在-performanceoverlay-里查看-gpu、cpu-统计信息"}},[e._v("#")]),e._v(" 在 PerformanceOverlay 里查看 GPU、CPU 统计信息")]),e._v(" "),a("p",[e._v("如下图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/27/1688dcffb845cf87?w=350&h=265&f=png&s=63322",alt:""}})]),e._v(" "),a("p",[e._v("这个浮窗有两个图形：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("上面的是 GPU thread")]),e._v(" "),a("p",[e._v("表示在 GPU 线程上生成每帧需要的时间。")])]),e._v(" "),a("li",[a("p",[e._v("下面的 UI thread")]),e._v(" "),a("p",[e._v("表示在 UI 线程上生成每帧需要的时间。")])]),e._v(" "),a("li",[a("p",[e._v("纵轴")]),e._v(" "),a("p",[e._v("图中的纵轴代表时间，每个图形都被分成三格，每小隔代表 16ms，如果图中超过这三条线之一，那么您的运行频率低于 60Hz。")])]),e._v(" "),a("li",[a("p",[e._v("横轴")]),e._v(" "),a("p",[e._v("横轴代表帧。 该图仅在应用程序绘制时更新，因此如果它处于空闲状态，该图将停止移动。每个图形绘制的都是该线程最后 300帧 的数据。")])])]),e._v(" "),a("p",[e._v("为了保证 60FPS，每帧耗费的时间应该是小于 16ms 的，看上图中绿色的粗线条，代表的是当前帧的数据，如果当前帧的数据符合预期（<16ms），那么就是绿色的，如果不符合，就是红色的，如下图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/27/1688ddec1fe47589?w=350&h=182&f=png&s=47753",alt:""}})]),e._v(" "),a("p",[e._v("遇到红色的就需要去具体分析，因为会造成 APP 卡顿：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("如果 GPU thread 是红色的")]),e._v(" "),a("p",[e._v("那么可能是绘制的图形过于复杂，或者是执行了过多的 GPU 操作。")])]),e._v(" "),a("li",[a("p",[e._v("如果 UI thread 是红色的")]),e._v(" "),a("p",[e._v("说明肯定是 Dart 代码里有耗时操作，导致阻塞 了UI 操作。")])]),e._v(" "),a("li",[a("p",[e._v("如果两个都是红色的 建议从 UI thread，也就是 Dart 代码查起。")])])]),e._v(" "),a("h3",{attrs:{id:"gpu-问题定位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gpu-问题定位"}},[e._v("#")]),e._v(" GPU 问题定位")]),e._v(" "),a("p",[e._v("辅助定位 GPU 问题的，就是 PerformanceOverlay 的下面两个功能：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("checkerboardRasterCacheImages -- 检查缓存图片的情况")]),e._v(" "),a("p",[e._v("还有一个拖慢 GPU 渲染速度的是没有给静态图像做缓存，导致每次 build 都会重新绘制。我们可以把静态图像加到 RepaintBoundry 中，引擎会自动判断图像是否复杂到需要 repaint boundary。")])]),e._v(" "),a("li",[a("p",[e._v("checkerboardOffscreenLayers -- 检查不必要的 setlayer")]),e._v(" "),a("p",[e._v("setlayer 是 Canvas里的操作，非常耗性能，所以要尽量避免这个操作。你可能会好奇，我根本没用到这个，是的，我们一般是不会使用这个函数的，所以当你开启了这个检查后，会发现啥也没有，正好说明了你没有用到 setlayer。我们一般都是被动的使用，比如需要剪切、透明的操作，用到一些 widget 的时候，这些 widget 会用到 setlayer 方法，一旦遇到这种情况，我们要想一下是否一定要这么做，能不能通过其他方式实现。")])])]),e._v(" "),a("p",[e._v("开启这两个功能的方法：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("MaterialApp(\n    showPerformanceOverlay: true,\n    checkerboardOffscreenLayers: true, //使用了saveLayer的图像会显示为棋盘格式并随着页面刷新而闪烁\n    checkerboardRasterCacheImages: true, // 做了缓存的静态图像图片在刷新页面使不会改变棋盘格的颜色；如果棋盘格颜色变了，说明被重新缓存，这是我们要避免的\n    ...\n);\n\n")])])]),a("h3",{attrs:{id:"gpu-优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gpu-优化"}},[e._v("#")]),e._v(" GPU 优化")]),e._v(" "),a("ol",[a("li",[e._v("一些效果尽量设置在子 Widget 上，而不是父 Widget")])]),e._v(" "),a("p",[e._v("例如，要实现一个混合图层的半透明效果，如果把透明度设置在顶层 Widget 上，CPU 会把每个 子Widget 的图层渲染出来，在执行 "),a("code",[e._v("saveLayer")]),e._v(" 操作保存为一个图层，最后给这个图层设置透明度，但是 "),a("code",[e._v("saveLayer")]),e._v(" 的开销很大，所以官方给出建议：首先确认这些效果是否真的有必要；如果有必要，应该把透明度设置到每个 子Widget 上，而不是 父Widget。裁剪操作也是类似。")]),e._v(" "),a("h3",{attrs:{id:"ui问题定位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ui问题定位"}},[e._v("#")]),e._v(" UI问题定位")]),e._v(" "),a("p",[e._v("可以使用 Observatory 里的 timeline 的功能分析。")]),e._v(" "),a("h2",{attrs:{id:"flutter-性能监控工具-observatory-介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flutter-性能监控工具-observatory-介绍"}},[e._v("#")]),e._v(" Flutter 性能监控工具 -- Observatory 介绍")]),e._v(" "),a("p",[e._v("Flutter 的宣传说，使用 Flutter 可以达到 60FPS，但是这并不意味，不管你怎么写，都能达到 60FPS，如果有耗时的操作，可能会阻塞 UI 的渲染，如果内存使用过多，也有可能会 OOM，所以性能的好坏，是保证 Flutter 能否达到 60FPS 的关键，在对 Flutter 进行性能优化之前，我们先看下如何来监测 Flutter 的性能。")]),e._v(" "),a("h3",{attrs:{id:"flutter-的三种构建模式-build-modes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flutter-的三种构建模式-build-modes"}},[e._v("#")]),e._v(" Flutter 的三种构建模式(build modes)")]),e._v(" "),a("p",[e._v("Flutter 有三种构建模式，适用于不同的场景:")]),e._v(" "),a("h4",{attrs:{id:"_1-debug"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-debug"}},[e._v("#")]),e._v(" 1.Debug")]),e._v(" "),a("p",[e._v("顾名思义，就是调试模式，在调试模式下：")]),e._v(" "),a("ol",[a("li",[e._v("Flutter 的断言（Assertions）功能是开的")]),e._v(" "),a("li",[e._v("Flutter 的 Observatory 是开的，Observatory 是用于分析和调试 Dart 代码的工具，用于 Dart 的 debugger")]),e._v(" "),a("li",[e._v("扩展的服务功能（Service extensions）是开启的，如第二点的 Observatory 的服务还有性能的服务等。")]),e._v(" "),a("li",[e._v("JIT 编译模式，可以使用 Hot Reload，为了快速开发")])]),e._v(" "),a("p",[e._v("可以看到，在 Debug 模式下，为了 debug 和快速开发，牺牲了性能，所以 Debug 模式都是用在开发阶段。 而且模拟器只能运行 Debug 模式。")]),e._v(" "),a("p",[e._v("用命令行:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$flutter run\n\n")])])]),a("h4",{attrs:{id:"_2-release"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-release"}},[e._v("#")]),e._v(" 2.Release")]),e._v(" "),a("p",[e._v("顾名思义，就是要发布了，在 Release 模式下，要追求最高的性能和最小的安装包，所以会：")]),e._v(" "),a("ol",[a("li",[e._v("断言（Assertions）功能关闭")]),e._v(" "),a("li",[e._v("没有 Debugging 的信息")]),e._v(" "),a("li",[e._v("Debugger 的功能关闭")]),e._v(" "),a("li",[e._v("AOT 编译，为了快速启动，快速执行和更小的包装包大小。")]),e._v(" "),a("li",[e._v("扩展的服务功能（Service extensions）关闭")])]),e._v(" "),a("p",[e._v("所以，Release 模式是 APP 要发布的时候才用。")]),e._v(" "),a("p",[e._v("Release 模式只能跑在真机上。")]),e._v(" "),a("p",[e._v("用命令行:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$flutter run --release\n\n")])])]),a("p",[e._v("或者")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$flutter build\n\n")])])]),a("h4",{attrs:{id:"_3-profile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-profile"}},[e._v("#")]),e._v(" 3.Profile")]),e._v(" "),a("p",[e._v("Profile 是专门监控性能的模式，在 Debug 模式下，不能实际反应应用的性能，而在 Release 模式下，却没有监控的功能，所以就诞生了 Profile 模式，Profile 模式和 Release 模式更接近，Profile 和 Release 都采用的 AOT 编译，所以都不能用 Hot Reload，但是 Profile 相对于 Release，多了如下的功能：")]),e._v(" "),a("ol",[a("li",[e._v("一些扩展的服务功能（Service extensions）是打开的，例如监控性能的浮层等。")]),e._v(" "),a("li",[e._v("Tracing 是打开的，Observatory 也可以连接到进程")])]),e._v(" "),a("p",[e._v("Profile 模式只能跑在真机上。")]),e._v(" "),a("p",[e._v("用命令行:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$flutter run --profile\n\n")])])]),a("h3",{attrs:{id:"使用-observatory-来监控性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-observatory-来监控性能"}},[e._v("#")]),e._v(" 使用 Observatory 来监控性能")]),e._v(" "),a("p",[e._v("Observatory 是用于分析和调试 Dart 代码的工具，因为 Flutter 自带 Dart VM，所以也可以用 Observatory。")]),e._v(" "),a("h4",{attrs:{id:"_1-命令行启动-observatory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-命令行启动-observatory"}},[e._v("#")]),e._v(" 1. 命令行启动 Observatory")]),e._v(" "),a("p",[e._v("Debug 下启用 Observatory：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$flutter run\n\n")])])]),a("p",[e._v("Profile 下启用 Observatory：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$flutter run --profile\n\n")])])]),a("p",[e._v("运行完命令后，会看到如下的信息：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ flutter run --profile\nInitializing gradle...                                       0.8s\nResolving dependencies...                                    6.6s\nLaunching lib/main.dart on ALP AL00 in profile mode...\nGradle task 'assembleProfile'...\nGradle task 'assembleProfile'... Done                       21.2s\nBuilt build/app/outputs/apk/profile/app-profile.apk (66.5MB).\nInstalling build/app/outputs/apk/app.apk...                  5.4s\nD/mali_winsys(18612): EGLint new_window_surface(egl_winsys_display *, void *, EGLSurface, EGLConfig, egl_winsys_surface **, EGLBoolean) returns 0x3000\n\nAn Observatory debugger and profiler on ALP AL00 is available at http://127.0.0.1:57535/\nFor a more detailed help message, press \"h\". To quit, press \"q\".\n\n")])])]),a("p",[e._v("这一句:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("available at http://127.0.0.1:57535/\n\n")])])]),a("p",[e._v("打开 "),a("code",[e._v("http://127.0.0.1:57535/")]),e._v(" 这个网址，就会看到如下的界面：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/27/1688b0505b551f25?w=3248&h=1822&f=png&s=438659",alt:""}})]),e._v(" "),a("p",[e._v("Observatory 支持如下的功能：")]),e._v(" "),a("ol",[a("li",[e._v("Allocation Profile")]),e._v(" "),a("li",[e._v("Code Coverage")]),e._v(" "),a("li",[e._v("CPU Profile")]),e._v(" "),a("li",[e._v("Debugger")]),e._v(" "),a("li",[e._v("Evaluating Expressions")]),e._v(" "),a("li",[e._v("Heap Map")]),e._v(" "),a("li",[e._v("Isolate")]),e._v(" "),a("li",[e._v("Metrics")]),e._v(" "),a("li",[e._v("User and VM Tags")])]),e._v(" "),a("p",[e._v("部分功能的截图如下：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/27/1688b5532c6515f8?w=2984&h=1676&f=png&s=476051",alt:""}})]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/27/1688b5736a3f22c5?w=2558&h=1576&f=png&s=498544",alt:""}})]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/27/1688b58c88493630?w=2956&h=1598&f=png&s=417010",alt:""}})]),e._v(" "),a("h4",{attrs:{id:"_2-flutter-inspector-启动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-flutter-inspector-启动"}},[e._v("#")]),e._v(" 2.Flutter Inspector 启动")]),e._v(" "),a("p",[e._v("Flutter Inspector 是一个强大的工具，要想使用 Flutter Inspector，就得先运行 Flutter APP。")]),e._v(" "),a("p",[e._v("运行 Flutter APP后:")]),e._v(" "),a("ol",[a("li",[e._v("在 Android Studio 里")])]),e._v(" "),a("p",[e._v("选择 View > Tool Windows > Flutter Inspector，就可以打开 Flutter Inspector，可以看到有很多功能，如下图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/28/1689018ea5935178?w=517&h=189&f=png&s=32861",alt:""}})]),e._v(" "),a("p",[e._v("然后选择 Open observatory。")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("在 VS Code里")])]),e._v(" "),a("p",[e._v("通过 View > Command Palette 或者 "),a("code",[e._v("cmd+p")]),e._v(" 打开命令板，输入 "),a("code",[e._v("Open observatory")]),e._v(" 然后选择 Open observatory就行。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/28/168902466cfa2ac4?w=1196&h=122&f=png&s=18681",alt:""}})]),e._v(" "),a("p",[e._v("如果看不到，说明你没有运行 Flutter APP，得以 "),a("code",[e._v("Start Debugging")]),e._v(" 的方式运行。")]),e._v(" "),a("h2",{attrs:{id:"flutter-性能监控工具-observatory-使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flutter-性能监控工具-observatory-使用"}},[e._v("#")]),e._v(" Flutter 性能监控工具 -- Observatory 使用")]),e._v(" "),a("p",[e._v("前面主要讲了如何打开 Observatory，现在讲一下如何使用 Observatory 里的各个功能来分析性能问题，")]),e._v(" "),a("p",[e._v("下图是 Observatory 的主页面：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/28/168951b1b83c6000?w=3228&h=1812&f=png&s=444838",alt:""}})]),e._v(" "),a("h3",{attrs:{id:"最上面的蓝色导航栏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最上面的蓝色导航栏"}},[e._v("#")]),e._v(" 最上面的蓝色导航栏")]),e._v(" "),a("p",[e._v("表示当前所在的位置")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("vm@ws://127.0.0.1:50579/ws ：表示当前连接的VM")]),e._v(" "),a("p",[e._v("鼠标放在这个上面，会看到这个，表示当前 APP 的 main()：")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/28/168951f40059bfc5?w=512&h=188&f=png&s=16769",alt:""}})]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("右边的 Refresh ：刷新数据")])]),e._v(" "),a("h3",{attrs:{id:"vm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vm"}},[e._v("#")]),e._v(" VM")]),e._v(" "),a("p",[e._v("这里显示当前 VM 的信息")]),e._v(" "),a("ol",[a("li",[e._v("name ： 当前 VM 的名字")]),e._v(" "),a("li",[e._v("version ：Dart 的版本，APP build 的时间，运行在哪个平台上")]),e._v(" "),a("li",[e._v("embedder ：嵌入的平台")]),e._v(" "),a("li",[e._v("started at ：VM 启动时的时间戳")]),e._v(" "),a("li",[e._v("uptime ：VM 已运行的时长")]),e._v(" "),a("li",[e._v("refreshed at ：上次采样数据的时间")]),e._v(" "),a("li",[e._v("pid ： 进程 ID")]),e._v(" "),a("li",[e._v("peak memory ：APP 运行时用的峰值内存")]),e._v(" "),a("li",[e._v("current memory : APP 当前用的内存")]),e._v(" "),a("li",[e._v("native zone memory ：native 原生内存")]),e._v(" "),a("li",[e._v("native heap memory ：native 堆内存")]),e._v(" "),a("li",[e._v("native heap allocatioon count ： native 堆对象数量")]),e._v(" "),a("li",[e._v("flag ：一些标记位")]),e._v(" "),a("li",[e._v("timeline ：工具")]),e._v(" "),a("li",[e._v("native memory profile ：")])]),e._v(" "),a("h3",{attrs:{id:"isolates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isolates"}},[e._v("#")]),e._v(" Isolates")]),e._v(" "),a("p",[e._v("这里是显示 APP 里的 Isolates，每个 APP 都有一个 root Isolates。")]),e._v(" "),a("p",[e._v("Isolates 是用一个饼图显示，这个饼图有很多组成部分，我们把这些叫做 tags，这些 tags 用来代表在 VM 里不同的执行列表，包括 User TAG 和 VM TAG：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("User TAG")]),e._v(" "),a("p",[e._v("用户自定义的 TAG，使用方式如下：")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import 'dart:developer';\n\nvar customTag = new UserTag('MyTag');\n\n// Save the previous tag when installing the custom tag.\nvar previousTag = customTag.makeCurrent();\n\n// your code here\n\n// Restore the previous tag.\npreviousTag.makeCurrent();\n\n")])])]),a("ul",[a("li",[a("p",[e._v("VM TAG")]),e._v(" "),a("p",[e._v("VM TAG 是系统定义的，在整个 UI 中使用，有：")]),e._v(" "),a("ol",[a("li",[e._v("CompileOptimized, CompileScanner, CompileTopLevel, CompileUnoptimized ：编译 Dart 代码")]),e._v(" "),a("li",[e._v("GCNewSpace ： 新生代的垃圾收集")]),e._v(" "),a("li",[e._v("GCOldSpace ： 老生代的垃圾收集")]),e._v(" "),a("li",[e._v("Idle ： 不是 VM TAG，但是用来标识 Isolate 空闲的占比")]),e._v(" "),a("li",[e._v("Native ： 执行Native代码，dart：io 库使用的 C++ 代码 或者 平台相关代码(Platform Channel)")]),e._v(" "),a("li",[e._v("Runtime : 执行 Runtime 代码")]),e._v(" "),a("li",[e._v("Dart ： 执行 自己的业务 Dart 代码")]),e._v(" "),a("li",[e._v("VM ：创建 isolate，和其他未被覆盖的部分")])])])]),e._v(" "),a("p",[e._v("图像的右边还有一系列链接，代表着不同的功能。")]),e._v(" "),a("h3",{attrs:{id:"debug"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#debug"}},[e._v("#")]),e._v(" debug")]),e._v(" "),a("p",[e._v("可以设置断点并调试您的应用程序。")]),e._v(" "),a("p",[e._v("如何设置 debugger，看 "),a("a",{attrs:{href:"https://dart-lang.github.io/observatory/debugger.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://dart-lang.github.io/observatory/debugger.html"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"class-hierarchy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-hierarchy"}},[e._v("#")]),e._v(" class hierarchy")]),e._v(" "),a("p",[e._v("显示应用程序的类层次结构。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/29/168954d8f7e10997?w=1504&h=1192&f=png&s=187886",alt:""}})]),e._v(" "),a("h3",{attrs:{id:"cpu-profile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu-profile"}},[e._v("#")]),e._v(" cpu profile")]),e._v(" "),a("p",[e._v("显示当前 isolate 的 CPU 使用数据")]),e._v(" "),a("p",[e._v("图表的下部按 CPU 占用比例做了一个列表，反映的是函数的调用次数和执行时间（划重点）。一般排在前面的函数（这些函数是？有待学习）都不是我们写的 dart 代码。如果你发现自己的某个函数调用占比反常，那么可能存在问题。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/29/168954d20cf1c4c3?w=1658&h=1598&f=png&s=292517",alt:""}})]),e._v(" "),a("p",[e._v("具体使用的地址："),a("a",{attrs:{href:"https://dart-lang.github.io/observatory/cpu-profile.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://dart-lang.github.io/observatory/cpu-profile.html"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"cpu-profile-table"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu-profile-table"}},[e._v("#")]),e._v(" cpu profile (table)")]),e._v(" "),a("p",[e._v("和 cpu profile 一样，但是是以表格的形式来展示")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/29/168954e997e3f6ed?w=1796&h=1232&f=png&s=333231",alt:""}})]),e._v(" "),a("h3",{attrs:{id:"allocation-profile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#allocation-profile"}},[e._v("#")]),e._v(" allocation profile")]),e._v(" "),a("p",[e._v("显示 isolate 已分配的内存。通过这个面板你能看到新生代/老生代的内存大小和占比；每个类型所占用的内存大小。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/29/1689552297814fd9?w=3224&h=1650&f=png&s=509264",alt:""}})]),e._v(" "),a("p",[e._v("Heap 堆，动态分配的Dart对象所在的内存空间")]),e._v(" "),a("ul",[a("li",[e._v("New generation: 新创建的对象，一般来说对象比较小，生命周期短，如local 变量。在这里GC活动频繁")]),e._v(" "),a("li",[e._v("Old generation：从GC中存活下来的New generation将会提拔到老生代Old generation，它比新生代空间大，更适合大的对象和生命周期长的对象")])]),e._v(" "),a("p",[e._v("通过这个面板你能看到新生代/老生代的内存大小和占比；每个类型所占用的内存大小。")]),e._v(" "),a("p",[e._v("为了 debug 的方便，我们可以获取到某段时间的内存分配情况：点击 Reset Accumulator 按钮，把数据清零，执行一下要测试的程序，点击刷新。 为了检查内存泄露，我们可以点击 GC 按钮，手动执行 GC。")]),e._v(" "),a("ul",[a("li",[e._v("Accumulator Size:自点击Reset Accumulator以来，累加对象占用内存大小")]),e._v(" "),a("li",[e._v("Accumulator Instances：自点击Reset Accumulator以来，累加实例个数")]),e._v(" "),a("li",[e._v("Current Size：当前对象占用内存大小")]),e._v(" "),a("li",[e._v("Current Instances：当前对象数量")])]),e._v(" "),a("p",[e._v("具体使用的地址："),a("a",{attrs:{href:"https://dart-lang.github.io/observatory/allocation-profile.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://dart-lang.github.io/observatory/allocation-profile.html"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"heap-snapshot"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#heap-snapshot"}},[e._v("#")]),e._v(" heap snapshot")]),e._v(" "),a("p",[e._v("堆快照")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/29/168955461b809164?w=1914&h=1332&f=png&s=314132",alt:""}})]),e._v(" "),a("h3",{attrs:{id:"heap-map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#heap-map"}},[e._v("#")]),e._v(" heap map")]),e._v(" "),a("p",[e._v("将分配的内存显示为颜色块")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/29/16895562c59f0628?w=3250&h=1120&f=png&s=227222",alt:""}})]),e._v(" "),a("p",[e._v("heap map 面板能查看 old generation 中的内存状态, 它以颜色显示内存块。 每个内存页面(page of memory)为256 KB，每页由水平黑线分隔。")]),e._v(" "),a("p",[e._v("例如，蓝色表示字符串，绿色表示双精度表。 可用空间为白色，指令（代码）为紫色。 如果启动垃圾收集（使用“分配配置文件”屏幕中的GC按钮），堆映射中将显示更多空白区域（可用空间）。 将光标悬停在上面时，顶部的状态栏显示有关光标下像素所代表的对象的信息。 显示的信息包括该对象的类型，大小和地址。")]),e._v(" "),a("p",[e._v("当你看到白色区域中有很多分散的其它颜色，说明存在内存碎片化，可能是内存泄露导致的。")]),e._v(" "),a("p",[e._v("具体使用看："),a("a",{attrs:{href:"https://dart-lang.github.io/observatory/heap-map.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://dart-lang.github.io/observatory/heap-map.html"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"metrics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#metrics"}},[e._v("#")]),e._v(" metrics")]),e._v(" "),a("p",[e._v("包含您应用中收集的指标。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/29/168955726d747d24?w=1308&h=714&f=png&s=77705",alt:""}})]),e._v(" "),a("h3",{attrs:{id:"persistent-handles"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#persistent-handles"}},[e._v("#")]),e._v(" persistent handles")]),e._v(" "),a("p",[e._v("查看强对象和弱对象")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/29/16895588df8b5263?w=2054&h=1726&f=png&s=419852",alt:""}})]),e._v(" "),a("h3",{attrs:{id:"ports"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ports"}},[e._v("#")]),e._v(" ports")]),e._v(" "),a("p",[e._v("端口")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/29/16895595f55f01cf?w=1362&h=212&f=png&s=31114",alt:""}})]),e._v(" "),a("h3",{attrs:{id:"logging"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#logging"}},[e._v("#")]),e._v(" logging")]),e._v(" "),a("p",[e._v("设置Log的级别")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/29/168955a02d935469?w=1314&h=222&f=png&s=40853",alt:""}})])])}),[],!1,null,null,null);t.default=s.exports}}]);