(window.webpackJsonp=window.webpackJsonp||[]).push([[334],{689:function(n,l,e){"use strict";e.r(l);var r=e(42),o=Object(r.a)({},(function(){var n=this,l=n.$createElement,e=n._self._c||l;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("blockquote",[e("p",[n._v("本节代码对应 GitHub 分支: chapter3")])]),n._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/sanyuan0704/react-cloud-music/tree/chapter3",target:"_blank",rel:"noopener noreferrer"}},[n._v("仓库传送门"),e("OutboundLink")],1)]),n._v(" "),e("p",[n._v("本项目最大的亮点之一就是采用 better-scroll 打造了移动端滑动基础组件，不仅仅可以用在本项目，也可以直接移植到其他所有的移动端 React 项目。现在，我们来一起封装这个实用且强大的组件。")]),n._v(" "),e("h2",{attrs:{id:"分步拆解-scroll-组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分步拆解-scroll-组件"}},[n._v("#")]),n._v(" 分步拆解 scroll 组件")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 安装 better-scroll\nnpm install better-scroll@next --save\n\n")])])]),e("p",[n._v("我们依然采用函数式组件的形式进行开发，不过作为一个通用组件，scroll 组件在业务中会被经常取到原生 DOM 对象，而函数式组件天生不具备被上层组件直接调用 ref 的条件，因此需要用 React 当中一些特殊的方式来处理，即使用 forwardRef 进行包裹。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const Scroll = forwardRef ((props, ref) => {\n  // 编写组件内容\n})\n\n")])])]),e("p",[n._v("首先梳理一下这个组件需要接受哪些参数:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Scroll.propTypes = {\n  direction: PropTypes.oneOf (['vertical', 'horizental']),// 滚动的方向\n  click: true,// 是否支持点击\n  refresh: PropTypes.bool,// 是否刷新\n  onScroll: PropTypes.func,// 滑动触发的回调函数\n  pullUp: PropTypes.func,// 上拉加载逻辑\n  pullDown: PropTypes.func,// 下拉加载逻辑\n  pullUpLoading: PropTypes.bool,// 是否显示上拉 loading 动画\n  pullDownLoading: PropTypes.bool,// 是否显示下拉 loading 动画\n  bounceTop: PropTypes.bool,// 是否支持向上吸顶\n  bounceBottom: PropTypes.bool// 是否支持向下吸底\n};\n\n")])])]),e("p",[n._v("目前归纳出了这些可能的参数，也正是后面的开发中所需要的，给他们赋默认值:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('Scroll.defaultProps = {\n  direction: "vertical",\n  click: true,\n  refresh: true,\n  onScroll:null,\n  pullUpLoading: false,\n  pullDownLoading: false,\n  pullUp: null,\n  pullDown: null,\n  bounceTop: true,\n  bounceBottom: true\n};\n\n')])])]),e("p",[n._v("现在来写 scroll 组件的核心逻辑代码，首先声明如下 hooks 变量:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//better-scroll 实例对象\nconst [bScroll, setBScroll] = useState ();\n//current 指向初始化 bs 实例需要的 DOM 元素 \nconst scrollContaninerRef = useRef ();\n\n")])])]),e("p",[n._v("从外面接受 props，解构赋值拿到这些参数:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const { direction, click, refresh, pullUpLoading, pullDownLoading, bounceTop, bounceBottom } = props;\nconst { pullUp, pullDown, onScroll } = props;\n\n")])])]),e("p",[n._v("接下来创建 better-scroll，")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('useEffect (() => {\n  const scroll = new BScroll (scrollContaninerRef.current, {\n    scrollX: direction === "horizental",\n    scrollY: direction === "vertical",\n    probeType: 3,\n    click: click,\n    bounce:{\n      top: bounceTop,\n      bottom: bounceBottom\n    }\n  });\n  setBScroll (scroll);\n  return () => {\n    setBScroll (null);\n  }\n}, []);\n\n')])])]),e("p",[n._v("每次重新渲染都要刷新实例，防止无法滑动:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("useEffect (() => {\n  if (refresh && bScroll){\n    bScroll.refresh ();\n  }\n});\n\n")])])]),e("p",[n._v("给实例绑定 scroll 事件，")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("useEffect (() => {\n  if (!bScroll || !onScroll) return;\n  bScroll.on ('scroll', (scroll) => {\n    onScroll (scroll);\n  })\n  return () => {\n    bScroll.off ('scroll');\n  }\n}, [onScroll, bScroll]);\n\n")])])]),e("p",[n._v("进行上拉到底的判断，调用上拉刷新的函数")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("useEffect (() => {\n  if (!bScroll || !pullUp) return;\n  bScroll.on ('scrollEnd', () => {\n    // 判断是否滑动到了底部\n    if (bScroll.y <= bScroll.maxScrollY + 100){\n      pullUp ();\n    }\n  });\n  return () => {\n    bScroll.off ('scrollEnd');\n  }\n}, [pullUp, bScroll]);\n\n")])])]),e("p",[n._v("进行下拉的判断，调用下拉刷新的函数")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("useEffect (() => {\n  if (!bScroll || !pullDown) return;\n  bScroll.on ('touchEnd', (pos) => {\n    // 判断用户的下拉动作\n    if (pos.y > 50) {\n      pullDown ();\n    }\n  });\n  return () => {\n    bScroll.off ('touchEnd');\n  }\n}, [pullDown, bScroll]);\n\n")])])]),e("p",[n._v("完成了滑动事件、上拉下拉事件的判断，现在需要给外界暴露组件方法，如:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 上层组件代码\nconst scrollRef = useRef ();\n...\n<Scroll ref={scrollRef}></Scroll>  \n\n")])])]),e("p",[n._v("想要通过这种调用方法的方式刷新 scroll 组件：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("scrollRef.current.refresh ();\n\n")])])]),e("p",[n._v("这应该怎么办呢？ React Hooks 中的 useImperativeHandle 已经给了我们解决方案，我们这样做就好了:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 一般和 forwardRef 一起使用，ref 已经在 forWardRef 中默认传入\nuseImperativeHandle (ref, () => ({\n  // 给外界暴露 refresh 方法\n  refresh () {\n    if (bScroll) {\n      bScroll.refresh ();\n      bScroll.scrollTo (0, 0);\n    }\n  },\n  // 给外界暴露 getBScroll 方法，提供 bs 实例\n  getBScroll () {\n    if (bScroll) {\n      return bScroll;\n    }\n  }\n}));\n\n")])])]),e("p",[n._v("剩下的是 UI 的渲染工作:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("return (\n  <ScrollContainer ref={scrollContaninerRef}>\n    {props.children}\n  </ScrollContainer>\n);\n\n")])])]),e("p",[n._v("同时贴出样式部分的 js 代码:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const ScrollContainer = styled.div`\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n`\n\n")])])]),e("p",[n._v("加载动画部分涉及到 loading 组件我们放到下一章拆解：）")]),n._v(" "),e("h2",{attrs:{id:"综合代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#综合代码"}},[n._v("#")]),n._v(" 综合代码")]),n._v(" "),e("p",[n._v("这里给出综合后的代码:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("import React, { forwardRef, useState,useEffect, useRef, useImperativeHandle } from \"react\"\nimport PropTypes from \"prop-types\"\nimport BScroll from \"better-scroll\"\nimport styled from'styled-components';\n\nconst ScrollContainer = styled.div`\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n`\nconst Scroll = forwardRef ((props, ref) => {\n  const [bScroll, setBScroll] = useState ();\n\n  const scrollContaninerRef = useRef ();\n\n  const { direction, click, refresh,  bounceTop, bounceBottom } = props;\n\n  const { pullUp, pullDown, onScroll } = props;\n\n  useEffect (() => {\n    const scroll = new BScroll (scrollContaninerRef.current, {\n      scrollX: direction === \"horizental\",\n      scrollY: direction === \"vertical\",\n      probeType: 3,\n      click: click,\n      bounce:{\n        top: bounceTop,\n        bottom: bounceBottom\n      }\n    });\n    setBScroll (scroll);\n    return () => {\n      setBScroll (null);\n    }\n    //eslint-disable-next-line\n  }, []);\n\n  useEffect (() => {\n    if (!bScroll || !onScroll) return;\n    bScroll.on ('scroll', (scroll) => {\n      onScroll (scroll);\n    })\n    return () => {\n      bScroll.off ('scroll');\n    }\n  }, [onScroll, bScroll]);\n\n  useEffect (() => {\n    if (!bScroll || !pullUp) return;\n    bScroll.on ('scrollEnd', () => {\n      // 判断是否滑动到了底部\n      if (bScroll.y <= bScroll.maxScrollY + 100){\n        pullUp ();\n      }\n    });\n    return () => {\n      bScroll.off ('scrollEnd');\n    }\n  }, [pullUp, bScroll]);\n\n  useEffect (() => {\n    if (!bScroll || !pullDown) return;\n    bScroll.on ('touchEnd', (pos) => {\n      // 判断用户的下拉动作\n      if (pos.y > 50) {\n        pullDown ();\n      }\n    });\n    return () => {\n      bScroll.off ('touchEnd');\n    }\n  }, [pullDown, bScroll]);\n\n\n  useEffect (() => {\n    if (refresh && bScroll){\n      bScroll.refresh ();\n    }\n  });\n\n  useImperativeHandle (ref, () => ({\n    refresh () {\n      if (bScroll) {\n        bScroll.refresh ();\n        bScroll.scrollTo (0, 0);\n      }\n    },\n    getBScroll () {\n      if (bScroll) {\n        return bScroll;\n      }\n    }\n  }));\n\n\n  return (\n    <ScrollContainer ref={scrollContaninerRef}>\n      {props.children}\n    </ScrollContainer>\n  );\n})\n\nScroll.defaultProps = {\n  direction: \"vertical\",\n  click: true,\n  refresh: true,\n  onScroll:null,\n  pullUpLoading: false,\n  pullDownLoading: false,\n  pullUp: null,\n  pullDown: null,\n  bounceTop: true,\n  bounceBottom: true\n};\n\nScroll.propTypes = {\n  direction: PropTypes.oneOf (['vertical', 'horizental']),\n  refresh: PropTypes.bool,\n  onScroll: PropTypes.func,\n  pullUp: PropTypes.func,\n  pullDown: PropTypes.func,\n  pullUpLoading: PropTypes.bool,\n  pullDownLoading: PropTypes.bool,\n  bounceTop: PropTypes.bool,// 是否支持向上吸顶\n  bounceBottom: PropTypes.bool// 是否支持向上吸顶\n};\n\nexport default Scroll;\n\n")])])]),e("h2",{attrs:{id:"在项目中应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在项目中应用"}},[n._v("#")]),n._v(" 在项目中应用")]),n._v(" "),e("p",[n._v("scroll 组件已经初步实现。但是，这还不够。还有一些细节，比如防抖，loading 控制等等，后期会一步一步完善。更重要的是，我们还需要将它运用到项目中，进入到 Recommend 目录下的 index.js，函数返回的 JSX 代码变化如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('<Content>\n  <Scroll className="list">\n    <div>\n      <Slider bannerList={bannerList}></Slider>\n      <RecommendList recommendList={recommendList}></RecommendList>\n    </div>\n  </Scroll>\n</Content> \n\n')])])]),e("p",[n._v("可能你会不解，Content 样式组件是个什么鬼？在这里我要强调一下，better-scroll 的原理并不复杂，就是在容器元素高度固定，当子元素高度超过容器元素高度时，通过 transfrom 动画产生滑动效果，因此它的使用原则就是外部容器必须是固定高度，不然没法滚动。而 Content 就是这个外部容器。")]),n._v(" "),e("p",[n._v("我们在对应 style.js 中增加以下代码:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("import styled from'styled-components';\n\nexport const Content = styled.div`\n  position: fixed;\n  top: 90px;\n  bottom: 0;\n  width: 100%;\n`\n\n")])])]),e("p",[n._v("现在打开页面，你就能体会到下拉吸顶、上拉吸底的感觉了。不过还是有一个问题，当你下拉的时候，中间会有一段空白，感觉比较突兀，没错，这就是默认的背景颜色。那么怎么来解决这个问题呢？")]),n._v(" "),e("p",[n._v("还是从遮罩入手吧，还记得那个.before 的 div 吗？")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('.before {\n  position: absolute;\n  top: -300px;\n  height: 400px;\n  width: 100%;\n  background: ${style ["theme-color"]};\n}\n\n')])])]),e("p",[n._v("如此修改即可，这样下拉间隙就变成了主题色了。")])])}),[],!1,null,null,null);l.default=o.exports}}]);