(window.webpackJsonp=window.webpackJsonp||[]).push([[350],{706:function(v,_,e){"use strict";e.r(_);var t=e(42),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"导读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#导读"}},[v._v("#")]),v._v(" 导读")]),v._v(" "),e("p",[v._v("本节标题：「武装思想」- React SSR 根本原理")]),v._v(" "),e("p",[v._v("本节主旨：全面分析 react ssr 技术的本质，并对对虚拟 dom、同构应用具体流程、双端对比机制进行说明。")]),v._v(" "),e("h1",{attrs:{id:"武装思想"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#武装思想"}},[v._v("#")]),v._v(" 武装思想")]),v._v(" "),e("p",[v._v("在动手搭建应用骨架前我们要先了解下"),e("code",[v._v("react ssr")]),v._v(" 最根本的原理，这是整个技术架构实现的基础，也可以说是基石，可以理解为我们盖房子的地基。")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/31/16ff99e599e198b0?w=1514&h=1038&f=png&s=270995",alt:""}})]),v._v(" "),e("p",[v._v("如果你对一些多技术感觉到陌生或者看过很多次仍然会忘记时，主要原因要么是用的少，要么就是不理解其中的原理，导致印象不够深刻。")]),v._v(" "),e("p",[v._v("深入理解原理对于我们的开发和创新（自己造轮子）有很大的帮助，原理可以一步一步的带你走正确的路。")]),v._v(" "),e("p",[v._v("或许你之前觉得"),e("code",[v._v("react ssr")]),v._v(" 这个技术很高大上，学起来没有头绪，无从下手。")]),v._v(" "),e("p",[v._v("在我看来 "),e("code",[v._v("react ssr")]),v._v("实现起来并不复杂，这个突破口就是从原理出发，一点一点的进行分析，然后通过代码校验你的分析。")]),v._v(" "),e("p",[e("code",[v._v("react ssr")]),v._v(" 原理很容易理解，但是仅仅理解这点还不够足以搭建应用骨架，其中最有难度的内容应该是同构。")]),v._v(" "),e("p",[v._v("那么什么是同构？如何实现同构应用呢？")]),v._v(" "),e("p",[v._v("下面请听我慢慢叨叨。我叨叨的同时也会引出问题，希望大家能在看的同时也一起思考起来。")]),v._v(" "),e("p",[v._v("我们上一节说过，传统的"),e("code",[v._v("ssr")]),v._v("和目前流行的"),e("code",[v._v("csr")]),v._v("方案"),e("code",[v._v("spa")]),v._v("都不够完美，所以我们需要能综合这两者优点的技术 - "),e("code",[v._v("react ssr (SPA+SSR)")]),v._v("。")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/26/16fdda177db75d3f?w=1534&h=726&f=png&s=121346",alt:""}})]),v._v(" "),e("p",[v._v("每次刷新页面的时候数据是从服务端直出，然后后续的访问就是 "),e("code",[v._v("spa")]),v._v(" 的体验，即能解决"),e("code",[v._v("SEO")]),v._v("问题，也能保持页面切换的效率，服务器的压力要比传统的"),e("code",[v._v("ssr")]),v._v("也相对小。")]),v._v(" "),e("p",[v._v("我们现在既然已经知道了该技术的作用和意义，那么接下来就该分析下它的原理了。")]),v._v(" "),e("p",[v._v("为什么"),e("code",[v._v("react")]),v._v("能够实现 "),e("code",[v._v("SPA+SSR")]),v._v(" 这种体验呢 ?")]),v._v(" "),e("h2",{attrs:{id:"虚拟-dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[v._v("#")]),v._v(" 虚拟 dom")]),v._v(" "),e("p",[v._v("使用"),e("code",[v._v("react ssr")]),v._v("技术开发出的最终产物其实就是"),e("code",[v._v("SPA+SSR")]),v._v("的结合。")]),v._v(" "),e("p",[v._v("其中的"),e("code",[v._v("SSR")]),v._v("指的是在服务端渲染组件。")]),v._v(" "),e("p",[v._v("而组件可以在服务端渲染的根本原因就是"),e("code",[v._v("虚拟 DOM")]),v._v("。")]),v._v(" "),e("p",[v._v("平时我们都习惯使用"),e("code",[v._v("jsx")]),v._v("来编写"),e("code",[v._v("react")]),v._v(" 的组件。但"),e("code",[v._v("jsx")]),v._v("只是一个抽象的语法糖，看上去是写组件，其实我们写的是对象，只是这样写更方便，更符合我们前端开发者的编写习惯，看上去就像写"),e("code",[v._v("html")]),v._v("，多爽。")]),v._v(" "),e("p",[v._v("虚拟 "),e("code",[v._v("DOM")]),v._v(" 除了在渲染时用于提高渲染性能，以最小的代价来更新视图的作用外，另一个作用就是为组件的跨平台渲染提供可能。")]),v._v(" "),e("p",[v._v("虚拟"),e("code",[v._v("DOM")]),v._v("本身 就是一个内存中的对象，通过对象的属性来描述要渲染的具体是什么元素以及内容。")]),v._v(" "),e("p",[v._v("举个栗子")]),v._v(" "),e("p",[v._v("下面是我们一个组件的"),e("code",[v._v("render")]),v._v("部分")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("<ul id='list'>\n  <li class='item'>1</li>\n  <li class='item'>2</li>\n  <li class='item'>3</li>\n</ul>\n\n")])])]),e("p",[v._v("上面的结构可以转换为下面的对象表示（虚拟 dom）")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("const tree = {\n  tag: 'ul', // 节点标签名\n  props: {       // DOM的属性，用一个对象存储键值对\n    id: 'list'\n  },\n  children: [    // 该节点的子节点\n    {tag: 'li', props: {class: 'item'}, children: ['1']},\n    {tag: 'li', props: {class: 'item'}, children: ['2']},\n    {tag: 'li', props: {class: 'item'}, children: ['3']},\n  ]\n}\n\n")])])]),e("p",[v._v("从上面我们可以看出这就是个普通对象。")]),v._v(" "),e("p",[v._v("既然有了这样的对象，我们就可以轻松的把这个对象转换我们想要的表现形式，比如 "),e("code",[v._v("html")]),v._v("格式，而这个"),e("code",[v._v("html")]),v._v("就是我们要直出的内容。")]),v._v(" "),e("p",[v._v("不过这个转换的过程不需要我们来完成，"),e("code",[v._v("react")]),v._v("已经帮我们完成，其本身就已提供了内置方法来支持服务端渲染。")]),v._v(" "),e("h2",{attrs:{id:"同构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同构"}},[v._v("#")]),v._v(" 同构")]),v._v(" "),e("p",[e("code",[v._v("React")]),v._v(" 虚拟 "),e("code",[v._v("DOM")]),v._v(" 为我们实现 "),e("code",[v._v("SSR")]),v._v(" 提供了基础条件，但是单纯的 "),e("code",[v._v("SSR")]),v._v(" 和 传统的 "),e("code",[v._v("SSR")]),v._v(" 没有什么区别，"),e("code",[v._v("React")]),v._v("中的 组件也只能用作其他模板语言的代替品。。。")]),v._v(" "),e("p",[v._v("那么为什么还要基于"),e("code",[v._v("React")]),v._v("来实现"),e("code",[v._v("SSR")]),v._v("呢？")]),v._v(" "),e("p",[v._v("既然这种技术能够出现，肯定是因为有他独特的魅力和优点。")]),v._v(" "),e("p",[v._v("我们要明白一点，服务端渲染的核心作用。")]),v._v(" "),e("p",[e("code",[v._v("SSR")]),v._v("主要是直接表达出页面最基础和核心的内容这就够了。")]),v._v(" "),e("p",[v._v("剩下的工作就要交给浏览器了，浏览器端需要对页面的交互完成进一步的渲染、事件绑定等增强功能。")]),v._v(" "),e("p",[v._v("说到这里好像有点明白了，意思不就是服务端把首屏的内容直出，让用户更快的看到页面，然后后面的数据采用"),e("code",[v._v("js")]),v._v("来异步请求和加载。貌似不用"),e("code",[v._v("react")]),v._v("一样可以做到的呀。")]),v._v(" "),e("p",[v._v("诶，好像说的没啥毛病。确实方案不只一种，但是我们基于"),e("code",[v._v("react")]),v._v("来实现可以更高效，写更少的代码。因为我们可以构造同构应用。")]),v._v(" "),e("p",[v._v("所谓同构，就是指前后端公用一套代码，比如我们的组件可以在服务端渲染也可以在客户端渲染，但都是同一个组件。这样的方式应该是可以甩传统方式好几条街了把。")]),v._v(" "),e("p",[v._v("当然打造同构应用还有另外一个得天独厚的条件，双端使用同一种语言 - javascript。")]),v._v(" "),e("p",[e("code",[v._v("SSR")]),v._v(" 部分我们使用"),e("code",[v._v("node")]),v._v("就能完成,所以我们才可以编写同一套代码供双端执行。")]),v._v(" "),e("p",[v._v("另外还有一个重要的特性也是同构的重要体现,浏览器接管页面后的进一步渲染（交互、事件）过程中，会判断已有的"),e("code",[v._v("DOM")]),v._v("结构和浏览器渲染出的结构是否相同，若相同，则不重复渲染，只需要绑定事件即可。")]),v._v(" "),e("p",[v._v("当然上面的这个特性是"),e("code",[v._v("react")]),v._v("提供的双端节点对比功能，也是为了最大限度的提高页面的渲染效率，尽可能的重用服务端给出的"),e("code",[v._v("html")]),v._v("结构。")]),v._v(" "),e("h2",{attrs:{id:"打造同构应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#打造同构应用"}},[v._v("#")]),v._v(" 打造同构应用")]),v._v(" "),e("p",[v._v("说了这么多其实本质还是"),e("code",[v._v("react")]),v._v("的能力，有了它的支持才能玩的转，这当然也得力于"),e("code",[v._v("node")]),v._v("。")]),v._v(" "),e("p",[v._v("说到这里，可能有同学会这样认为，既然"),e("code",[v._v("react")]),v._v("都为我们提供了，那我们实现起来就很方便了呀。和我们做"),e("code",[v._v("SPA")]),v._v("应用的时候差不多吧，只写一套代码，然后在服务端调用下"),e("code",[v._v("react")]),v._v("服务端渲染的相关 "),e("code",[v._v("api")]),v._v(" ，浏览器端也不需要管，"),e("code",[v._v("react")]),v._v("也帮我们搞定了。")]),v._v(" "),e("p",[v._v("说的好像没啥毛病，但是打造同构应该不是仅仅调用几个"),e("code",[v._v("api")]),v._v("的事儿，如果你只是打算写一个"),e("code",[v._v("demo")]),v._v("玩玩，我觉得是可以的。")]),v._v(" "),e("p",[v._v("同构的最大优点是双端可以公用一套代码，但它是一把双刃剑，因为他还涉及到服务端，所以复杂性大大增加。")]),v._v(" "),e("p",[v._v("另外双端也不是完全能公用一套代码，还需要做很多差异化的处理。不只是代码层面的，还会涉及到架构和工程化。")]),v._v(" "),e("p",[v._v("虽然我们已经了解了"),e("code",[v._v("react ssr")]),v._v("的最核心的原理，但是并不能保证你能迅速的开发出这样体验的应用。")]),v._v(" "),e("p",[v._v("所以我们需要一个轮子，这个轮子本身已经帮我们完备了双端的差异处理，开发者只需要关心自身业务逻辑，开发中无差异化。")]),v._v(" "),e("p",[v._v("而这个轮子就是我们接下来要一步一步实现的"),e("code",[v._v("React SSR")]),v._v("应用开发骨架。")]),v._v(" "),e("h2",{attrs:{id:"双端对比机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双端对比机制"}},[v._v("#")]),v._v(" 双端对比机制")]),v._v(" "),e("p",[v._v("上面也提到了这个概念，这里需要详细的说明一下。")]),v._v(" "),e("p",[v._v("为了实现服务端渲染，打造同构应用，"),e("code",[v._v("React")]),v._v("内部实现了相关的"),e("code",[v._v("API")]),v._v("，可以让我们方便的将一个组件转换为"),e("code",[v._v("html")]),v._v("字符串。")]),v._v(" "),e("p",[v._v("下面介绍几个"),e("code",[v._v("API")])]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("import ReactDOMServer from 'react-dom/server'\n\n")])])]),e("p",[e("code",[v._v("ReactDOMServer")]),v._v(" 类可以帮我们在服务端渲染组件 - 得到组件的 "),e("code",[v._v("html")]),v._v(" 字符串。")]),v._v(" "),e("p",[v._v("下面是介绍该模块的两个方法")]),v._v(" "),e("ul",[e("li",[v._v("renderToString()")])]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("ReactDOMServer.renderToString(element)\n\n")])])]),e("p",[v._v("把一个"),e("code",[v._v("React")]),v._v("组件渲染为原始的"),e("code",[v._v("HTML")]),v._v("。")]),v._v(" "),e("p",[v._v("我们可以用这个方法在服务端生成"),e("code",[v._v("HTML")]),v._v("字符串，然后将该字符串返回给浏览器端，完成页面内容的初始化，同时让搜索引擎可以抓取你的页面来达到优化"),e("code",[v._v("SEO")]),v._v("的目的。")]),v._v(" "),e("p",[v._v("另外在"),e("code",[v._v("react 16")]),v._v("前该方法生成的"),e("code",[v._v("html")]),v._v("内容的每一个"),e("code",[v._v("DOM")]),v._v("节点都有一个"),e("code",[v._v("data-react-id")]),v._v("属性，根节点会有一个"),e("code",[v._v("data-react-checksum")]),v._v("属性。")]),v._v(" "),e("p",[v._v("组件在服务端渲染后，在浏览器端还会渲染一次，来完成组件的交互等逻辑。渲染时，"),e("code",[v._v("react")]),v._v("在浏览器端会计算出组件的"),e("code",[v._v("data-react-checksum")]),v._v("属性值，如果发现和服务端计算的值一致，则不会进行客户端渲染。所以"),e("code",[v._v("data-react-checksum")]),v._v("属性的作用是为了完成组件的双端对比。")]),v._v(" "),e("p",[v._v("如果两个组件的"),e("code",[v._v("props")]),v._v("和"),e("code",[v._v("DOM")]),v._v("结构是相同的，那么计算出的该属性值就是一致的。")]),v._v(" "),e("p",[v._v("也可以换个角度来理解，当双端渲染的组件的"),e("code",[v._v("props")]),v._v("和"),e("code",[v._v("DOM")]),v._v("结构一致时，那么该组件只会渲染一次，客户端会采用服务端渲染的结果，仅作事件绑定等处理，这会让我们的应用有一个非常高效的初次加载体验。")]),v._v(" "),e("p",[v._v("ps:"),e("code",[v._v("data-react-checksum")]),v._v("属性值是通过"),e("code",[v._v("Adler-32")]),v._v("校验算法实现的。有兴趣的可以了解下此算法，这里就不详细说明了。")]),v._v(" "),e("ul",[e("li",[v._v("renderToStaticMarkup()")])]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("ReactDOMServer.renderToStaticMarkup(element)\n\n")])])]),e("p",[v._v("该方法就比较轻量了，仅仅是为了将组件渲染为"),e("code",[v._v("html")]),v._v("字符串，不会带有"),e("code",[v._v("data-react-checksum")]),v._v("属性。")]),v._v(" "),e("p",[v._v("和上面方法的能力不同，当然使用场景也不同，如果只是单纯服务端渲染的话可以用该方法，性能肯定要比上面的方法高，因为不需要计算嘛，还能减少直出的内容体积。")]),v._v(" "),e("h3",{attrs:{id:"性能提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能提升"}},[v._v("#")]),v._v(" 性能提升")]),v._v(" "),e("p",[v._v("咱们上面说的都是"),e("code",[v._v("react 16")]),v._v("以前的，现在是什么样的呢？")]),v._v(" "),e("p",[v._v("从"),e("code",[v._v("react 16")]),v._v("开始，服务端渲染"),e("code",[v._v("renderToString")]),v._v("方法渲染的结果不再有"),e("code",[v._v("data-react-*")]),v._v("属性，当然也相应的提供了一个客户端渲染"),e("code",[v._v("API")]),v._v(" - "),e("code",[v._v("ReactDOM.hydrate()")]),v._v("，从使用上来说和"),e("code",[v._v("ReactDOM.render()")]),v._v("没有差别。")]),v._v(" "),e("p",[v._v("在浏览器端渲染时，该方法会最大限度的保留服务端使用"),e("code",[v._v("renderToString()")]),v._v("渲染的内容，同时添加事件绑定等交互。")]),v._v(" "),e("ul",[e("li",[v._v("renderToNodeStream 和 renderToStaticNodeStream")])]),v._v(" "),e("p",[v._v("另外 "),e("code",[v._v("react 16")]),v._v(" 在性能上还做了改进，提供了可以将组件转换为字节流的"),e("code",[v._v("renderToNodeStream")]),v._v("方法。")]),v._v(" "),e("p",[v._v("其实使用"),e("code",[v._v("renderToNodeStream")]),v._v("或者"),e("code",[v._v("renderToString")]),v._v("对最终的渲染结果没有影响。不过"),e("code",[v._v("renderToNodeStream")]),v._v("的性能要好的多，可以有效缩短"),e("code",[v._v("TTFB")]),v._v("时间。")]),v._v(" "),e("p",[v._v("因为组件渲染为字符串，是一次性处理完后才开始向浏览器端返回结果。而采用流的话，可以边读边输出，可以要让页面更快的展现，缩短首屏展现时间。")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/30/16ff2883d6d95e82?w=397&h=398&f=png&s=20288",alt:""}})]),v._v(" "),e("p",[v._v("那么"),e("code",[v._v("renderToStaticNodeStream")]),v._v("可以结合 "),e("code",[v._v("renderToStaticMarkup")]),v._v("理解下，作用应该很明了了。")]),v._v(" "),e("h2",{attrs:{id:"同构应用流程图"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同构应用流程图"}},[v._v("#")]),v._v(" 同构应用流程图")]),v._v(" "),e("p",[v._v("上面我们介绍了很多理论性的知识，可能不够具象。")]),v._v(" "),e("p",[v._v("为了加强理解我准备了一张同构应用的流程图。")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/28/16fe82eb96f4a852?w=795&h=2029&f=png&s=204615",alt:""}})]),v._v(" "),e("h1",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[v._v("#")]),v._v(" 小结")]),v._v(" "),e("p",[v._v("本节我们主要从原理来了解下"),e("code",[v._v("react ssr")]),v._v("技术，目的是希望能对该技术有更深的理解和认识。")]),v._v(" "),e("p",[v._v("另外可以根据同构应用流程图来对我们的应用骨架有个宏观的认识，后面我们就要进入实践阶段，一步一步的来打造我们的应用骨架了。")]),v._v(" "),e("p",[e("strong",[v._v("造轮子，所需要的工具")])]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("node10.14  其实支持async await的版本就可以\nreact16.8 \nreact-router5 \nredux\nredux-thunk\nwebpack4 \nbabel7 \nkoa2 ，小册里使用 koa2，当然用 express 也可以\n...其他的一些插件和库，细节在后面说明\n\n")])])]),e("p",[v._v("let's go！一起去造轮子啦!")])])}),[],!1,null,null,null);_.default=a.exports}}]);