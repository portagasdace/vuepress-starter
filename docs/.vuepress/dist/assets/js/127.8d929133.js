(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{483:function(e,t,d){"use strict";d.r(t);var i=d(42),n=Object(i.a)({},(function(){var e=this,t=e.$createElement,d=e._self._c||t;return d("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[d("h1",{attrs:{id:"使用-scopedmodel-对豆瓣电影-app-进行重构"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#使用-scopedmodel-对豆瓣电影-app-进行重构"}},[e._v("#")]),e._v(" 使用 ScopedModel 对豆瓣电影 App 进行重构")]),e._v(" "),d("p",[e._v("本节使用 ScopedModel 对豆瓣电影 App 进行重构。")]),e._v(" "),d("h2",{attrs:{id:"重构后的工程路径"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#重构后的工程路径"}},[e._v("#")]),e._v(" 重构后的工程路径")]),e._v(" "),d("p",[e._v("StateManager/flutter_doubanmovie_scopedmodel")]),e._v(" "),d("h2",{attrs:{id:"scopedmodel"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#scopedmodel"}},[e._v("#")]),e._v(" ScopedModel")]),e._v(" "),d("p",[e._v("ScopedModel 是一个可以对状态进行管理的第三方库，该库是从 Fuchsia 的代码库中提取的。")]),e._v(" "),d("h3",{attrs:{id:"scopedmodel-的使用"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#scopedmodel-的使用"}},[e._v("#")]),e._v(" ScopedModel 的使用")]),e._v(" "),d("p",[e._v("使用 ScopedModel 进行状态管理，要用到这个库提供的三个类，掌握这三个类的使用，就掌握了 ScopedModel。这三个类分别是：")]),e._v(" "),d("ul",[d("li",[e._v("Model")]),e._v(" "),d("li",[e._v("ScopedModel")]),e._v(" "),d("li",[e._v("ScopedModelDescendant")])]),e._v(" "),d("h4",{attrs:{id:"model"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#model"}},[e._v("#")]),e._v(" Model")]),e._v(" "),d("p",[e._v("Model 是类，用来存储全局状态，当状态发生变化时，调用 "),d("code",[e._v("notifyListeners()")]),e._v(" 方法，就会通知给依赖这个状态的子 Widget，引起子 Widget 的创建。我们需要继承 Model 类来写自己的 Models，例如 我们写一个 UserModel，里面可以用来存储用户的用户名和 token。")]),e._v(" "),d("h4",{attrs:{id:"scopedmodel-2"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#scopedmodel-2"}},[e._v("#")]),e._v(" ScopedModel")]),e._v(" "),d("p",[e._v("ScopedModel 是 Widget，用来共享全局状态，可以将 Model 里的状态传递给它的子 Widget。为了将状态传递给子 Widget，我们需要使用 ScopedModel 来包 Model。")]),e._v(" "),d("h4",{attrs:{id:"scopedmodeldescendant"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#scopedmodeldescendant"}},[e._v("#")]),e._v(" ScopedModelDescendant")]),e._v(" "),d("p",[e._v("ScopedModelDescendant 也是 Widget，用于需要依赖 Model 里状态的子 Widget 中，而且会自动订阅 Model 里状态的变化，当 Model 里状态发生变化时，就会触发 ScopedModelDescendant 的重建。")]),e._v(" "),d("h3",{attrs:{id:"子widget-中获取-model-的方法"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#子widget-中获取-model-的方法"}},[e._v("#")]),e._v(" 子Widget 中获取 Model 的方法")]),e._v(" "),d("p",[e._v("有两种方法可以在子 Widget 中获取 Model：")]),e._v(" "),d("ol",[d("li",[e._v("使用 ScopedModelDescendant，可以获取 Model，并且在 Model 变化时会重建。")]),e._v(" "),d("li",[e._v("使用 "),d("code",[e._v("ScopedModel.of")]),e._v(" 的静态方法获取 Model 实例，但是无法收到 Model 变化的通知。如果需要频繁使用，可以在 Model 里写一个静态方法，下面会讲到。")])]),e._v(" "),d("h2",{attrs:{id:"使用-scopedmodel-重构"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#使用-scopedmodel-重构"}},[e._v("#")]),e._v(" 使用 ScopedModel 重构")]),e._v(" "),d("p",[e._v("在 pubspec.yaml 里添加 ScopedModel 库的依赖：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("dependencies:\n  ...\n  scoped_model: ^1.0.1\n\n")])])]),d("p",[e._v("在 VS Code 里选择保存后，会自动下载依赖库。")]),e._v(" "),d("p",[e._v("第一步，是创建 CityModel 类，里面存储 "),d("code",[e._v("curCity")]),e._v(" 的值，同时写一个可以设置 "),d("code",[e._v("curCity")]),e._v(" 值的方法，并且在这个方法里，当 "),d("code",[e._v("curCity")]),e._v(" 的值设置完后，还需要调用 "),d("code",[e._v("notifyListeners()")]),e._v(" ：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("class CityModel extends Model {\n  String curCity;\n\n  void setCurCity(String city) {\n    if (curCity != city) {\n      curCity = city;\n\n      //通知状态发生变化\n      notifyListeners();\n    }\n  }\n}\n\n")])])]),d("p",[e._v("因为第一次打开的时候 "),d("code",[e._v("curCity")]),e._v(" 需要从本地读取数据，这个读取数据的操作比较耗时，所以必须得异步操作，所以 CityModel 里的 "),d("code",[e._v("curCity")]),e._v(" 的值默认只能是空的，读取到数据后在赋值，使得状态发生变化，从而触发 Widget 的重建，代码需要这么写：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("class CityModel extends Model {\n  ...\n  void initData() async {\n    final prefs = await SharedPreferences.getInstance(); //获取 prefs\n\n    String city = prefs.getString('curCity'); //获取 key 为 curCity 的值\n\n    if (city != null && city.isNotEmpty) {\n      //如果有值\n      setCurCity(city);\n    } else {\n      //如果没有值，则使用默认值\n      setCurCity('深圳');\n    }\n  }\n  ...\n}\n\n")])])]),d("p",[e._v("在 CityModel 在建一个静态方法，获取 CityModel 的实例：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("class CityModel extends Model {\n  ...\n\n  static CityModel of(BuildContext context) => ScopedModel.of<CityModel>(context);\n}\n\n")])])]),d("p",[e._v("第二步，使用 "),d("code",[e._v("ScopedModel<CityModel>()")]),e._v(" 作为父 Widget，代码如下：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("class _MyHomePageState extends State<MyHomePage> {\n  ...\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: ScopedModel<CityModel>(\n        model: cityModel,\n        child: _widgetItems[_selectedIndex],\n      ), //选中不同的选项显示不同的界面,\n      ...\n    );\n  }\n\n  ...\n}\n\n")])])]),d("p",[e._v("第三步，开始对依赖 "),d("code",[e._v("curCity")]),e._v(" 的 Widget 进行重构，在 HotWidget 里需要使用 ScopedModelDescendant 来包原来的 HotWidget：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("class HotWidgetState extends State<HotWidget> {\n  @override\n  void initState() {\n    // TODO: implement initState\n    super.initState();\n    print('HotWidgetState initState');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: implement build\n    print('HotWidgetState build');\n    return ScopedModelDescendant<CityModel>(\n          ...\n    );\n  }\n}\n\n")])])]),d("p",[e._v("这里 ScopedModelDescendant 有三个参数：")]),e._v(" "),d("ul",[d("li",[d("p",[e._v("child")]),e._v(" "),d("p",[e._v("child 的类型为 Widget，是可选的，这个 child 是不需要依赖 Model 的 Widget，将会传递给 builder。")])]),e._v(" "),d("li",[d("p",[e._v("builder")]),e._v(" "),d("p",[e._v("builder 的类型为 ScopedModelDescendantBuilder，是一个函数，是必选的，定义为：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("typedef Widget ScopedModelDescendantBuilder<T extends Model>(\n  BuildContext context,\n  Widget child,\n  T model,\n);\n\n")])])]),d("p",[e._v("函数的参数有 context、child、model，在函数的内部可以访问这三个参数，builder 里的 child 就是上面提到的 child，在 builder 通过 modle 参数访问状态数据，例如 "),d("code",[e._v("modle.curCity")]),e._v("， 最后返回一个 Widget。")])]),e._v(" "),d("li",[d("p",[e._v("rebuildOnChange")]),e._v(" "),d("p",[e._v("rebuildOnChange 是 bool 类型，是可选的，表示当状态发生变化的时候是否需要重建，默认是 true，除非特别情况，这里应该永远是 true。")])])]),e._v(" "),d("p",[e._v("所以继续重构代码，将 HotWidgetState 里的 "),d("code",[e._v("curCity")]),e._v(" 变量删掉，并替换成 "),d("code",[e._v("model.curCity")]),e._v("：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("return ScopedModelDescendant<CityModel>(\n      builder: (context, child, model) {\n        if (model.curCity != null && model.curCity.isNotEmpty) {\n          //如果 curCity 不为空\n          return ...\n        } else {\n          //如果 curCity 为空\n          return ...\n        }\n      },\n    );\n\n")])])]),d("p",[e._v("这个时候 "),d("code",[e._v("_jumpToCitysWidget()")]),e._v(" 方法会报错，给这个方法增加一个 "),d("code",[e._v("city")]),e._v(" 的参数，从调用的地方传过来，因为这个方法里会改变 CityModel 里 "),d("code",[e._v("curCity")]),e._v(" 的值，需要调用 CityModel 的 "),d("code",[e._v("setCurCity()")]),e._v(" 方法，所以还要增加一个 CityModel 的参数，最后代码就是：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("  void _jumpToCitysWidget(CityModel model,String city) async {\n    var selectCity =\n        await Navigator.pushNamed(context, '/Citys', arguments: city);\n    if (selectCity == null) return;\n\n    final prefs = await SharedPreferences.getInstance();\n    prefs.setString('curCity', selectCity); //存取数据\n\n    model.setCurCity(selectCity);\n  }\n\n")])])]),d("p",[e._v("调用 "),d("code",[e._v("_jumpToCitysWidget()")]),e._v(" 方法的代码就变为:")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("_jumpToCitysWidget(model,model.curCity);\n\n")])])]),d("p",[e._v("重构完 HotWidget 后，同理对 HotMoviesListWidget、CitysWidget 进行重构。")]),e._v(" "),d("p",[e._v("因为 HotMoviesListWidget 里的 "),d("code",[e._v("curCity")]),e._v(" 的值需要在 build 之前就要用到，而且 HotMoviesListWidget 也没必要监听 CityModel 的变化，因为 HotMoviesListWidget 的父 Widget 是 HotWidget，HotWidget 已经对 CityModel 进行了变化，HotWidget 重建的时候也会引起 HotMoviesListWidget 的重建，所以 HotMoviesListWidget 里就不用 "),d("code",[e._v("ScopedModelDescendant<CityModel>(...)")]),e._v(" 了，而是用 "),d("code",[e._v("CityModel.of(context)")]),e._v("，而且因为要用到 context，和前面使用 InheritedWidget 一样的理由，"),d("code",[e._v("_getData()")]),e._v(" 放到 "),d("code",[e._v("didChangeDependencies()")]),e._v("里，重构后的代码为：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("class HotMoviesListWidget extends StatefulWidget {\n  HotMoviesListWidget() {}\n\n  @override\n  State<StatefulWidget> createState() {\n    // TODO: implement createState\n    return HotMoviesListWidgetState();\n  }\n}\n\nclass HotMoviesListWidgetState extends State<HotMoviesListWidget>\n    with AutomaticKeepAliveClientMixin {\n  List<HotMovieData> hotMovies = new List<HotMovieData>();\n\n  @override\n  void initState() {\n    // TODO: implement initState\n    super.initState();\n  }\n\n  @override\n  void didChangeDependencies() {\n    // TODO: implement didChangeDependencies\n    super.didChangeDependencies();\n    _getData();\n  }\n\n  void _getData() async {\n    List<HotMovieData> serverDataList = new List();\n    var response = await http.get(\n        'https://api.douban.com/v2/movie/in_theaters?apikey=0b2bdeda43b5688921839c8ecb20399b&city=' +\n            CityModel.of(context).curCity +\n            '&start=0&count=10');\n    //成功获取数据\n    ...\n  }\n\n  ...\n}\n\n")])])]),d("p",[e._v("HotMoviesListWidget 的构造函数去掉了参数，所以之前调用的地方要把参数去掉。")]),e._v(" "),d("p",[e._v("CitysWidget 这里就可以重构，也可以不重构，因为原先这里的 "),d("code",[e._v("curCity")]),e._v(" 的值是通过参数传过来的，耦合性就比较低，但是传参还是挺麻烦的，这里我们还是重构一下吧。")]),e._v(" "),d("p",[e._v("CitysWidget 的重构有一点麻烦，因为 CitysWidget 是通过路由创建的，因此 CitysWidget 的父 Widget 和 HotWidget 的父 Widget 不同，所以为了让 CitysWidget 访问到 Model，一方面要用 "),d("code",[e._v("ScopedModel<CityModel>()")]),e._v("，同时 HotWidget 和 CitysWidget 要公用同一个 CityModel 的实例，所以重构后的代码如下：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("CityModel cityModel = CityModel();\n\nclass MyApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      ...\n      routes: {\n        '/Citys': (context) => ScopedModel<CityModel>(\n              model: cityModel,\n              child: ScopedModelDescendant<CityModel>(\n                builder: (context, child, model) {\n                  return CitysWidget();\n                },\n              ),\n            ),\n      },\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n   ...\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  ...\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: ScopedModel<CityModel>(\n        model: cityModel,\n        child: _widgetItems[_selectedIndex],\n      ), //选中不同的选项显示不同的界面,\n      ...\n    );\n  }\n  ...\n}\n\n")])])]),d("p",[d("code",[e._v("curCity")]),e._v(" 就使用 "),d("code",[e._v("CityModel.of(context)")]),e._v(" 来获取，CitysWidget 重构后的代码为：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("class CityWidgtState extends State<CitysWidget> {\n  String curCity;\n\n  @override\n  Widget build(BuildContext context) {\n    // TODO: implement build\n    curCity = CityModel.of(context).curCity;\n    ...\n  }\n}\n\n")])])]),d("p",[e._v("同时把传递参数的代码删掉，在 HotWidget 的 "),d("code",[e._v("_jumpToCitysWidget()")]),e._v(" 方法，重构后的代码为：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v("void _jumpToCitysWidget(CityModel model,String city) async {\n    var selectCity =\n        await Navigator.pushNamed(context, '/Citys');\n    ...\n  }\n\n")])])]),d("p",[e._v("接下来在看一下，能不能把 UI 逻辑和业务逻辑分离，同样看一下 HotMoviesListWidget 里，既包含了一个请求数据，又包含了数据的显示，可以考虑把数据的请求和显示分开，数据请求部分如下：")]),e._v(" "),d("div",{staticClass:"language- extra-class"},[d("pre",{pre:!0,attrs:{class:"language-text"}},[d("code",[e._v(" void _getData() async {\n    List<HotMovieData> serverDataList = new List();\n    var response = await http.get(\n        'https://api.douban.com/v2/movie/in_theaters?apikey=0b2bdeda43b5688921839c8ecb20399b&city=' +\n            ShareDataInheritedWidget.of(context).curCity +\n            '&start=0&count=10');\n    //成功获取数据\n    if (response.statusCode == 200) {\n      var responseJson = json.decode(response.body);\n      for (dynamic data in responseJson['subjects']) {\n        HotMovieData hotMovieData = HotMovieData.fromJson(data);\n        serverDataList.add(hotMovieData);\n      }\n      setState(() {\n        hotMovies = serverDataList;\n      });\n    }\n  }\n\n")])])]),d("p",[e._v("但是这部分应该放在哪呢？其遇到的问题和 InheritedWidget 的状态管理框是一样的，这里既不能放在 CityModel 里，因为这部分其实是本地状态， 创建一个新的 Model，会把原来的本地状态变为全局状态，导致代码复杂话，不适合扩展，从中也可以看到 ScopedModel 的状态管理框架并没有考虑 UI 逻辑和业务逻辑分离的问题。")]),e._v(" "),d("h2",{attrs:{id:"分析"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#分析"}},[e._v("#")]),e._v(" 分析")]),e._v(" "),d("p",[e._v("在使用 ScopedModel 重构完后，对比一下一个好的状态管理框架应该具有的条件：")]),e._v(" "),d("ul",[d("li",[e._v("能管理好全局状态和本地状态")]),e._v(" "),d("li",[e._v("UI 逻辑和业务逻辑应该是分离的")]),e._v(" "),d("li",[e._v("在框架的帮助下可以写出高质量的代码")]),e._v(" "),d("li",[e._v("框架应该提升 App 的性能")]),e._v(" "),d("li",[e._v("框架要容易理解，便于扩展")])]),e._v(" "),d("p",[e._v("我们发现 ScopedModel 只能管理全局状态，而且没有涉及到 UI 逻辑和业务逻辑的分离。")]),e._v(" "),d("h2",{attrs:{id:"总结"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),d("p",[e._v("通过 ScopedModel 对豆瓣电影 App 的重构，我们可以发现 ScopedModel 也可以对全局状态进行管理，相对于 InheritedWidget 来说，有如下优点：")]),e._v(" "),d("ul",[d("li",[e._v("可以对全局状态进行管理")]),e._v(" "),d("li",[e._v("数据只能从上到下传递，也可以从下到上传递")])]),e._v(" "),d("p",[e._v("但是，依然有很多的缺点：")]),e._v(" "),d("ul",[d("li",[e._v("UI 逻辑和业务逻辑没有分开")]),e._v(" "),d("li",[e._v("无法管理本地状态")]),e._v(" "),d("li",[e._v("随着 App 变大，代码维护也会变得越来越难。")])]),e._v(" "),d("p",[e._v("所以，ScopedModel 只能在简单的 App 里使用，大型 App 绝对不能使用 ScopedModel 对状态进行管理。")])])}),[],!1,null,null,null);t.default=n.exports}}]);