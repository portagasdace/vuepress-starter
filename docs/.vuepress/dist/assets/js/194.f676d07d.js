(window.webpackJsonp=window.webpackJsonp||[]).push([[194],{548:function(n,r,i){"use strict";i.r(r);var e=i(42),t=Object(e.a)({},(function(){var n=this,r=n.$createElement,i=n._self._c||r;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h2",{attrs:{id:"前言"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[n._v("#")]),n._v(" 前言")]),n._v(" "),i("p",[n._v("策略模式和状态模式属于本书”彩蛋“性质的附加小节。这两种模式理解难度都不大，在面试中也几乎没有什么权重，但是却对大家培养良好的编码习惯和重构意识却大有裨益。针对这两种模式，大家了解、会用即可，不建议大家死磕。")]),n._v(" "),i("p",[n._v("策略模式不太适合一上来就怼概念，容易懵。咱们就先从一个非常贴近业务的需求讲起，大家跟我一起敲完这波代码，自然会知道策略模式是怎么回事儿了。")]),n._v(" "),i("h2",{attrs:{id:"先来看一个真实场景"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#先来看一个真实场景"}},[n._v("#")]),n._v(" 先来看一个真实场景")]),n._v(" "),i("p",[n._v("有一天，产品经理韩梅梅找到李雷，给李雷提了这么个需求："),i("br"),n._v("\n马上大促要来了，我们本次大促要做差异化询价。啥是差异化询价？就是说同一个商品，我通过在后台给它设置不同的价格类型，可以让它展示不同的价格。具体的逻辑如下：")]),n._v(" "),i("ul",[i("li",[n._v("当价格类型为“预售价”时，满 100 - 20，不满 100 打 9 折")]),n._v(" "),i("li",[n._v("当价格类型为“大促价”时，满 100 - 30，不满 100 打 8 折")]),n._v(" "),i("li",[n._v("当价格类型为“返场价”时，满 200 - 50，不叠加")]),n._v(" "),i("li",[n._v("当价格类型为“尝鲜价”时，直接打 5 折")])]),n._v(" "),i("p",[n._v("李雷扫了一眼 prd，立刻来了主意。他首先将四种价格做了标签化：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("预售价 - pre\n大促价 - onSale\n返场价 - back\n尝鲜价 - fresh\n\n")])])]),i("p",[n._v("接下来李雷仔细研读了 prd 的内容，作为资深 if-else 侠，他三下五除二就写出一套功能完备的代码：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("// 询价方法，接受价格标签和原价为入参\nfunction askPrice(tag, originPrice) {\n\n  // 处理预热价\n  if(tag === 'pre') {\n    if(originPrice >= 100) {\n      return originPrice - 20\n    } \n    return originPrice * 0.9\n  }\n  \n  // 处理大促价\n  if(tag === 'onSale') {\n    if(originPrice >= 100) {\n      return originPrice - 30\n    } \n    return originPrice * 0.8\n  }\n  \n  // 处理返场价\n  if(tag === 'back') {\n    if(originPrice >= 200) {\n      return originPrice - 50\n    }\n    return originPrice\n  }\n  \n  // 处理尝鲜价\n  if(tag === 'fresh') {\n     return originPrice * 0.5\n  }\n}\n\n")])])]),i("h2",{attrs:{id:"if-else-侠-人人喊打"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#if-else-侠-人人喊打"}},[n._v("#")]),n._v(" if-else 侠，人人喊打")]),n._v(" "),i("p",[n._v("随便跑一下，上述代码运行起来确实没啥毛病。但也只是“运行起来”没毛病而已。作为人人喊打的 if-else 侠，李雷必须为他的行为付出代价。我们一起来看看这么写代码会带来什么后果：")]),n._v(" "),i("ul",[i("li",[i("p",[n._v("首先，它违背了“单一功能”原则。一个 function 里面，它竟然处理了四坨逻辑——这个函数的逻辑太胖了！这样会带来什么样的糟糕后果，笔者在前面的小节中已经 BB 过很多次了：比如说万一其中一行代码出了 Bug，那么整个询价逻辑都会崩坏；与此同时出了 Bug 你很难定位到底是哪个代码块坏了事；再比如说单个能力很难被抽离复用等等等等。相信跟着我一路学下来的各位，也已经在重重实战中对胖逻辑的恶劣影响有了切身的体会。总之，见到胖逻辑，我们的第一反应，就是一个字——拆！")])]),n._v(" "),i("li",[i("p",[n._v("不仅如此，它还违背了“开放封闭”原则。假如有一天韩梅梅再次找到李雷，要他加一个满 100 - 50 的“新人价”怎么办？他只能继续 if-else：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("function askPrice(tag, originPrice) {\n\n  // 处理预热价\n  if(tag === 'pre') {\n    if(originPrice >= 100) {\n      return originPrice - 20\n    } \n    return originPrice * 0.9\n  }\n  // 处理大促价\n  if(tag === 'onSale') {\n    if(originPrice >= 100) {\n      return originPrice - 30\n    } \n    return originPrice * 0.8\n  }\n\n  // 处理返场价\n  if(tag === 'back') {\n    if(originPrice >= 200) {\n      return originPrice - 50\n    }\n    return originPrice\n  }\n\n  // 处理尝鲜价\n  if(tag === 'fresh') {\n     return originPrice * 0.5\n  }\n  \n  // 处理新人价\n  if(tag === 'newUser') {\n    if(originPrice >= 100) {\n      return originPrice - 50\n    }\n    return originPrice\n  }\n}\n\n")])])]),i("p",[n._v("没错，李雷灰溜溜地跑去改了 askPrice 函数！随后他恬不知耻地徐徐转头，对背后的测试同学说：哥，我改了询价函数，麻烦你帮我把"),i("strong",[n._v("整个询价逻辑")]),n._v("回归一下。测试同学莞尔一笑， 心中早已有无数头羊驼在狂奔。他强忍着周末加班的悲痛，做完了这漫长而不必要的回归测试，随后默默点击了同事系统里的举报按钮对李雷说：哥，求你学学设计模式吧！！")])])]),n._v(" "),i("h2",{attrs:{id:"重构询价逻辑"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#重构询价逻辑"}},[n._v("#")]),n._v(" 重构询价逻辑")]),n._v(" "),i("p",[n._v("现在我们基于我们已经学过的设计模式思想，一点一点改造掉这个臃肿的 askPrice。")]),n._v(" "),i("h4",{attrs:{id:"单一功能改造"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#单一功能改造"}},[n._v("#")]),n._v(" 单一功能改造")]),n._v(" "),i("p",[n._v("首先，我们赶紧把四种询价逻辑提出来，让它们各自为政：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("// 处理预热价\nfunction prePrice(originPrice) {\n  if(originPrice >= 100) {\n    return originPrice - 20\n  } \n  return originPrice * 0.9\n}\n\n// 处理大促价\nfunction onSalePrice(originPrice) {\n  if(originPrice >= 100) {\n    return originPrice - 30\n  } \n  return originPrice * 0.8\n}\n\n// 处理返场价\nfunction backPrice(originPrice) {\n  if(originPrice >= 200) {\n    return originPrice - 50\n  }\n  return originPrice\n}\n\n// 处理尝鲜价\nfunction freshPrice(originPrice) {\n  return originPrice * 0.5\n}\n\nfunction askPrice(tag, originPrice) {\n  // 处理预热价\n  if(tag === 'pre') {\n    return prePrice(originPrice)\n  }\n  // 处理大促价\n  if(tag === 'onSale') {\n    return onSalePrice(originPrice)\n  }\n\n  // 处理返场价\n  if(tag === 'back') {\n    return backPrice(originPrice)\n  }\n\n  // 处理尝鲜价\n  if(tag === 'fresh') {\n     return freshPrice(originPrice)\n  }\n}\n\n")])])]),i("p",[n._v("OK，我们现在至少做到了一个函数只做一件事。现在每个函数都有了自己明确的、单一的分工：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("prePrice - 处理预热价\nonSalePrice - 处理大促价\nbackPrice - 处理返场价\nfreshPrice - 处理尝鲜价\naskPrice - 分发询价逻辑\n\n")])])]),i("p",[n._v("如此一来，我们在遇到 Bug 时，就可以做到“头痛医头，脚痛医脚”，而不必在庞大的逻辑海洋里费力去定位到底是哪块不对。")]),n._v(" "),i("p",[n._v("同时，如果我在另一个函数里也想使用某个询价能力，比如说我想询预热价，那我直接把 prePrice 这个函数拿去调用就是了，而不必在 askPrice 肥胖的身躯里苦苦寻觅、然后掏出这块逻辑、最后再复制粘贴到另一个函数去——更何况万一哪天 askPrice 里的预热价逻辑改了，你还得再复制粘贴一次，扎心啊老铁！")]),n._v(" "),i("p",[n._v("到这里，在单一功能原则的指引下，我们已经解决了一半的问题。")]),n._v(" "),i("p",[n._v("我们现在来捋一下，其实这个询价逻辑整体上来看只有两个关键动作：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("询价逻辑的分发 ——> 询价逻辑的执行\n\n")])])]),i("p",[n._v("在改造的第一步，我们已经把“询价逻辑的执行”给摘了出去，并且实现了不同询价逻辑之间的解耦。接下来，我们就要拿“分发”这个动作开刀。")]),n._v(" "),i("h4",{attrs:{id:"开放封闭改造"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#开放封闭改造"}},[n._v("#")]),n._v(" 开放封闭改造")]),n._v(" "),i("p",[n._v("剩下一半的问题是啥呢？就是咱们上面说的那个新人价的问题——这会儿我要想给 askPrice 增加新人询价逻辑，我该咋整？我只能这么来：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("// 处理预热价\nfunction prePrice(originPrice) {\n  if(originPrice >= 100) {\n    return originPrice - 20\n  } \n  return originPrice * 0.9\n}\n\n// 处理大促价\nfunction onSalePrice(originPrice) {\n  if(originPrice >= 100) {\n    return originPrice - 30\n  } \n  return originPrice * 0.8\n}\n\n// 处理返场价\nfunction backPrice(originPrice) {\n  if(originPrice >= 200) {\n    return originPrice - 50\n  }\n  return originPrice\n}\n\n// 处理尝鲜价\nfunction freshPrice(originPrice) {\n  return originPrice * 0.5\n}\n\n// 处理新人价\nfunction newUserPrice(originPrice) {\n  if(originPrice >= 100) {\n    return originPrice - 50\n  }\n  return originPrice\n}\n\nfunction askPrice(tag, originPrice) {\n  // 处理预热价\n  if(tag === 'pre') {\n    return prePrice(originPrice)\n  }\n  // 处理大促价\n  if(tag === 'onSale') {\n    return onSalePrice(originPrice)\n  }\n\n  // 处理返场价\n  if(tag === 'back') {\n    return backPrice(originPrice)\n  }\n\n  // 处理尝鲜价\n  if(tag === 'fresh') {\n     return freshPrice(originPrice)\n  }\n  \n  // 处理新人价\n  if(tag === 'newUser') {\n     return newUserPrice(originPrice)\n  }\n}\n\n")])])]),i("p",[n._v("在外层，我们编写一个 newUser 函数用于处理新人价逻辑；在 askPrice 里面，我们新增了一个 if-else 判断。可以看出，这样其实还是在修改 askPrice 的函数体，没有实现“对扩展开放，对修改封闭”的效果。")]),n._v(" "),i("p",[n._v("那么我们应该怎么做？我们仔细想想，楼上用了这么多 if-else，我们的目的到底是什么？是不是就是为了把 询价标签-询价函数 这个映射关系给明确下来？那么在 JS 中，有没有什么既能够既帮我们明确映射关系，同时不破坏代码的灵活性的方法呢？答案就是"),i("strong",[n._v("对象映射")]),n._v("！")]),n._v(" "),i("p",[n._v("咱们完全可以把询价算法全都收敛到一个对象里去嘛：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("// 定义一个询价处理器对象\nconst priceProcessor = {\n  pre(originPrice) {\n    if (originPrice >= 100) {\n      return originPrice - 20;\n    }\n    return originPrice * 0.9;\n  },\n  onSale(originPrice) {\n    if (originPrice >= 100) {\n      return originPrice - 30;\n    }\n    return originPrice * 0.8;\n  },\n  back(originPrice) {\n    if (originPrice >= 200) {\n      return originPrice - 50;\n    }\n    return originPrice;\n  },\n  fresh(originPrice) {\n    return originPrice * 0.5;\n  },\n};\n\n")])])]),i("p",[n._v("当我们想使用其中某个询价算法的时候：通过标签名去定位就好了：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("// 询价函数\nfunction askPrice(tag, originPrice) {\n  return priceProcessor[tag](originPrice)\n}\n\n")])])]),i("p",[n._v("如此一来，askPrice 函数里的 if-else 大军彻底被咱们消灭了。这时候如果你需要一个新人价，只需要给 priceProcessor 新增一个映射关系：")]),n._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("priceProcessor.newUser = function (originPrice) {\n  if (originPrice >= 100) {\n    return originPrice - 50;\n  }\n  return originPrice;\n}\n\n")])])]),i("p",[n._v("这样一来，询价逻辑的分发也变成了一个清清爽爽的过程。当李雷以这种方式新增一个新人价的询价逻辑的时候，就可以底气十足地对测试同学说：老哥，我改了询价逻辑，但是改动范围仅仅涉及到新人价，是一个单纯的功能增加。所以你只测这个新功能点就 OK，老逻辑不用管！")]),n._v(" "),i("p",[n._v("从此，李雷就从人人喊打的 if-else 侠，摇身一变成为了测试之友、中国好开发。业务代码里的询价逻辑，也因为李雷坚守设计原则100年不动摇，而变得易读、易维护。")]),n._v(" "),i("h2",{attrs:{id:"这-就是策略模式"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#这-就是策略模式"}},[n._v("#")]),n._v(" 这，就是策略模式！")]),n._v(" "),i("p",[n._v("说起来你可能不相信，咱们上面的整个重构的过程，就是对策略模式的应用。"),i("br"),n._v("\n现在大家来品品策略模式的定义：")]),n._v(" "),i("blockquote",[i("p",[n._v("定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。")])]),n._v(" "),i("p",[n._v("回头看看，咱们忙活到现在，是不是就干了这事儿？")]),n._v(" "),i("p",[n._v("但你要直接读这句话，可能确实会懵圈——啥是算法？如何封装？可替换又是咋做到的？")]),n._v(" "),i("p",[n._v("如今你你已经自己动手实现了算法提取、算法封装、分发优化的整个一条龙的操作流，相信面对这条定义，你可以会心一笑——算法，就是我们这个场景中的询价逻辑，它也可以是你任何一个功能函数的逻辑；“封装”就是把某一功能点对应的逻辑给提出来；“可替换”建立在封装的基础上，只是说这个“替换”的判断过程，咱们不能直接怼 if-else，而要考虑更优的映射方案。")]),n._v(" "),i("p",[n._v("（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流^_^）")])])}),[],!1,null,null,null);r.default=t.exports}}]);