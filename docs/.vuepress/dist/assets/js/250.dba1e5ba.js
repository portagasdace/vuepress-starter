(window.webpackJsonp=window.webpackJsonp||[]).push([[250],{607:function(e,n,t){"use strict";t.r(n);var a=t(42),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"实战篇-4-小程序列表获取-使用-sequelize"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战篇-4-小程序列表获取-使用-sequelize"}},[e._v("#")]),e._v(" 实战篇 4：小程序列表获取 —— 使用 Sequelize")]),e._v(" "),t("p",[e._v("上一节，我们的店铺 shops 表与商品 goods 表都已经通过 migrate 与 seed，完成了表结构的创建与数据的填充。本小节我们把知识点聚焦在 Sequelize 插件库本身的数据模型 model 的查询能力，来实现小程序店铺的列表查询与商品列表查询。")]),e._v(" "),t("h2",{attrs:{id:"sequelize-连接-mysql-数据库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sequelize-连接-mysql-数据库"}},[e._v("#")]),e._v(" Sequelize 连接 MySQL 数据库")]),e._v(" "),t("p",[e._v("Sequelize 连接数据库的核心代码主要就是通过 new Sequelize（database, username, password, options） 来实现，其中 options 中的配置选项，除了最基础的 host 与 port、数据库类型外，还可以设置连接池的连接参数 pool，数据模型命名规范 underscored 等等。具体可以查阅官方手册 "),t("a",{attrs:{href:"http://docs.sequelizejs.com/manual/installation/usage.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("基础使用"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("由于前一小节通过 sequelize-cli init 初始化了 models 的目录，sequelize-cli 已经特别友好地为我们准备了一个动态加载 models 目录中具体数据库表模型的入口模块 index.js。由于我们希望遵循 MySQL 数据库表字段的下划线命名规范，所以，需要全局开启一个 "),t("code",[e._v("underscore: true")]),e._v(" 的定义，来使系统中默认的 createdAt 与 updatedAt 能以下划线的方式，与表结构保持一致。")]),e._v(" "),t("p",[e._v("微调 models/index.js 中的代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// models/index.js\n\n// 将 const config = configs[env] 调整为如下结构\n\nconst config = {\n  ...configs[env],\n  define: {\n    underscored: true,\n  },\n};\n\n")])])]),t("h2",{attrs:{id:"定义数据库业务相关的-model"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义数据库业务相关的-model"}},[e._v("#")]),e._v(" 定义数据库业务相关的 model")]),e._v(" "),t("p",[e._v("结合业务所需，我们在 models 目录下继续创建一系列的 model 来与数据库表结构做对应：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("├── models                       # 数据库 model\n│   ├── index.js                 # model 入口与连接\n│   ├── goods.js                 # 商品表\n│   ├── shops.js                 # 店铺表\n\n")])])]),t("h3",{attrs:{id:"_1-定义店铺的数据模型-shops"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-定义店铺的数据模型-shops"}},[e._v("#")]),e._v(" 1. 定义店铺的数据模型 shops")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// models/shops.js\n\nmodule.exports = (sequelize, DataTypes) => sequelize.define(\n  'shops',\n  {\n    id: {\n      type: DataTypes.INTEGER,\n      primaryKey: true,\n      autoIncrement: true,\n    },\n    name: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    thumb_url: DataTypes.STRING,\n  },\n  {\n    tableName: 'shops',\n  },\n);\n\n\n")])])]),t("h3",{attrs:{id:"_2-定义商品的数据模型-goods"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-定义商品的数据模型-goods"}},[e._v("#")]),e._v(" 2.定义商品的数据模型 goods")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports = (sequelize, DataTypes) => sequelize.define(\n  'goods',\n  {\n    id: {\n      type: DataTypes.INTEGER,\n      primaryKey: true,\n      autoIncrement: true,\n    },\n    shop_id: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n    },\n    name: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    thumb_url: DataTypes.STRING,\n  },\n  {\n    tableName: 'goods',\n  },\n);\n\n\n")])])]),t("h2",{attrs:{id:"实现店铺列表页接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现店铺列表页接口"}},[e._v("#")]),e._v(" 实现店铺列表页接口")]),e._v(" "),t("h3",{attrs:{id:"_1-实现简单的店铺列表接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-实现简单的店铺列表接口"}},[e._v("#")]),e._v(" 1. 实现简单的店铺列表接口")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// routes/shops.js\n\n// 引入 models\nconst models = require(\"../models\");\nmodule.exports = [\n  {\n    method: 'GET',\n    path: '/shops',\n    handler: async (request, reply) => {\n      // 通过 await 来异步查取数据\n      const result = await models.shops.findAll();\n      reply(result)\n    }\n  }\n]\n\n")])])]),t("h3",{attrs:{id:"_2-隐藏返回列表中不需要的字段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-隐藏返回列表中不需要的字段"}},[e._v("#")]),e._v(" 2. 隐藏返回列表中不需要的字段")]),e._v(" "),t("p",[e._v("很多时候，我们并不希望 findAll 来将数据表中的所有数据全都暴露出来，比如在查询用户列表时，用户的密码的值，便是特别敏感的数据。 我们可以在 findAll 中加入一个 "),t("code",[e._v("attributes")]),e._v(" 的约束，可以是一个要查询的属性（字段）列表，或者是一个 key 为 "),t("code",[e._v("include")]),e._v(" 或 "),t("code",[e._v("exclude")]),e._v(" 对象的键，比如对于用户表，"),t("code",[e._v("findAll({ attributes: { exclude: ['password'] } })")]),e._v("，就可以排除密码字段的查询露出。")]),e._v(" "),t("p",[e._v("在我们的店铺表中，我们希望有如下的字段露出：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nconst result = await models.shops.findAll({\n  attributes: [\n    'id', 'name'\n  ]\n});\n\n")])])]),t("h3",{attrs:{id:"_3-列表分页"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-列表分页"}},[e._v("#")]),e._v(" 3. 列表分页")]),e._v(" "),t("p",[e._v("当列表的数据开始增多，每次的列表展示数据，并不需要拉取全部，这时，我们需要为系统框架引入分页插件，hapi-pagination。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n# 安装适配 hapi v16 的 hapi-pagination\n$ npm i hapi-pagination@1\n\n")])])]),t("p",[e._v("在 plugins 目录下新增一个 hapi-pagination 的插件。options 的具体配置参数细节说明，参见 "),t("a",{attrs:{href:"https://github.com/fknop/hapi-pagination/tree/v1.6.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("hapi-pagination"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("考虑到，并非所有的接口都需要支持分页，所以，笔者建议对需要分页的相关接口，在 routes.include 配置中，逐条添加：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// plugins/hapi-pagination.js\nconst hapiPagination = require('hapi-pagination');\n\nconst options = {\n  query: {\n    // ... 此处篇幅考虑省略 query 入参配置代码，参看章节  github 案例\n  },\n  meta: {\n    name: 'meta',\n    // ... 此处篇幅考虑省略 meta 的相关配置代码，参看章节  github 案例\n  },\n  results: {\n    name: 'results'\n  },\n  reply: {\n    paginate: 'paginate'\n  },\n  routes: {\n    include: [\n      '/shops'  // 店铺列表支持分页特性\n    ],\n    exclude: []\n  }\n}\n\nmodule.exports = {\n  register: hapiPagination,\n  options: options,\n}\n\n")])])]),t("p",[e._v("在 app.js 中注册使用 hapi-pagination:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// app.js\nconst pluginHapiPagination = require('./plugins/hapi-pagination');\nawait server.register([\n  pluginHapiPagination,\n])\n\n\n")])])]),t("p",[e._v("为 GET /shops 的接口添加分页的入参校验，同时更新 Swagger 文档的入参契约。考虑到系统中未来会有不少接口需要做分页处理，我们在 utils/router-helper.js 中，增加一个公共的分页入参校验配置：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// utils/router-helper.js\nconst paginationDefine = {\n  limit: Joi.number().integer().min(1).default(10)\n    .description('每页的条目数'),\n  page: Joi.number().integer().min(1).default(1)\n    .description('页码数'),\n  pagination: Joi.boolean().description('是否开启分页，默认为true'),\n}\n\nmodule.exports = { paginationDefine }\n\n")])])]),t("p",[e._v("最终，回到 router/shops.js，实现最后的分页配置逻辑。考虑到分页的查询功能除了拉取列表外，还要获取总条目数，Sequelize 为我们提供了 "),t("code",[e._v("findAndCountAll")]),e._v(" 的 API，来为分页查询提供更高效的封装实现，返回的列表与总条数会分别存放在 "),t("code",[e._v("rows")]),e._v(" 与 "),t("code",[e._v("count")]),e._v(" 字段的对象中。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const { paginationDefine } = require('../utils/router-helper');\n// ...省略上下文\n{\n  method: 'GET',\n  path: `/${GROUP_NAME}`,\n  handler: async (request, reply) => {\n    const { rows: results, count: totalCount } = await models.shops.findAndCountAll({\n      attributes: [\n        'id',\n        'name',\n      ],\n      limit: request.query.limit,\n      offset: (request.query.page - 1) * request.query.limit,\n    });\n    // 开启分页的插件，返回的数据结构里，需要带上 result 与 totalCount 两个字段\n    reply({ results, totalCount });\n  },\n  config: {\n    tags: ['api', GROUP_NAME],\n    auth: false,\n    description: '获取店铺列表',\n    validate: {\n      query: {\n        ...paginationDefine\n      }\n    }\n  }\n}\n// ...省略上下文\n\n\n")])])]),t("p",[e._v("通过 Swagger 文档工具 "),t("a",{attrs:{href:"http://localhost:3000/documentation",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://localhost:3000/documentation"),t("OutboundLink")],1),e._v(" 查看店铺列表的接口调用返回数据，结果应该和下图相仿：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/19/165528f7aa0b42c3?w=1482&h=1774&f=jpeg&s=317342",alt:""}})]),e._v(" "),t("h2",{attrs:{id:"实现获取单个店铺的商品列表接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现获取单个店铺的商品列表接口"}},[e._v("#")]),e._v(" 实现获取单个店铺的商品列表接口")]),e._v(" "),t("p",[e._v("根据传入的店铺 ID，查询特定店铺 ID 下的商品列表，此处使用到了 sequelize 的 where 条件查询。同时，我们为店铺商品列表也加入分页的特性。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n// router/shops.js\n\nconst models = require(\"../models\");\nmodule.exports = [\n  // ...省略上下文\n  {\n    method: 'GET',\n    path: `/${GROUP_NAME}/{shopId}/goods`,\n    handler: async (request, reply) => {\n      // 增加带有 where 的条件查询\n      const { rows: results, count: totalCount } = await models.goods.findAndCountAll({\n        // 基于 shop_id 的条件查询\n        where: {\n          shop_id: request.params.shopId,\n        },\n        attributes: [\n          'id',\n          'name',\n        ],\n        limit: request.query.limit,\n        offset: (request.query.page - 1) * request.query.limit,\n      });\n    },\n  }\n  // ...省略上下文\n]\n\n")])])]),t("p",[e._v("记得在 plugins/hapi-pagination.js 的 include 中加入 /shops/{shopId}/goods 的分页路由白名单。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// plugins/hapi-pagination.js\nconst options = {\n  // ...\n  routes: {\n    include: [\n      '/shops/goods',\n      '/shops/{shopId}/goods',\n    ],\n    exclude: []\n  }\n  // ...\n}\n\n\n")])])]),t("p",[e._v("更多关于 models 的操作请查看官方手册 "),t("a",{attrs:{href:"http://docs.sequelizejs.com/manual/tutorial/models-usage.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Model 使用"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("GitHub 参考代码 "),t("a",{attrs:{href:"https://github.com/yeshengfei/hapi-tutorial/tree/master/chapter8/hapi-tutorial-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("chapter8/hapi-tutorial-1"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),t("p",[e._v("关键词：Sequelize，Model定义，列表查询，分页")]),e._v(" "),t("p",[e._v("本小节，我们学习了如何使用 Sequelize 提供的数据库查询的方法，来获取列表数据。我们在大多数的使用场景下，都可以利用 Sequelize 简洁的函数式方法调用，避开直接拼写晦涩冗长的数据库查询语句，最终获取我们想要的业务数据查询结果。掌握 Sequelize 插件库，是 Node.js 下使用 MySQL 数据库的必修课。相关的使用手册文档，希望能经常温故而知新，掌握更多高级的使用技巧。")]),e._v(" "),t("p",[e._v("思考：我们发现实际的业务中，店铺的数量会很多，我们希望通过一些关键词的输入，来模糊查询匹配的店铺列表，路由该如何设计？Sequelize 该如何查询？")]),e._v(" "),t("p",[t("strong",[e._v("本小节参考代码汇总")])]),e._v(" "),t("p",[e._v("Sequelize 连接 MySQL 数据库 - Sequelize 具体细节： "),t("a",{attrs:{href:"http://docs.sequelizejs.com/manual/installation/usage.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("基础使用"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("实现店铺列表页接口 - 列表分页 - hapi-pagination 的 options 配置细节: "),t("a",{attrs:{href:"https://github.com/fknop/hapi-pagination/tree/v1.6.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("hapi-pagination"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("实现获取单个店铺的商品列表接口："),t("a",{attrs:{href:"https://github.com/yeshengfei/hapi-tutorial/tree/master/chapter8/hapi-tutorial-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("chapter8/hapi-tutorial-1"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("models 更多操作："),t("a",{attrs:{href:"http://docs.sequelizejs.com/manual/tutorial/models-usage.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Model 使用"),t("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=s.exports}}]);