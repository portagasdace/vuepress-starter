(window.webpackJsonp=window.webpackJsonp||[]).push([[344],{700:function(t,e,n){"use strict";n.r(e);var a=n(42),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"导读"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#导读"}},[t._v("#")]),t._v(" 导读")]),t._v(" "),n("p",[t._v("本节标题：「装修阶段」- 添加状态管理 redux")]),t._v(" "),n("p",[t._v("本节主旨：完善骨架模型，支持 redux 状态管理，重点关注如何实现数据同构")]),t._v(" "),n("p",[t._v("本节配套代码：")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-redux",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-redux"),n("OutboundLink")],1)]),t._v(" "),n("h1",{attrs:{id:"正文"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[t._v("#")]),t._v(" 正文")]),t._v(" "),n("p",[t._v("小册的内容进行到这里，本应用骨架的搭建已经接近尾声，整体上目前已经比较完善，可以用到实际项目开发中。")]),t._v(" "),n("p",[t._v("目前还缺少一个可选的能力 - 状态管理。")]),t._v(" "),n("p",[t._v("业内最有名的状态管理工具肯定是"),n("code",[t._v("redux")]),t._v("了，但实际上它并不是必须的，在实际项目中到底需不需要使用它，要根据自己的实际情况来定。")]),t._v(" "),n("p",[t._v("为了给我们实际场景中多一个选型，这一节我们将"),n("code",[t._v("redux")]),t._v("状态管理融入到我们的骨架中。")]),t._v(" "),n("h1",{attrs:{id:"redux-介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redux-介绍"}},[t._v("#")]),t._v(" redux 介绍")]),t._v(" "),n("p",[t._v("这里对"),n("code",[t._v("redux")]),t._v("做一个简单介绍，便于把大家带入主题。")]),t._v(" "),n("p",[t._v("在复杂应用中组件间的数据通信可能非常复杂，单纯通过层级关系进行数据传递会显得力不从心，难以维护。所以此时会使用"),n("code",[t._v("redux")]),t._v("来进行状态管理，或者其他的一些状态管理工具如"),n("code",[t._v("mobx")]),t._v("。")]),t._v(" "),n("p",[n("code",[t._v("redux")]),t._v("借鉴了函数式编程的思想，采用"),n("code",[t._v("Flux")]),t._v("单向数据流理念，将应用状态全局化、中心化，同时为实现对状态的管理封装了不同的方法，实现数据的顶层分发，并对我们的操作进行规范和约束。")]),t._v(" "),n("p",[t._v("可以参考下图来理解其理念。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/10/16f8f245788e6879?w=533&h=221&f=png&s=85971",alt:""}})]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/10/16f8f1cd4cc32e3c?w=600&h=132&f=png&s=11513",alt:""}})]),t._v(" "),n("p",[t._v("可能上面说的有点抽象，用人类的语言再说一下。")]),t._v(" "),n("p",[n("code",[t._v("redux")]),t._v(" 将应用的数据"),n("code",[t._v("state")]),t._v(",集中到一个地方来进行存储管理，而不需要再单独的在组件内维护状态，状态的更新只能通过"),n("code",[t._v("redux")]),t._v("提供的规范和"),n("code",[t._v("api")]),t._v("来进行处理.。不在需要我们来手动调用"),n("code",[t._v("setState")]),t._v("来更新组件，其内部已经帮我们完成。")]),t._v(" "),n("p",[t._v("下面用伪代码简单介绍"),n("code",[t._v("redux")]),t._v("各个部分，帮我们更进一步理解"),n("code",[t._v("redux")]),t._v("。")]),t._v(" "),n("ul",[n("li",[t._v("数据管理 - "),n("code",[t._v("Store")])])]),t._v(" "),n("p",[n("code",[t._v("Store")]),t._v(" 是"),n("code",[t._v("redux")]),t._v("唯一保存所有"),n("code",[t._v("state")]),t._v("的容器,包含应用的状态和逻辑。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//创建一个store\nconst store = createStore(reducer, defualtState);\n\n//获得 store内的状态\nconst state = Store.getState();\n\n")])])]),n("ul",[n("li",[t._v("数据源 - "),n("code",[t._v("Action")])])]),t._v(" "),n("p",[t._v("表示在客户端触发，用于更新状态的动作,同时包含具体的数据，它是一个纯声明的数据结构，不提供逻辑。")]),t._v(" "),n("p",[t._v("在执行状态更新之前都会先产生一个"),n("code",[t._v("action")]),t._v("对象,用于来获取具体的数据。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("{\n    type:'getList',\n    data:{\n        list:[1,2,3]\n    }\n}\n\n")])])]),n("ul",[n("li",[t._v("状态整合 - reducer")])]),t._v(" "),n("p",[n("code",[t._v("reducer")]),t._v("是一个纯函数，用于接收"),n("code",[t._v("action")]),t._v("，根据"),n("code",[t._v("action")]),t._v("的"),n("code",[t._v("type")]),t._v("和数据(data),来返回一个新的"),n("code",[t._v("state")]),t._v("。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function xxxReducer(state = {},action){\n    switch(action.type){\n        case 'ADD':\n            return {\n                ...state,\n                count:action.count\n            }\n    }\n}\n\n")])])]),n("p",[t._v("上面函数接收 "),n("code",[t._v("state")]),t._v(" 和 "),n("code",[t._v("action")]),t._v(" 两个参数, 其中 "),n("code",[t._v("state")]),t._v(" 为上一个状态，也就是发起 "),n("code",[t._v("action")]),t._v(" 时 "),n("code",[t._v("store")]),t._v("中的状态。")]),t._v(" "),n("p",[n("code",[t._v("action")]),t._v(" 为一个真实的对象，其中必须含有一个为 "),n("code",[t._v("type")]),t._v("的属性。"),n("code",[t._v("reducer")]),t._v(" 就是通过这个"),n("code",[t._v("action.type")]),t._v(" 进行判断，来返回不同的 "),n("code",[t._v("state")]),t._v("。")]),t._v(" "),n("ul",[n("li",[t._v("数据更新 - dispatch")])]),t._v(" "),n("p",[n("code",[t._v("dispatch")]),t._v("是"),n("code",[t._v("store")]),t._v("暴露出的一个方法，用于执行对"),n("code",[t._v("store")]),t._v("内数据的更新，它接收一个"),n("code",[t._v("action")]),t._v("对象，其内部会调用"),n("code",[t._v("reducer")]),t._v("来返回最新的状态，最后完成状态的更新。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("dispatch(action);//更新数据\n\nconst store  = store.getState();//获取最新数据\n\n\n")])])]),n("h1",{attrs:{id:"中间件和异步"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#中间件和异步"}},[t._v("#")]),t._v(" 中间件和异步")]),t._v(" "),n("p",[t._v("上面是"),n("code",[t._v("redux")]),t._v("的基本用法，但是还不够。因为实际中没有那么简单的项目，比如我要从接口获取数据怎么办。")]),t._v(" "),n("p",[t._v("咱们上面介绍的只是在同步情况下的处理，更新数据直接"),n("code",[t._v("dispath(action)")]),t._v("就可以。")]),t._v(" "),n("p",[t._v("为此"),n("code",[t._v("redux")]),t._v("提供了一套中间件机制，可以让我们在派发"),n("code",[t._v("action")]),t._v("和执行"),n("code",[t._v("reducer")]),t._v("之间，做一些操作，比如做一个异步操作（从接口中拿数据）。")]),t._v(" "),n("p",[n("code",[t._v("redux")]),t._v("本身提供了"),n("code",[t._v("appleMiddleware")]),t._v("方法来接入中间件。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const store = createStore(reducer, defualtState, applyMiddleware(..));\n\n")])])]),n("p",[t._v("这里提一个比较常用的中间件"),n("code",[t._v("redux-thunk")]),t._v("，包括我们下面的实践中也会用这个。")]),t._v(" "),n("h1",{attrs:{id:"react-redux"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-redux"}},[t._v("#")]),t._v(" "),n("code",[t._v("react-redux")])]),t._v(" "),n("p",[t._v("为了更加方便的使"),n("code",[t._v("redux")]),t._v("和"),n("code",[t._v("react")]),t._v("相结合，我们需要使用"),n("code",[t._v("react-redux")]),t._v("库。")]),t._v(" "),n("p",[t._v("该库把"),n("code",[t._v("react")]),t._v("和"),n("code",[t._v("redux")]),t._v("链接在一起，内部进行了极强的封装，不在需要我们手动调用"),n("code",[t._v("setState")]),t._v("进行数据更新,当我们执行"),n("code",[t._v("dipatch(action)")]),t._v("时会自动更新状态，同时重新渲染组件。")]),t._v(" "),n("p",[t._v("该库更细节的使用就不多说了，更详细的可以参考下官方的文档。")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://react-redux.js.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://react-redux.js.org/"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("下面我们来进行实践，在我们的"),n("code",[t._v("react ssr")]),t._v("应用骨架内接入"),n("code",[t._v("redux")]),t._v("。")]),t._v(" "),n("h1",{attrs:{id:"ssr-接入-redux"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ssr-接入-redux"}},[t._v("#")]),t._v(" ssr 接入 redux")]),t._v(" "),n("p",[t._v("使用"),n("code",[t._v("redux")]),t._v("进行状态管理，虽然并不是必须的，但是从使用层面来讲可以大大简化我们的代码，更方便后期的维护，代码结构更清晰。")]),t._v(" "),n("p",[t._v("如何接入呢？")]),t._v(" "),n("p",[t._v("其实和我们开发"),n("code",[t._v("SPA")]),t._v("应用的使用方式差不多，只是需要针对双端做一些调整。")]),t._v(" "),n("p",[n("strong",[t._v("下面我们在上一节代码基础上进行改造。")])]),t._v(" "),n("h2",{attrs:{id:"准备工作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#准备工作"}},[t._v("#")]),t._v(" 准备工作")]),t._v(" "),n("p",[t._v("安装基础库")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("npm i redux react-redux redux-thunk\n\n")])])]),n("h2",{attrs:{id:"创建-store"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建-store"}},[t._v("#")]),t._v(" 创建 store")]),t._v(" "),n("p",[t._v("状态都由"),n("code",[t._v("store")]),t._v("来进行管理和存储，所以首先要先有"),n("code",[t._v("store")]),t._v("。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// ./src/client/share/redux/store.js\n\nimport {createStore, applyMiddleware, combineReducers} from 'redux';\nimport thunk from 'redux-thunk';\nimport reducer from './reducer';\n\nexport default (defualtState={}) => {\n  return createStore(reducer, defualtState, applyMiddleware(thunk));\n}\n\n\n")])])]),n("p",[t._v("上面是一个同构方法，双端都会调用。由于"),n("code",[t._v("node")]),t._v("模块具有缓存机制，所以我们需要导出一个函数来每次都能返回最新的"),n("code",[t._v("store")]),t._v("。")]),t._v(" "),n("h2",{attrs:{id:"创建-reducer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建-reducer"}},[t._v("#")]),t._v(" 创建 reducer")]),t._v(" "),n("p",[t._v("该模块会对各个页面内的子"),n("code",[t._v("reducer")]),t._v("进行合并。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// ./src/client/share/redux/reducer.js\n\n//列表页面的子 reducer\nimport { reducer as listPage } from '../../client/pages/list/redux/index';\n\n//关于页面的子 reducer\nimport { reducer as aboutPage } from '../../client/pages/about/redux/index';\n\n//合并多个 reducer\nimport {combineReducers } from 'redux';\n\nexport default combineReducers({\n    listPage,\n    aboutPage\n});\n\n\n")])])]),n("h2",{attrs:{id:"客户端渲染"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#客户端渲染"}},[t._v("#")]),t._v(" 客户端渲染")]),t._v(" "),n("p",[t._v("首先要获得"),n("code",[t._v("sotre")]),t._v("对象，利用"),n("code",[t._v("Provider")]),t._v("组件可以使子组件从"),n("code",[t._v("context")]),t._v("上得到"),n("code",[t._v("store")]),t._v("。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// ./src/client/app/index.js\n\nimport { Provider } from 'react-redux';\nimport getStore from '../../share/redux/store';\n\nfunction renderDom(routeList,initialData) {\n        \n        const insertCss = (...styles) => {\n                const removeCss = styles.map(style => style._insertCss());//客户端执行，插入style\n                return () => removeCss.forEach(dispose => dispose());//组件卸载时 移除当前的 style 标签\n        }\n\n        //得到 store 对象\n        const store = getStore(initialData);\n        \n        //将store 放入全局，方便后期的使用\n        window.__STORE__ = store;\n        \n        //传递 store\n        ReactDom.hydrate(<Provider store={store}>\n        <BrowserRouter>\n            <StyleContext.Provider value={{ insertCss }}>\n            <App routeList={routeList} />\n            </StyleContext.Provider>\n        </BrowserRouter>\n        </Provider>,document.getElementById('root'))\n}\n\n//...\n\n")])])]),n("h2",{attrs:{id:"改造-列表页面"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#改造-列表页面"}},[t._v("#")]),t._v(" 改造 列表页面")]),t._v(" "),n("p",[t._v("下面拿我们项目中的列表页面举例,其路由为"),n("code",[t._v("/list")]),t._v("，同时模拟了异步数据的请求。")]),t._v(" "),n("h3",{attrs:{id:"创建-reducer-action"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建-reducer-action"}},[t._v("#")]),t._v(" 创建 reducer action")]),t._v(" "),n("p",[t._v("个人习惯吧，我没有把"),n("code",[t._v("actions")]),t._v(","),n("code",[t._v("reducer")]),t._v(","),n("code",[t._v("action type")]),t._v("分文件存在，而是合并到了一起，感觉用起来更方便一些。")]),t._v(" "),n("p",[t._v("在"),n("code",[t._v("pages/list")]),t._v("下面创建"),n("code",[t._v("redux/index.js")]),t._v("文件。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//假数据\nimport tempData from '../data';\n\n//action type\nexport const ACTION_TYPE={\n  changeList:'list/changelist'\n}\n\n//用于更新状态 action creater\nconst changeList = list => ({\n  type: ACTION_TYPE.changeList,\n  list\n});\n\n//异步获得数据 【副作用】 返回Promise类型\nexport const getInitialData = (props) => {\n  return (dispatch, getState) => {\n    return new Promise(resolve=>{\n    //延迟 500ms 返回数据\n      setTimeout(() => {\n        const data = {\n          fetchData: {\n            code: 0,\n            data: tempData\n          },\n          page: {\n            tdk: {\n              title: '列表页 - koa-react-ssr',\n              keywords: '关键词 koa-react-ssr',\n              description: '描述 koa-react-ssr'\n            }\n          }\n        }\n        resolve(data);\n        //更新状态\n        dispatch(changeList(data));\n      }, 500);\n    })\n  };\n};\n\n\n//默认数据\nconst defaultState = {\n  fetchData:{},\n  page:{}\n};\n\n// reducer 返回一个全新状态\nexport const reducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case ACTION_TYPE.changeList:\n      return {//通过共享结构返回一个新对象\n        ...state,\n        ...action.list\n      };\n    default:\n      return state;//返回默认\n  }\n}\n\n\n")])])]),n("h3",{attrs:{id:"页面组件改造"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#页面组件改造"}},[t._v("#")]),t._v(" 页面组件改造")]),t._v(" "),n("p",[t._v("我们使用"),n("code",[t._v("connect")]),t._v("方法将组件和"),n("code",[t._v("redux")]),t._v("进行链接，以支持组件的状态传递和组件的自动更新。")]),t._v(" "),n("p",[t._v("另外需要对"),n("code",[t._v("数据预取")]),t._v("方法进行更改，不再是直接调用接口返回数据，而是使用"),n("code",[t._v("dispatch")]),t._v("。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//src/client/pages/list/index.js\n//列表页 组件\n\nimport React from 'react';\nimport {Link} from 'react-router-dom';\nimport css from './list.scss';\n\n//action  获取初始化数据\nimport {getInitialData} from './redux/index';\n\n//为了方便使用，封装的一个方法，下面会介绍\nimport isoConnect from '../../common/components/iso-connect';\n\nclass Index extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n\n    //数据预取方法 用于服务端调用 参数内可以获得store \n    static async  getInitialProps({store}) {\n        //通过 dispach 获得数据,同时也会更新store\n        return store.dispatch(getInitialData());\n    }\n\n    render() {\n        //渲染数据 这里不变\n        const {fetchData,page} = this.props.initialData;\n        const { code, data } = fetchData||{};\n        \n        return <div className=\"list-page-box\">\n        {data && data.map((item,index)=>{\n            return <div key={index}>\n                <h3>{item.title}</h3>\n                <p>{item.desc}</p>\n            </div>\n        })}\n        {!data&&<div>暂无数据</div>}\n        </div>\n    }\n}\n\n//将 store 中 state 转换为 props传递给组件\nconst mapStateToProps = state => ({\n    initialData: state.listPage,\n});\n\n//将获取数据的方法也做为 props传递给组件\nconst mapDispatchToProps = dispatch => ({\n    getInitialData() {\n        console.log('dispath fetch data');\n        return dispatch(getInitialData());\n    }\n});\n\n// 封装了一层，为了方便，下面有介绍\nexport default isoConnect({\n    css,\n    mapStateToProps,\n    mapDispatchToProps},Index);\n\n\n\n")])])]),n("p",[n("strong",[t._v("isoConnect 方法")])]),t._v(" "),n("p",[t._v("由于我们的页面组件内需要做 "),n("code",[t._v("css")]),t._v("同构，需要调用"),n("code",[t._v("PageContainer")]),t._v("高阶组件（提取了组件内的重复逻辑）,现在又需要调用"),n("code",[t._v("connect")]),t._v("方法， 这样一层又一层的写法很繁琐，所以为了方便使用，需要做一层封装，提取了一个"),n("code",[t._v("isoConnect")]),t._v("方法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import PageContainer from '../page-container/index';\nimport { connect } from 'react-redux';\nimport withStyles from 'isomorphic-style-loader/withStyles'\n\nexport default ({ css, mapStateToProps, mapDispatchToProps }, ActiveComponet)=>{\n    return withStyles(css)\n        (connect(mapStateToProps, mapDispatchToProps)(PageContainer(ActiveComponet)));\n}\n\n")])])]),n("h3",{attrs:{id:"高阶组件改造"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件改造"}},[t._v("#")]),t._v(" 高阶组件改造")]),t._v(" "),n("p",[t._v("需要对我们的"),n("code",[t._v("PageContainer")]),t._v("组件进行改造，主要是数据预取和数据初始化的处理,同时兼容不使用"),n("code",[t._v("redux")]),t._v("的页面。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// ./src/client/common/comoponents/page-container\n//高阶组件 用于提取重复逻辑\n\nimport React from 'react';\n\nlet _this = null;\n\nconst popStateCallback = () => {\n    // 使用popStateFn保存函数防止addEventListener重复注册\n    if (_this && _this.getInitialProps) {\n        console.log('popStateFn');\n        _this.getInitialProps();\n    }\n};\n\nexport default (SourceComponent) => {\n    return class HoComponent extends React.Component {\n        constructor(props, context) {\n            super(props);\n            console.log('props', props);\n            this.state = {\n                initialData: {},\n                canClientFetch: false//浏览器端是否需要请求数据\n            }\n        }\n\n        //转接子组件的预取方法，服务端会调用这个方法来做数据预取\n        static async getInitialProps(ctx) {\n            return SourceComponent.getInitialProps ? await SourceComponent.getInitialProps(ctx) : {};\n        }\n\n        //用于封装处理数据的更新逻辑\n        async getInitialProps() {\n            // ssr首次进入页面以及csr/ssr切换路由时才调用组件的getInitialProps方法\n            const props = this.props;\n            const store = window.__STORE__;//从全局得到 store \n            \n            //兼容不使用 redux 的页面\n            const res = props.getInitialData ? await props.getInitialData(store.dispatch) : (\n                SourceComponent.getInitialProps? await SourceComponent.getInitialProps():{}\n            );\n            \n            //处理页面 title 显示\n            let { tdk } = res.page || {};\n            if (tdk) {\n                document.title = tdk.title;\n            }\n        }\n\n        async componentDidMount() {\n\n            _this = this; // 修正_this指向，保证_this指向当前渲染的页面组件\n            //注册事件，用于在页面回退的时候触发\n            window.addEventListener('popstate', popStateCallback);\n\n            const canClientFetch = this.props.history && this.props.history.action === 'PUSH';//路由跳转的时候可以异步请求数据\n            if (canClientFetch) {\n                //如果是 history PUSH 操作 则更新数据\n                await this.getInitialProps();\n            }\n\n        }\n\n        render() {\n            const props = {\n                initialData: {},\n                ...this.props\n            };\n\n            //客户端渲染\n            if (this.state.canClientFetch) {//需要异步请求数据\n                props.initialData = this.state.initialData || {};\n            } else {\n                props.initialData = this.props.initialData;\n            }\n\n            return <SourceComponent  {...props}></SourceComponent>\n        }\n    }\n}\n\n")])])]),n("h2",{attrs:{id:"服务端渲染"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染"}},[t._v("#")]),t._v(" 服务端渲染")]),t._v(" "),n("p",[t._v("只需要对"),n("code",[t._v("react-ssr.js")]),t._v("中间件做调整，导入"),n("code",[t._v("Provider")]),t._v("组件，得到"),n("code",[t._v("store")]),t._v("对象。")]),t._v(" "),n("p",[t._v("这里需要注意一点，调用数据预取方法后，"),n("code",[t._v("store")]),t._v("内的"),n("code",[t._v("state")]),t._v("会自动更新，组件在渲染的时候会自动获取，不在需要显示的通过"),n("code",[t._v("staticContext")]),t._v("属性进行传递。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 服务端 ssr 中间件\n// ./src/server/middlewares/react-ssr.js\n\n//...\nimport { Provider } from "react-redux";\nimport getStore from \'../../share/redux/store\';\n\n\nexport default async (ctx, next) => {\n\n   //...\n\n    //获得静态路由\n    const staticRoutesList = await getStaticRoutes(routeList);\n\n\n    //查找到的目标路由对象\n    let matchResult = await matchRoute(path, staticRoutesList);\n    let { targetRoute, targetMatch } = matchResult;\n\n    //得到 store,默认没有数据\n    const store = getStore();\n\n    //进行数据预取，更新 store 内的数据\n    let fetchDataFn,fetchResult={};\n    if (targetRoute){\n        fetchDataFn = targetRoute.component ?targetRoute.component.getInitialProps:null;\n        if (fetchDataFn) {\n            fetchResult = await fetchDataFn({store});//更新 state \n        }\n    }\n    \n    //从数据预取的结果中得到 page 信息\n    let { page } = fetchResult || {};\n\n    let tdk = {\n        title: \'默认标题 - koa+react+ssr\',\n        keywords: \'默认关键词\',\n        description: \'默认描述\'\n    };\n\n    if (page && page.tdk) {\n        tdk = page.tdk;\n    }\n\n    const context = {};\n    const css = new Set();\n    //css  同构\n    React components\n    const insertCss = (...styles) => styles.forEach(style => css.add(style._getContent()));\n   \n    //使用 Provider 传递 store\n    const html = renderToString(<Provider store={store}><StaticRouter location={path} context={context}>\n        <StyleContext.Provider value={{ insertCss }} >\n            <App routeList={staticRoutesList}></App></StyleContext.Provider>\n    </StaticRouter></Provider>);\n\n    const styles = [];\n    [...css].forEach(item => {\n        let [mid, content] = item[0];\n        styles.push(`<style id="s${mid}-0">${content}</style>`)\n    });\n\n    //静态资源\n    const assetsMap = getAssets();\n\n    ctx.body = `<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>${tdk.title}</title>\n    <meta name="keywords" content="${tdk.keywords}" />\n    <meta name="description" content="${tdk.description}" />\n    ${styles.join(\'\')}\n</head>\n<body>\n    <div id="root">\n       ${html}\n    </div>\n    <textarea id="ssrTextInitData" style="display:none;">\n    //获得store 然后序列化直出到客户端\n    ${JSON.stringify(store.getState())}\n    </textarea>\n</body>\n</html>\n</body>\n ${assetsMap.js.join(\'\')}\n`;\n\n    await next();\n}\n\n')])])]),n("p",[t._v("代码层面改造已完成，下面看下具体展示")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/10/16f8fabfa1f6b985?w=814&h=936&f=png&s=225535",alt:""}})]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/10/16f8faf4a7488ce5?w=946&h=957&f=png&s=807252",alt:""}})]),t._v(" "),n("h1",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),n("p",[t._v("本节我们完成了同构应用内的"),n("code",[t._v("redux")]),t._v("的接入，让我们的应用骨架更加的完善。")]),t._v(" "),n("p",[t._v("从本次改造中可以看出大部分还是我们平时"),n("code",[t._v("SPA")]),t._v("开发中的应用，最主要的部分还是"),n("code",[t._v("数据预取")]),t._v("，考查的是我们的对同构的理解。只要你熟悉"),n("code",[t._v("redux")]),t._v("的应用，那么在搞明白数据同构之后，相信你也能较快的接入"),n("code",[t._v("redux")]),t._v("。")]),t._v(" "),n("p",[t._v("改造的方案很多，但是其中原理和流程都是相同的，所以我们也可以迅速的集成"),n("code",[t._v("mobx")]),t._v("。")]),t._v(" "),n("p",[t._v("本节完整代码已上传")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-redux",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-redux"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("感谢你的阅读。")]),t._v(" "),n("p",[t._v("如果有问题欢迎留言，也欢迎在留言区留下你的想法和思考。")])])}),[],!1,null,null,null);e.default=r.exports}}]);