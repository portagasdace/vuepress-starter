(window.webpackJsonp=window.webpackJsonp||[]).push([[336],{690:function(n,a,t){"use strict";t.r(a);var e=t(42),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("blockquote",[t("p",[n._v("本节代码对应 GitHub 分支: chapter3")])]),n._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/sanyuan0704/react-cloud-music/tree/chapter3",target:"_blank",rel:"noopener noreferrer"}},[n._v("仓库传送门"),t("OutboundLink")],1)]),n._v(" "),t("h2",{attrs:{id:"图片懒加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图片懒加载"}},[n._v("#")]),n._v(" 图片懒加载")]),n._v(" "),t("p",[n._v("在大量图片加载的情况下，会造成页面空白甚至卡顿，然而我们的视口就这么大，因此只需要让视口内的图片显示即可，同时图片未显示的时候给它一个默认的 src，让一张非常精简的图片占位。这就是图片懒加载的原理。当然，在本项目中，我们采取一个成熟的方案 react-lazyload 库，易上手，效果不错。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("npm install react-lazyload --save\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//components/list.js\n// 引入\nimport LazyLoad from "react-lazyload";\n\n//img 标签外部包裹一层 LazyLoad\n<LazyLoad placeholder={<img width="100%" height="100%" src={require (\'./music.png\')} alt="music"/>}>\n  <img src={item.picUrl + "?param=300x300"} width="100%" height="100%" alt="music"/>\n</LazyLoad>\n\n')])])]),t("p",[n._v("至于默认的占位图片，大家可以去相应分支去拿。")]),n._v(" "),t("p",[n._v("现在我们做到了视口内的图片显示真实资源，视口外则显示占位图片，那么当我们滑动的时候，如何让下面相应的图片显示呢？")]),n._v(" "),t("p",[n._v("其实也相当简单，在 Recommend/index.js 中:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 引入 forceCheck 方法\nimport { forceCheck } from 'react-lazyload';\n\n//scroll 组件中应用这个方法\n<Scroll className=\"list\" onScroll={forceCheck}>\n...\n\n")])])]),t("p",[n._v("这样随着页面滑动，下面的图片会依次显示，没有任何问题。")]),n._v(" "),t("h2",{attrs:{id:"进场-loading-效果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进场-loading-效果"}},[n._v("#")]),n._v(" 进场 loading 效果")]),n._v(" "),t("p",[n._v("Ajax 请求往往需要一定的时间，在这个时间内，页面会处于没有数据的状态，也就是空白状态，但是用户点击来的时候看见一片空白的时候心里是非常焦灼的，尤其是 Ajax 的请求时间长达几秒的时候，而 loading 效果便能减缓这种焦急的情绪，并且如果 loading 动画做的漂亮，还能够让人赏心悦目，让用户对 App 产生好感。")]),n._v(" "),t("p",[n._v("loading 的重要性不言而喻。因此，我也是这花费了不少力气，折腾出了几个版本的 loading 效果。这里先来写第一版。")]),n._v(" "),t("p",[n._v("主要是利用了 CSS3 的 animation-delay 特性，让两个圆交错变化，产生一个涟漪的效果。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import React from 'react';\nimport styled, { keyframes } from'styled-components';\nimport style from '../../assets/global-style';\n\nconst loading = keyframes`\n  0%, 100% {\n    transform: scale(0.0);\n  }\n  50% {\n    transform: scale(1.0);\n  }\n`\nconst LoadingWrapper = styled.div`\n  >div {\n    position: fixed;\n    z-index: 1000;\n    left: 0; \n    right: 0;  \n    top: 0;\n    bottom: 0;\n    margin: auto;\n    width: 60px;\n    height: 60px;\n    opacity: 0.6;\n    border-radius: 50%;\n    background-color: ${style [\"theme-color\"]};\n    animation: ${loading} 1.4s infinite ease-in;\n  }\n  >div:nth-child (2) {\n    animation-delay: -0.7s;\n  }\n`\n\nfunction Loading ()  {\n  return (\n    <LoadingWrapper>\n      <div></div>\n      <div></div>\n    </LoadingWrapper>\n  );\n}\n \nexport default React.memo (Loading);\n\n")])])]),t("p",[n._v("现在在 Recommend 组件中引入")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import Loading from '../../baseUI/loading/index';\n\n// 在返回的 JSX 代码中\n<Content>\n  ...\n  <Loading></Loading>\n<Content>\n\n")])])]),t("p",[n._v("现在你可以看到屏幕中间的 loading。接下来添加 Loading 的控制逻辑。")]),n._v(" "),t("p",[n._v("由于数据是异步获取，异步逻辑全在 redux-thunk 中执行，且 loading 和数据之间是一个联动的关系，因此 loading 的状态应放在 redux 管理。")]),n._v(" "),t("ol",[t("li",[n._v("首先，在 Recommend/store 下的 reducer.js 中:")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//reducer.js\nconst defaultState = fromJS ({\n  ...\n  enterLoading: true\n});\n\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[n._v("添加 action 的 type 值常量")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//constants.js\n...\nexport const CHANGE_ENTER_LOADING = 'recommend/CHANGE_ENTER_LOADING';\n\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[n._v("添加 reducer 的逻辑:")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export default (state = defaultState, action) => {\n  switch (action.type) {\n    ...\n    case actionTypes.CHANGE_ENTER_LOADING:\n      return state.set ('enterLoading', action.data);\n    default:\n      return state;\n  }\n}\n\n")])])]),t("ol",{attrs:{start:"4"}},[t("li",[n._v("然后编写 action：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//actionCreators.js\n...\nexport const changeEnterLoading = (data) => ({\n  type: actionTypes.CHANGE_ENTER_LOADING,\n  data\n});\n// 另外在获取推荐歌单后，应把 loading 状态改为 false\nexport const getRecommendList = () => {\n  return (dispatch) => {\n    getRecommendListRequest ().then (data => {\n      dispatch (changeRecommendList (data.result));\n      dispatch (changeEnterLoading (false));// 改变 loading\n    }).catch (() => {\n      console.log ("推荐歌单数据传输错误");\n    });\n  }\n};\n\n')])])]),t("p",[n._v("接下来在组件中应用这个 enterLoading:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//recommend/index.js\nconst mapStateToProps = (state) => ({\n  ...\n  enterLoading: state.getIn (['recommend', 'enterLoading'])\n});\n// 返回的 JSX 代码中应用它\n<Content>\n  ...\n  { enterLoading ? <Loading></Loading> : null }\n<Content>\n\n")])])]),t("p",[n._v("这样 Loading 效果就正常显示啦！")]),n._v(" "),t("h2",{attrs:{id:"redux-数据缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redux-数据缓存"}},[n._v("#")]),n._v(" Redux 数据缓存")]),n._v(" "),t("p",[n._v("问题：其实还有一个细节需要我们来优化，就是你现在切换到歌手页面，然后切回到推荐页，你在浏览器的 Network 中会看到又发了两次网络请求，而这两次请求是完全没有必要的，纯属浪费性能。")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/18/16dddf168d7a60bc?w=909&h=168&f=jpeg&s=29010",alt:""}})]),n._v(" "),t("p",[n._v("那如何来优化呢？根据我们这个项目的特点，利用 Redux 的数据来进行页面缓存成本最低，是不二之选。")]),n._v(" "),t("p",[n._v("其实操作起来也是非常简单的，只需要做一些小小的改动：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//Recommend/index.js\nuseEffect (() => {\n  // 如果页面有数据，则不发请求\n  //immutable 数据结构中长度属性 size\n  if (!bannerList.size){\n    getBannerDataDispatch ();\n  }\n  if (!recommendList.size){\n    getRecommendListDataDispatch ();\n  }\n}, []);\n\n")])])]),t("p",[n._v("这下，我切换到歌手页，再切回来，果然就不会多发请求啦！")]),n._v(" "),t("p",[n._v("恭喜你，现在已经完成了推荐模块的内容，是不是相当有成就感呢？后面还有更多有挑战的事情等着你呢，加油！")])])}),[],!1,null,null,null);a.default=s.exports}}]);