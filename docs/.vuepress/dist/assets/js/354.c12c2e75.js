(window.webpackJsonp=window.webpackJsonp||[]).push([[354],{710:function(t,e,r){"use strict";r.r(e);var n=r(42),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"导读"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#导读"}},[t._v("#")]),t._v(" 导读")]),t._v(" "),r("p",[t._v("本节标题：「建造毛坯」- 双端路由同构")]),t._v(" "),r("p",[t._v("本节主旨： 继续以发现问题，分析问题，解决问题的思路，来实现多路由的双端同构，重点在于服务端和客户端如何处理")]),t._v(" "),r("p",[t._v("本节配套代码：")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr2",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr2"),r("OutboundLink")],1)]),t._v(" "),r("h1",{attrs:{id:"正文"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[t._v("#")]),t._v(" 正文")]),t._v(" "),r("p",[t._v("前面几节我们实现了一个最基础的 "),r("code",[t._v("react ssr")]),t._v("，同时也初步接触了同构，双端渲染同一个组件，服务端直出 "),r("code",[t._v("html")]),t._v(" 结构，浏览器端也能够实现组件事件的绑定。")]),t._v(" "),r("p",[t._v("然后又对应用骨架的开发体验做了一次重要的升级。")]),t._v(" "),r("h1",{attrs:{id:"引出问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引出问题"}},[t._v("#")]),t._v(" 引出问题")]),t._v(" "),r("p",[t._v("虽然我们能展示页面并且执行事件，但我们还缺一个非常重要的能力。")]),t._v(" "),r("p",[t._v("那就是路由！")]),t._v(" "),r("p",[t._v("现在我们只有一个路由，属于服务端的根路由 "),r("code",[t._v("/")]),t._v(" 。")]),t._v(" "),r("p",[t._v("我们无论怎么在浏览器内改变路由地址都会显示同一个"),r("code",[t._v("UI")]),t._v("。")]),t._v(" "),r("p",[t._v("当然我们的项目不可能只有一个页面，那我们该怎样来处理和维护项目的路由呢？")]),t._v(" "),r("h1",{attrs:{id:"路由同构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路由同构"}},[t._v("#")]),t._v(" 路由同构")]),t._v(" "),r("p",[t._v("由于我们打造的是基于服务端渲染的"),r("code",[t._v("React SPA")]),t._v("应用开发骨架，所以服务端和客户端都需要对路由进行处理。")]),t._v(" "),r("p",[t._v("我们使用的是"),r("code",[t._v("React")]),t._v(",那前端路由肯定会使用"),r("code",[t._v("react-router")]),t._v("来处理。")]),t._v(" "),r("p",[t._v("那服务端呢？服务端也需要单独维护一套路由？")]),t._v(" "),r("p",[t._v("当然不需要，这样不科学，更不合理。")]),t._v(" "),r("p",[t._v("在前几节我们初步接触了同构，现在解决这个问题的办法还是同构 - "),r("code",[t._v("路由同构")]),t._v("，经过同构后服务端和客户端可以使用同一套路由。")]),t._v(" "),r("h2",{attrs:{id:"同构思路与实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同构思路与实现"}},[t._v("#")]),t._v(" 同构思路与实现")]),t._v(" "),r("p",[t._v("先整体说下实现思路,让大家先有个基本的了解。")]),t._v(" "),r("p",[t._v("当第一请求页面的时候，服务端接收请求，根据当前的"),r("code",[t._v("path")]),t._v("来查找具体的路由，然后根据路由得到具体的组件，然后将组件直出。")]),t._v(" "),r("p",[t._v("服务端直出后，页面由浏览器接管，后面的渲染执行就交给前端代码了。")]),t._v(" "),r("p",[t._v("思路很简单，接下来看下具体的实现和代码。")]),t._v(" "),r("p",[r("strong",[t._v("创建一个客户端路由配置")])]),t._v(" "),r("p",[t._v("从"),r("code",[t._v("react router4")]),t._v("开始，"),r("code",[t._v("react")]),t._v("对路由做了重大的升级，将组件化的思想贯彻到底 - 一切皆组件。")]),t._v(" "),r("p",[t._v("所以从"),r("code",[t._v("v4")]),t._v("版本开始不再是集中式路由配置，路由也是组件，也可以和 "),r("code",[t._v("UI")]),t._v(" 写在一起。")]),t._v(" "),r("p",[t._v("当然你仍然可以使用集中式的路由配置方式。")]),t._v(" "),r("p",[t._v("新增一个"),r("code",[t._v("Layout")]),t._v("组件作为页面公共组件，在这个组件内进行路由渲染,当然也可以不用，这里也是为了让每个页面都有公共部分，无需每重复渲染。")]),t._v(" "),r("p",[t._v("具体用不用看自身的业务即可。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// ./src/client/app/layout.js\n\nimport React from 'react';\nimport { Link } from 'react-router-dom';\nexport default class Index extends React.Component{\nconstructor(props){\n super(props);\n}\nrender(){\nreturn  <div>\n    <Link to=\"/index\">首页</Link>  <Link to=\"/artice\">列表页</Link>\n    <div>{this.props.children}</div>\n    </div>\n}\n}\n\n")])])]),r("p",[r("strong",[t._v("配置路由")])]),t._v(" "),r("p",[t._v("顺便简单介绍几个"),r("code",[t._v("react router4")]),t._v("的路由组件 "),r("code",[t._v("Route, Switch, BrowserRouter")])]),t._v(" "),r("p",[r("code",[t._v("Route 组件")])]),t._v(" "),r("p",[t._v("用于绑定组件和"),r("code",[t._v("path")]),t._v("的关系,一般使用"),r("code",[t._v("component")]),t._v("属性指定要渲染的组件,其中"),r("code",[t._v("exact")]),t._v("属性表示是否是精确匹配模式，默认是"),r("code",[t._v("false")]),t._v("。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v(' <Route path="/index"  exact={true} component={Index}></Route>\n\n')])])]),r("p",[r("code",[t._v("Switch 组件")])]),t._v(" "),r("p",[t._v("使用该组件只会渲染第一个匹配到的路由，否则所有的路由都会渲染。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('  <Switch>\n      <Route path="/"  exact={true} component={Root}></Route>\n      <Route path="/list" exact={true} component={List}></Route>\n  </Switch>\n\n')])])]),r("p",[r("code",[t._v("BrowserRouter 组件")])]),t._v(" "),r("p",[t._v("此组件相信大家都熟悉，基于浏览器 "),r("code",[t._v("History api")]),t._v(" 来达到浏览器地址和 "),r("code",[t._v("UI")]),t._v(" 同步的能力。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('<BrowserRouter>\n    <Switch>\n        <Route path="/root"  exact={true} component={Root}></Route>\n        <Route path="/list" exact={true} component={List}></Route>\n    </Switch>\n</BrowserRouter>\n\n')])])]),r("p",[r("strong",[t._v("来看下完整的路由配置")])]),t._v(" "),r("p",[t._v("提取为独立的模块，方便维护和管理。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// ./src/client/router/route-config.js\n//路由配置文件\n\nimport Index from '../pages/index';\nimport List from '../pages/list';\n\nexport default [\n    {\n        path:'/index',\n        component:Index,\n        exact: true //是否精确匹配\n    },\n    {\n        path: '/list',\n        component: List,\n        exact: true,\n    }\n]\n\n\n")])])]),r("p",[r("strong",[t._v("路由渲染入口配置")])]),t._v(" "),r("p",[t._v("遍历路由配置")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// src/client/router/indxex.js\n//路由配置文件\n\nimport Layout from '../app/layout';\nimport React  from 'react';\nimport { Route, Switch } from 'react-router-dom';\n\n//服务端也会用到所以通过参数的方式将配置传递进来\nfunction App({routeList}) {\n    return (\n        <Layout> //公共组件\n            <Switch>\n                {\n                    routeList.map(item=>{\n                            return <Route key={item.path} {...item}></Route>\n                    })\n                }\n            </Switch>\n        </Layout>\n    );\n}\n\nexport default App;\n\n\n")])])]),r("p",[r("strong",[t._v("调整客户端组件渲染的入口代码")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("//client/app/index.js\n//浏览器端页面结构渲染入口\n\nimport React from 'react';\nimport ReactDom from 'react-dom';\nimport { BrowserRouter} from 'react-router-dom';\nimport App from '../router/index';\nimport routeList from '../router/route-config';//路由配置\n\n\n//渲染入口\nReactDom.hydrate(\n   - <Index>\n   + <BrowserRouter>\n        <App routeList={routeList} />\n   </BrowserRouter>//改成路由组件\n, document.getElementById('root'))\n\n\n")])])]),r("p",[t._v("到这里，客户端路由已生效，路由改变同时能够渲对应的组件。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/12/30/16f56eb3292a57c0?w=500&h=375&f=png&s=19009",alt:""}})]),t._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/12/30/16f56eb7840ab331?w=500&h=375&f=png&s=19308",alt:""}})]),t._v(" "),r("p",[r("strong",[t._v("现在客户端路由基本上已经配置好，服务端该如何处理？")])]),t._v(" "),r("p",[r("strong",[t._v("服务端路由处理")])]),t._v(" "),r("p",[t._v("按照我们上面的思路，根据请求的 "),r("code",[t._v("path")]),t._v("，去路由配置里查找对应的组件，得到匹配的组件后，服务端完成组件直出。")]),t._v(" "),r("p",[t._v("上面的思路没什么问题，不过"),r("code",[t._v("v4")]),t._v("中 已经为我们提供了相关的组件来完成服务端的渲染。")]),t._v(" "),r("p",[r("code",[t._v("StaticRouter")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("import { StaticRouter} from 'react-router';\n\n")])])]),r("p",[t._v("该组件主要用于服务端渲染，可以帮助我们完成路由查找功能,无需再做手动匹配。")]),t._v(" "),r("p",[t._v("基本的思路是，将替换为无状态的。")]),t._v(" "),r("p",[t._v("将服务器上接收到的"),r("code",[t._v("path")]),t._v("传递给此组件用来匹配，同时支持传入"),r("code",[t._v("context")]),t._v("特性,此组件会自动匹配到目标组件进行渲染。")]),t._v(" "),r("p",[r("code",[t._v("context")]),t._v("属性是一个普通的"),r("code",[t._v("JavaScript")]),t._v("对象。")]),t._v(" "),r("p",[t._v("在组件渲染时，可向该对象添加属性以存储有关渲染的信息，比如"),r("code",[t._v("302 404")]),t._v("等结果状态，然后服务端可以针对不同的状态进行具体的响应处理。")]),t._v(" "),r("p",[t._v("对比来看")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("//客户端\n<BrowserRouter>\n      <App/>\n</BrowserRouter>\n     \n// 服务端\n<StaticRouter location={req.url} context={context}>   \n        <App/>\n</StaticRouter>\n\n")])])]),r("p",[r("strong",[t._v("服务端渲染处理")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("//引入客户端路由组件\n//...\nimport React from 'react';\nimport { renderToString } from 'react-dom/server';\nimport { StaticRouter, Route} from 'react-router';\nimport App from '../../client/router/index';\nimport routeList from '../../client/router/route-config';\n\n\nexport default  (ctx,next)=>{\n    \n    //获得请求的 path\n    const path = ctx.request.path;\n    \n    //渲染组件为 html 字符串\n    const html = renderToString(<StaticRouter location={path}>\n          <App routeList={routeList}></App>\n    </StaticRouter>);\n    ctx.body=`<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>my react ssr</title>\n</head>\n<body>\n    <div id=\"root\">\n       ${html}\n    </div>\n</body>\n</html>\n</body>\n<script type=\"text/javascript\"  src=\"index.js\"><\/script>\n`;\n\n    return next();\n}\n\n")])])]),r("p",[t._v("到这里我们已经实现了基本的双端路的同构，是不是很简单呢。^_^")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/12/30/16f56f6c03bd5447?w=863&h=375&f=png&s=83817",alt:""}})]),t._v(" "),r("h2",{attrs:{id:"小结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),r("p",[t._v("本节主要是了解和实现 "),r("code",[t._v("路由同构")]),t._v("，整体来说比较简单，不过这也只是小试牛刀哦，后面还会更精彩。")]),t._v(" "),r("p",[t._v("本节代码已上传")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr2",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr2"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("感谢你的阅读。")]),t._v(" "),r("p",[t._v("如果有问题欢迎留言，也欢迎在留言区留下你的想法和思考。")])])}),[],!1,null,null,null);e.default=a.exports}}]);