(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{367:function(t,n,e){"use strict";e.r(n);var v=e(42),_=Object(v.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("结束了针对栈结构的定点轰炸，我们现在开始要缓缓过渡到队列的世界了。")]),t._v(" "),e("p",[t._v("关于队列，在算法面试中大家需要掌握以下重点：")]),t._v(" "),e("ol",[e("li",[t._v("栈向队列的转化")]),t._v(" "),e("li",[t._v("双端队列")]),t._v(" "),e("li",[t._v("优先队列")])]),t._v(" "),e("p",[t._v("以上考点中，1 属于基础难度， 2 对一部分同学来说已经有点吃力，3 的区分度最高——优先队列属于高级数据结构，其本质是二叉堆结构，考虑到相关题目具有较强的综合性，我们把它放在小册二叉树和堆相关的专题来展开。在本节，我们集中火力向前两个命题点开炮。")]),t._v(" "),e("h2",{attrs:{id:"为什么一道题可以成为高频面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么一道题可以成为高频面试题"}},[t._v("#")]),t._v(" 为什么一道题可以成为高频面试题")]),t._v(" "),e("p",[t._v("如何用栈实现队列？这个问题在近几年的算法面试中热度非常高。")]),t._v(" "),e("p",[t._v("所谓“热度”从何而来？这里就引出了一个非常有趣的话题：（在前端算法面试中）"),e("strong",[t._v("什么样的题目是好题")]),t._v("？")]),t._v(" "),e("p",[t._v("首先，不能剑走偏锋：好的面试题，它考察的大多是算法/数据结构中最经典、最关键的一部分内容，这样才能体现公平；其次，它的知识点要尽可能密集、题目本身要尽可能具备综合性，这样才能一箭双雕甚至一箭N雕，进而体现区分度、最大化面试过程的效率。")]),t._v(" "),e("p",[t._v("能够同时在这两个方面占尽优势的考题其实并不是很多，“"),e("strong",[t._v("用栈实现队列")]),t._v("”这样的问题算是其中的佼佼者：一方面，它考察的确实是数据结构中的经典内容；另一方面，它又覆盖了两个大的知识点、足以检验出候选人编码基本功的扎实程度。唯一的 BUG 可能就是深度和复杂度不够，换句话说就是不够难。")]),t._v(" "),e("p",[t._v("这个特点，在普通算法面试中可能是 BUG，但在前端算法面试中，实在未必。大家要知道，你是前端，你的面试官也是前端，前端行业普遍的算法水平是啥样他心里还没个数吗...... 实际上大多数前端算法面试题的风格都是非常务实的，需要你炫技的实属特殊情况。")]),t._v(" "),e("h2",{attrs:{id:"如何用栈实现一个队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何用栈实现一个队列"}},[t._v("#")]),t._v(" 如何用栈实现一个队列？")]),t._v(" "),e("blockquote",[e("p",[t._v("题目描述：使用栈实现队列的下列操作："),e("br"),t._v("\npush(x) -- 将一个元素放入队列的尾部。"),e("br"),t._v("\npop() -- 从队列首部移除元素。"),e("br"),t._v("\npeek() -- 返回队列首部的元素。"),e("br"),t._v("\nempty() -- 返回队列是否为空。")])]),t._v(" "),e("blockquote",[e("p",[t._v("示例: MyQueue queue = new MyQueue();"),e("br"),t._v("\nqueue.push(1);"),e("br"),t._v("\nqueue.push(2);"),e("br"),t._v("\nqueue.peek(); // 返回 1"),e("br"),t._v("\nqueue.pop(); // 返回 1"),e("br"),t._v("\nqueue.empty(); // 返回 false")])]),t._v(" "),e("blockquote",[e("p",[t._v("说明:")]),t._v(" "),e("ul",[e("li",[t._v("你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。")]),t._v(" "),e("li",[t._v("你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。")]),t._v(" "),e("li",[t._v("假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。")])])]),t._v(" "),e("h3",{attrs:{id:"思路分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#思路分析"}},[t._v("#")]),t._v(" 思路分析")]),t._v(" "),e("p",[t._v("做这道题大家首先要在心里清楚一个事情：栈和队列的区别在哪里？"),e("br"),t._v("\n仔细想想，栈，后进先出；队列，先进先出。也就是说两者的进出顺序其实是反过来的。用栈实现队列，说白了就是用栈实现先进先出的效果，再说直接点，就是想办法"),e("strong",[t._v("让栈底的元素首先被取出")]),t._v("，也就是让出栈序列被"),e("strong",[t._v("逆序")]),t._v("。"),e("br"),t._v("\n乍一看有点头大：栈结构决定了栈底元素只能被死死地压在最底下，如何使它首先被取出呢？"),e("br"),t._v("\n一个栈做不到的事情，我们用两个栈来做：")]),t._v(" "),e("ul",[e("li",[t._v("首先，准备两个栈：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/13/171735fc8ee608ea?w=914&h=722&f=png&s=30040",alt:""}})]),t._v(" "),e("ul",[e("li",[t._v("现在问题是，怎么把第一个栈底下的那个 1 给撬出来。仔细想想，阻碍我们接触到 1 的是啥？是不是它头上的 3 和 2？那么如何让 3 和 2 给 1 让路呢？实际上咱们完全可以把这三个元素按顺序从 stack1 中出栈、然后入栈到 stack 2 里去：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/13/17173813ab3377b1?w=894&h=748&f=png&s=30404",alt:""}})]),t._v(" "),e("ul",[e("li",[e("p",[t._v("此时 1 变得触手可及。不仅如此，下一次我们试图出队 2 的时候，可以继续直接对 stack2 执行出栈操作——因为转移 2 和 3 的时候已经做过一次逆序了，此时 stack2 的出栈序列刚好就对应队列的出队序列。")])]),t._v(" "),e("li",[e("p",[t._v("有同学会问，那如果 stack1 里入栈新元素怎么办？比如这样：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/13/171738289370743a?w=1010&h=714&f=png&s=37881",alt:""}})])])]),t._v(" "),e("p",[t._v("你会发现这个4按照顺序应该在 1、2、3 后出栈。当 4 需要被出栈时，"),e("code",[t._v("stack2")]),t._v(" 一定已经空掉了。当 "),e("code",[t._v("stack2")]),t._v(" 为空、而 "),e("code",[t._v("stack1")]),t._v(" 不为空时，我们需要继续把 "),e("code",[t._v("stack1")]),t._v(" 中的元素转移到 "),e("code",[t._v("stack2")]),t._v(" 中去，然后再从 "),e("code",[t._v("stack2")]),t._v(" 里取元素。也就是说，所有的出队操作都只能依赖 "),e("code",[t._v("stack2")]),t._v(" 来完成——只要我们坚持这个原则，就可以确保 "),e("code",[t._v("stack1")]),t._v(" 里的元素都能够按照正确的顺序（逆序）出栈。")]),t._v(" "),e("p",[t._v("我们按照这个思路来写代码：")]),t._v(" "),e("h3",{attrs:{id:"编码实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编码实现"}},[t._v("#")]),t._v(" 编码实现")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/**\n * 初始化构造函数\n */\nconst MyQueue = function () {\n  // 初始化两个栈\n  this.stack1 = [];\n  this.stack2 = [];\n};\n\n/**\n* Push element x to the back of queue.\n* @param {number} x\n* @return {void}\n*/\nMyQueue.prototype.push = function (x) {\n  // 直接调度数组的 push 方法\n  this.stack1.push(x);\n};\n\n/**\n* Removes the element from in front of queue and returns that element.\n* @return {number}\n*/\nMyQueue.prototype.pop = function () {\n  // 假如 stack2 为空，需要将 stack1 的元素转移进来\n  if (this.stack2.length <= 0) {\n    // 当 stack1 不为空时，出栈\n    while (this.stack1.length !== 0) {\n      // 将 stack1 出栈的元素推入 stack2\n      this.stack2.push(this.stack1.pop());\n    }\n  }\n  // 为了达到逆序的目的，我们只从 stack2 里出栈元素\n  return this.stack2.pop();\n};\n\n/**\n* Get the front element.\n* @return {number}\n* 这个方法和 pop 唯一的区别就是没有将定位到的值出栈\n*/\nMyQueue.prototype.peek = function () {\n  if (this.stack2.length <= 0) {\n    // 当 stack1 不为空时，出栈\n    while (this.stack1.length != 0) {\n      // 将 stack1 出栈的元素推入 stack2\n      this.stack2.push(this.stack1.pop());\n    }\n  }\n  // 缓存 stack2 的长度\n  const stack2Len = this.stack2.length;\n  return stack2Len && this.stack2[stack2Len - 1];\n};\n\n/**\n* Returns whether the queue is empty.\n* @return {boolean}\n*/\nMyQueue.prototype.empty = function () {\n  // 若 stack1 和 stack2 均为空，那么队列空\n  return !this.stack1.length && !this.stack2.length;\n};\n\n")])])]),e("h2",{attrs:{id:"认识双端队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#认识双端队列"}},[t._v("#")]),t._v(" 认识双端队列")]),t._v(" "),e("p",[t._v("双端队列衍生出的滑动窗口问题，是一个经久不衰的命题热点。关于双端队列，各种各样的解释五花八门，这里大家不要纠结，就记住一句话：")]),t._v(" "),e("p",[e("strong",[t._v("双端队列就是允许在队列的两端进行插入和删除的队列")]),t._v("。")]),t._v(" "),e("p",[t._v("体现在编码上，最常见的载体是既允许使用 pop、push 同时又允许使用 shift、unshift 的数组：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const queue = [1,2,3,4] // 定义一个双端队列   \nqueue.push(1) // 双端队列尾部入队 \nqueue.pop() // 双端队列尾部出队   \nqueue.shift() // 双端队列头部出队 \nqueue.unshift(1) // 双端队列头部入队\n\n")])])]),e("p",[t._v("现在相信你对双端队列已经形成了一个感性的认知，咱们紧接着就开始做题，在题里去认知这种结构的特征和效用。")]),t._v(" "),e("h2",{attrs:{id:"滑动窗口问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口问题"}},[t._v("#")]),t._v(" 滑动窗口问题")]),t._v(" "),e("blockquote",[e("p",[t._v("题目描述：给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。")])]),t._v(" "),e("blockquote",[e("p",[t._v("示例: 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]")])]),t._v(" "),e("blockquote",[e("p",[t._v("解释: 滑动窗口的位置"),e("br"),t._v("\n---------------"),e("br"),t._v("\n[1 3 -1] -3 5 3 6 7"),e("br"),t._v("\n1 [3 -1 -3] 5 3 6 7"),e("br"),t._v("\n1 3 [-1 -3 5] 3 6 7"),e("br"),t._v("\n1 3 -1 [-3 5 3] 6 7"),e("br"),t._v("\n1 3 -1 -3 [5 3 6] 7"),e("br"),t._v("\n1 3 -1 -3 5 [3 6 7]")])]),t._v(" "),e("blockquote",[e("p",[t._v("最大值分别对应："),e("br"),t._v("\n3 3 5 5 6 7")])]),t._v(" "),e("blockquote",[e("p",[t._v("提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。")])]),t._v(" "),e("h3",{attrs:{id:"思路分析-双指针-遍历法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#思路分析-双指针-遍历法"}},[t._v("#")]),t._v(" 思路分析：双指针+遍历法")]),t._v(" "),e("p",[t._v("这道题如果只是为了做对，那么思路其实不难想，我们直接模拟题中描述的这个过程就行。"),e("br"),t._v("\n按照题意，它要求我们在遍历数组的过程当中，约束一个窗口——窗口的本质其实就是一个范围，像这样：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[1  3  -1] -3  5  3  6  7 \n\n")])])]),e("p",[t._v("范围就被圈定在了前三个元素。"),e("br"),t._v("\n我们前面学过，约束范围，可以用双指针。因此我这里定义一个 "),e("code",[t._v("left")]),t._v(" 左指针、定义一个 "),e("code",[t._v("right")]),t._v(" 右指针，分别指向窗口的两端即可：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/19/171915c3ae13a951?w=1252&h=452&f=png&s=27612",alt:""}})]),t._v(" "),e("p",[t._v("接下来我们可以把这个窗口里的数字取出来，直接遍历一遍、求出最大值，然后把最大值存进结果数组。这样第一个窗口的最大值就有了。")]),t._v(" "),e("p",[t._v("接着按照题意，窗口每次前进一步（左右指针每次一起往前走一步），此时的范围变成了这样：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/19/171915c9c9f694db?w=1238&h=462&f=png&s=27669",alt:""}})]),t._v(" "),e("p",[t._v("我们要做的仍然是取出当前范围的所有元素、遍历一遍求出最大值，然后将最大值存进结果数组。")]),t._v(" "),e("p",[t._v("反复执行上面这个过程，直到数组完全被滑动窗口遍历完毕，我们也就得到了问题的答案。")]),t._v(" "),e("p",[t._v("基于这个淳朴的思路，我们来写一波代码：")]),t._v(" "),e("h3",{attrs:{id:"编码实现-双指针-遍历法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编码实现-双指针-遍历法"}},[t._v("#")]),t._v(" 编码实现：双指针+遍历法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst maxSlidingWindow = function (nums, k) {\n  // 缓存数组的长度\n  const len = nums.length;\n  // 定义结果数组\n  const res = [];\n  // 初始化左指针\n  let left = 0;\n  // 初始化右指针\n  let right = k - 1;\n  // 当数组没有被遍历完时，执行循环体内的逻辑\n  while (right < len) {\n    // 计算当前窗口内的最大值\n    const max = calMax(nums, left, right);\n    // 将最大值推入结果数组\n    res.push(max);\n    // 左指针前进一步\n    left++;\n    // 右指针前进一步\n    right++;\n  }\n  // 返回结果数组\n  return res;\n};\n\n// 这个函数用来计算最大值\nfunction calMax(arr, left, right) {\n  // 处理数组为空的边界情况\n  if (!arr || !arr.length) {\n    return;\n  }\n  // 初始化 maxNum 的值为窗口内第一个元素\n  let maxNum = arr[left];\n  // 遍历窗口内所有元素，更新 maxNum 的值\n  for (let i = left; i <= right; i++) {\n    if (arr[i] > maxNum) {\n      maxNum = arr[i];\n    }\n  }\n  // 返回最大值\n  return maxNum;\n}\n\n")])])]),e("h3",{attrs:{id:"解法复盘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解法复盘"}},[t._v("#")]),t._v(" 解法复盘")]),t._v(" "),e("p",[t._v("上面这个解法，你在面试的时候写上去，完全没有问题，也不用担心超时。"),e("br"),t._v("\n有的同学可能会觉得 "),e("code",[t._v("calMax")]),t._v(" 这个函数多余了，认为可以直接用 "),e("code",[t._v("Math.max")]),t._v(" 这个 JS 原生方法。其实就算是"),e("code",[t._v("Math.max")]),t._v("，也不可避免地需要对你传入的多个数字做最小值查找，"),e("code",[t._v("calMax")]),t._v(" 和"),e("code",[t._v("Math.max")]),t._v("做的工作可以说是一样的辛苦。我这里手动实现一个 "),e("code",[t._v("calMax")]),t._v("， 大家会对查找过程造成的时间开销有更直观的感知。")]),t._v(" "),e("p",[t._v("现在我们来思考一下，上面这一波操作下来，时间复杂度是多少？"),e("br"),t._v("\n这波操作里其实涉及了两层循环，外层循环是 "),e("code",[t._v("while")]),t._v("，它和滑动窗口前进的次数有关。滑动窗口前进了多少次，"),e("code",[t._v("while")]),t._v(" 就执行了多少次。")]),t._v(" "),e("p",[t._v("假设数组的规模是 "),e("code",[t._v("n")]),t._v("，那么从起始位置开始，滑动窗口每次走一步，一共可以走 "),e("code",[t._v("n - k")]),t._v(" 次。注意别忘了初始位置也算作一步的，因此一共走了 "),e("code",[t._v("n - k + 1")]),t._v("次。然后每个窗口内部我们又会固定执行 "),e("code",[t._v("k")]),t._v(" 次遍历。注意 "),e("code",[t._v("k")]),t._v(" 可不是个常数，它和 "),e("code",[t._v("n")]),t._v(" 一样是个变量。因此这个时间复杂度简化后用大 O 表示法可以记为 "),e("code",[t._v("O(kn)")]),t._v("。")]),t._v(" "),e("p",[e("code",[t._v("O(kn)")]),t._v(" 虽然不差，但对这道题来说，还不是最好。因此在面试过程中，如果你采用了上面这套解法做出了这个题，面试官有 99% 的可能性会追问你：这个题可以优化吗？如何优化？（或者直接问你，你能在线性时间复杂度内解决此题吗？）")]),t._v(" "),e("p",[t._v("答案当然是能，然后面试官就会搬个小板凳坐你旁边，看看你怎么妙手回春，变 "),e("code",[t._v("O(kn)")]),t._v(" 为 "),e("code",[t._v("O(n)")]),t._v("。")]),t._v(" "),e("p",[t._v("接下来你需要表演的，正是面试官期待已久的双端队列解法啊！")]),t._v(" "),e("h3",{attrs:{id:"思路分析-双端队列法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#思路分析-双端队列法"}},[t._v("#")]),t._v(" 思路分析：双端队列法")]),t._v(" "),e("p",[t._v("要想变 "),e("code",[t._v("O(kn)")]),t._v(" 为 "),e("code",[t._v("O(n)")]),t._v("，我们就要想怎么做才能丢掉这个 "),e("code",[t._v("k")]),t._v("。"),e("br"),t._v(" "),e("code",[t._v("k")]),t._v(" 之所以会产生，是因为我们现在只能通过遍历来更新最大值。那么更新最大值，有没有更高效的方法呢？"),e("br"),t._v("\n大家仔细想想，当滑动窗口往后前进一步的时候，比如我从初始位置前进到第二个位置：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/19/171916004417d924?w=1218&h=448&f=png&s=27971",alt:""}})]),t._v(" "),e("p",[t._v("（图中红色的范围是初始位置时，滑动窗口覆盖到的元素）")]),t._v(" "),e("p",[t._v("此时滑动窗口内的元素少了一个 1，增加了一个 -3——减少的数不是当前最大值，增加的数也没有超越当前最大值，因此最大值仍然是 3。此时我们不禁要想：如果我们能"),e("strong",[t._v("在窗口发生移动时，只根据发生变化的元素对最大值进行更新")]),t._v("，那复杂度是不是就低很多了？")]),t._v(" "),e("p",[t._v("双端队列可以完美地帮助我们达到这个目的。")]),t._v(" "),e("p",[t._v("使用双端队列法，核心的思路是维护一个"),e("strong",[t._v("有效的递减队列")]),t._v("。")]),t._v(" "),e("p",[t._v("在遍历数组的前期，我们尝试将遍历到的每一个元素都推入队列内部（下图是第一个元素入队的示意图）：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/19/171916b7462c1b87?w=1242&h=588&f=png&s=35019",alt:""}})]),t._v(" "),e("p",[t._v("每尝试推入一个元素前，都把这个元素与队列头部的元素作对比。根据对比结果的不同，采取不同的措施：")]),t._v(" "),e("ul",[e("li",[t._v("如果试图推入的元素（当前元素）大于队尾元素，则意味着队列的递减趋势被打破了。此时我们需要将队列尾部的元素依次出队（注意由于是双端队列，所以队尾出队是没有问题的）、直到队尾元素大于等于当前元素为止，此时再将当前元素入队。")]),t._v(" "),e("li",[t._v("如果试图推入的元素小于队列尾部的元素，那么就不需要额外的操作，直接把当前元素入队即可。")])]),t._v(" "),e("p",[t._v("我用动画来表达一下这个过程：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/19/171918a1ae330dd3?w=1343&h=799&f=gif&s=469027",alt:""}})]),t._v(" "),e("p",[t._v("（注：动画大小已经极致压缩，如果仍然存在加载失败问题，可能与网络环境有关。如果你遇到了这个问题，建议 PC 端点击"),e("a",{attrs:{href:"https://user-gold-cdn.xitu.io/2020/4/19/171918a1ae330dd3?w=1343&h=799&f=gif&s=469027",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),e("OutboundLink")],1),t._v("直接访问动图试试看）")]),t._v(" "),e("p",[t._v("维持递减队列的目的，就在于"),e("strong",[t._v("确保队头元素始终是当前窗口的最大值")]),t._v("。"),e("br"),t._v("\n当遍历到的元素个数达到了 "),e("code",[t._v("k")]),t._v(" 个时，意味着滑动窗口的第一个最大值已经产生了，我们把它 push 进结果数组里：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/19/171916d956b7871b?w=1232&h=872&f=png&s=59228",alt:""}})]),t._v(" "),e("p",[t._v("然后继续前进，我们发现数组索引 0 处的元素（"),e("code",[t._v("1")]),t._v("）已经被踢出滑动窗口了（图中红色方块对应的是当前滑动窗口覆盖到的元素们）：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/19/171916fec2ae69a2?w=1184&h=718&f=png&s=46258",alt:""}})]),t._v(" "),e("p",[t._v("为了确保"),e("strong",[t._v("队列的有效性")]),t._v("，需要及时地去队列检查下 "),e("code",[t._v("1")]),t._v(" 这个元素在不在队列里（在的话要及时地踢出去，因为队列本身只维护当前滑动窗口内的元素）。")]),t._v(" "),e("p",[t._v("这里大家思考一下，我在查找 "),e("code",[t._v("1")]),t._v(" 的时候，需不需要遍历整个队列？答案是不需要，因为 "),e("code",[t._v("1")]),t._v(" 是最靠前的一个元素，如果它在，那么它一定是队头元素。这里我们只需要检查队头元素是不是 "),e("code",[t._v("1")]),t._v(" 就行了。 此时我们检查队头，发现是 "),e("code",[t._v("3")]),t._v("：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/4/19/17191713bc7336d2?w=936&h=184&f=png&s=16471",alt:""}})]),t._v(" "),e("p",[t._v("没错，"),e("code",[t._v("1")]),t._v("早就因为不符合递减趋势被从队头干掉了。此时我们可以断定，当前双端队列里的元素都是滑动窗口已经覆盖的有效元素——没毛病，继续往下走就行了。")]),t._v(" "),e("p",[t._v("接下来，每往前遍历一个元素，都需要重复以上的几个步骤。这里我总结一下每一步都做了什么：")]),t._v(" "),e("ol",[e("li",[t._v("检查队尾元素，看是不是都满足大于等于当前元素的条件。如果是的话，直接将当前元素入队。否则，将队尾元素逐个出队、直到队尾元素大于等于当前元素为止。")]),t._v(" "),e("li",[t._v("将当前元素入队")]),t._v(" "),e("li",[t._v("检查队头元素，看队头元素是否已经被排除在滑动窗口的范围之外了。如果是，则将队头元素出队。")]),t._v(" "),e("li",[t._v("判断滑动窗口的状态：看当前遍历过的元素个数是否小于 "),e("code",[t._v("k")]),t._v("。如果元素个数小于"),e("code",[t._v("k")]),t._v("，这意味着第一个滑动窗口内的元素都还没遍历完、第一个最大值还没出现，此时我们还不能动结果数组，只能继续更新队列；如果元素个数大于等于"),e("code",[t._v("k")]),t._v("，这意味着滑动窗口的最大值已经出现了，此时每遍历到一个新元素（也就是滑动窗口每往前走一步）都要及时地往结果数组里添加当前滑动窗口对应的最大值（最大值就是此时此刻双端队列的队头元素）。")])]),t._v(" "),e("p",[t._v("这四个步骤分别有以下的目的：")]),t._v(" "),e("ol",[e("li",[t._v("维持队列的"),e("strong",[t._v("递减性")]),t._v("：确保队头元素是当前滑动窗口的最大值。这样我们每次取最大值时，直接取队头元素即可。")]),t._v(" "),e("li",[t._v("这一步没啥好说的，就是在维持队列递减性的基础上、更新队列的内容。")]),t._v(" "),e("li",[t._v("维持队列的"),e("strong",[t._v("有效性")]),t._v("：确保队列里所有的元素都在滑动窗口圈定的范围以内。")]),t._v(" "),e("li",[t._v("排除掉滑动窗口还没有初始化完成、第一个最大值还没有出现的特殊情况。")])]),t._v(" "),e("p",[t._v("结合以上的分析，我们来写代码：")]),t._v(" "),e("h3",{attrs:{id:"编码实现-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编码实现-2"}},[t._v("#")]),t._v(" 编码实现")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst maxSlidingWindow = function (nums, k) {\n  // 缓存数组的长度\n  const len = nums.length;\n  // 初始化结果数组\n  const res = [];\n  // 初始化双端队列\n  const deque = [];\n  // 开始遍历数组\n  for (let i = 0; i < len; i++) {\n    // 当队尾元素小于当前元素时\n    while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {\n      // 将队尾元素（索引）不断出队，直至队尾元素大于等于当前元素\n      deque.pop();\n    }\n    // 入队当前元素索引（注意是索引）\n    deque.push(i);\n    // 当队头元素的索引已经被排除在滑动窗口之外时\n    while (deque.length && deque[0] <= i - k) {\n      // 将队头元素索引出队\n      deque.shift();\n    }\n    // 判断滑动窗口的状态，只有在被遍历的元素个数大于 k 的时候，才更新结果数组\n    if (i >= k - 1) {\n      res.push(nums[deque[0]]);\n    }\n  }\n  // 返回结果数组\n  return res;\n};\n\n")])])]),e("p",[t._v("（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）")])])}),[],!1,null,null,null);n.default=_.exports}}]);