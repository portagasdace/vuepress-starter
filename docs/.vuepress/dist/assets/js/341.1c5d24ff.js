(window.webpackJsonp=window.webpackJsonp||[]).push([[341],{697:function(t,e,n){"use strict";n.r(e);var a=n(42),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"导读"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#导读"}},[t._v("#")]),t._v(" 导读")]),t._v(" "),n("p",[t._v("本节标题：「装修阶段」- 基于路由的按需渲染")]),t._v(" "),n("p",[t._v("本节主旨：页面渲染性能优化，实现基于路由的拆分，按需渲染，需要特别注意双端路由如何处理")]),t._v(" "),n("p",[t._v("本节配套代码：")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-routesplit",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-routesplit"),n("OutboundLink")],1)]),t._v(" "),n("h1",{attrs:{id:"正文"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[t._v("#")]),t._v(" ---正文")]),t._v(" "),n("h1",{attrs:{id:"react-ssr-下的路由分割-按需渲染"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-ssr-下的路由分割-按需渲染"}},[t._v("#")]),t._v(" react ssr 下的路由分割 - 按需渲染")]),t._v(" "),n("p",[t._v("到这里，我们的应用骨架已相对完善，已经可以 用来进行实际项目开发，但是仍然不够，还有优化的空间。")]),t._v(" "),n("p",[t._v("现在的所有业务代码都打包到了一个文件内"),n("code",[t._v("main.js")]),t._v("。")]),t._v(" "),n("p",[t._v("若开发一个真实的项目，在开始阶段页面较少，支持的业务较少，"),n("code",[t._v("js")]),t._v(" 代码体积并不会太大，但是随着时间的推移，这个 "),n("code",[t._v("js")]),t._v(" 文件会变得越来越大，有可能超过"),n("code",[t._v("1M")]),t._v("。")]),t._v(" "),n("p",[t._v("过大的文件会严重影响页面的加载速度，直接影响用户体验。")]),t._v(" "),n("h1",{attrs:{id:"如何优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何优化"}},[t._v("#")]),t._v(" 如何优化")]),t._v(" "),n("p",[t._v("代码全部打包到一个文件内在访问时被全部加载，但用户当前访问的也就一个页面，所以我们只需要当前页面的业务代码就可以了，其他页面的代码是不需要加载的，当用户访问的时候再加载和执行岂不是更好？")]),t._v(" "),n("p",[t._v("所以我们本节开始来实现基于路由的按需渲染。")]),t._v(" "),n("h1",{attrs:{id:"需渲染原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#需渲染原理"}},[t._v("#")]),t._v(" 需渲染原理")]),t._v(" "),n("p",[t._v("早期接触过 "),n("code",[t._v("webpack2")]),t._v(" 的同学应该都知道"),n("code",[t._v("require.ensure")]),t._v("方法，甚至使用过该方法来实现按需加载。")]),t._v(" "),n("p",[t._v("这个 "),n("code",[t._v("Api")]),t._v(" 的作用就是用来实现代码分割，它会单独打包指定的文件，不和主文件打包在一起。")]),t._v(" "),n("p",[t._v("不过后来有了更加规范的方式来实现按需加载-"),n("code",[t._v("动态导入")]),t._v("。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const A = import('./pages/A');\n\n")])])]),n("p",[t._v("并且在"),n("code",[t._v("webpack2")]),t._v("版本中早就支持了该特性，只需要配置"),n("code",[t._v("@babel/plugin-syntax-dynamic-import")]),t._v("插件便可使用。")]),t._v(" "),n("p",[t._v("也就是说从"),n("code",[t._v("webpack2")]),t._v("开始已经支持了"),n("code",[t._v("require.ensure")]),t._v("和动态导入两种方式来实现按需加载。")]),t._v(" "),n("p",[t._v("这里我们主要介绍下使用动态导入的方式来实现按需加载。")]),t._v(" "),n("p",[n("code",[t._v("import()")]),t._v("只是一个语法糖，当前模块没有加载时，内部会发起一个"),n("code",[t._v("JSONP")]),t._v("请求来加载目标代码模块， 返回值是一个"),n("code",[t._v("Promise")]),t._v("对象，可以在"),n("code",[t._v("then")]),t._v("方法内得到真正的模块。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// pages/a.js\nexport default class A{\n    //...\n}\n\nimport('./pags/a').then({default:A}=>{\n    \n    //...\n})\n\n")])])]),n("p",[t._v("代码拆分和异步加载逻辑"),n("code",[t._v("webpack")]),t._v("已帮我们完成。")]),t._v(" "),n("p",[t._v("那动态导入怎样和"),n("code",[t._v("react")]),t._v("结合来实现按需加载呢？")]),t._v(" "),n("h1",{attrs:{id:"具体实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#具体实现"}},[t._v("#")]),t._v(" 具体实现")]),t._v(" "),n("p",[t._v("实现按需加载并不复杂，官方也有很多 "),n("code",[t._v("demo")]),t._v(" 可以参考。")]),t._v(" "),n("p",[t._v("在"),n("code",[t._v("react router3")]),t._v("下实现按需加载更简单，但是 "),n("code",[t._v("react router4")]),t._v("就完全不同了。")]),t._v(" "),n("p",[t._v("在"),n("code",[t._v("v3")]),t._v("中，路由提供了特定的属性来支持，下面简短的几行代码就达到了按需加载的效果。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const A = (location, cb) => {\n    require.ensure([], require => {\n        cb(null, require('../Component/A').default)\n    },'A')\n}\n\n//配置route\n<Route path=\"/a\" getComponent={A} />\n\n")])])]),n("h1",{attrs:{id:"react-router4-按需渲染"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-router4-按需渲染"}},[t._v("#")]),t._v(" react router4 按需渲染")]),t._v(" "),n("p",[t._v("我们需要抽象一个"),n("code",[t._v("AsyncBundler")]),t._v("组件，用于按需加载。")]),t._v(" "),n("p",[t._v("我们为该组件添了一个"),n("code",[t._v("state mod")]),t._v("状态， 表示异步加载(import())完成后得到的组件，并且加载过程增加"),n("code",[t._v("laoding")]),t._v("显示。")]),t._v(" "),n("p",[t._v("该组件还接收一个"),n("code",[t._v("load props")]),t._v("，此属性为"),n("code",[t._v("Promise")]),t._v("类型，用于动态导入其他组件，当"),n("code",[t._v("AsyncBundler")]),t._v("挂载完成后，在"),n("code",[t._v("componentDidMount")]),t._v("事件内执行异步组件的加载,也就是"),n("code",[t._v("props. load")]),t._v("方法，在"),n("code",[t._v("then")]),t._v("方法内得到加载成功的异步组件，同时更新"),n("code",[t._v("AsyncBundler")]),t._v("组件的"),n("code",[t._v("state.mod")]),t._v("，完成渲染。")]),t._v(" "),n("p",[t._v("以下是该组件完整代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n * 容器组件，组件按需加载器\n *\n * @class Bundle\n * @extends {Component}\n */\nexport default class AsyncBundle extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mod: null//自身状态\n        };\n    }\n\n    componentDidMount() {\n        if (!this.state.mod) {\n            this.load(this.props);\n        }\n    }\n\n\n    load(props) {\n        this.setState({\n            mod: null\n        });\n        //注意这里，使用Promise对象; mod.default导出默认\n        props.load().then((mod) => {\n            this.setState({\n                mod: mod.default ? mod.default : mod\n            });\n        });\n    }\n\n    render() {\n        return this.state.mod ? this.props.children(this.state.mod) : <LoadingCompoent/>;\n    }\n}\n\n")])])]),n("p",[t._v("组件的具体用法如下")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" <AsyncBundle load={()=>import('../pages/a'))}>\n            {(Comp) => <Comp />}\n </AsyncBundle>\n\n")])])]),n("p",[t._v("为了使用更方便，我们对上面的写法再次进行封装，只需要调用一个方法就可以。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\n//异步加载组件的高阶函数\n\nimport AsyncBundle from './async-bundle';\nimport React from 'react';\nfunction AsyncLoader (loader) {\n\n    function asyncFn(props) {\n       return <AsyncBundle load={loader}>\n            {(Comp) => <Comp {...props}/>}\n        </AsyncBundle>\n    }\n    \n    return asyncFn;\n}\n\nexport default AsyncLoader;\n\n\n")])])]),n("p",[t._v("封装后的用法如下，这样使用可以节省不少代码。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" AsyncLoader(() => import('../pages/index')),\n\n")])])]),n("h1",{attrs:{id:"路由改造"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#路由改造"}},[t._v("#")]),t._v(" 路由改造")]),t._v(" "),n("p",[t._v("我们可以通过"),n("code",[t._v('/*webpackChunkName:"chunk-index"*/')]),t._v("的方式来执行文件名称，默认按照数字来命名.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\n//组件动态加载容器\nimport AsyncLoader from './async-loader';\n\nexport default [\n    {\n        path: ['/','/index'],\n        component: AsyncLoader(() => import(/*webpackChunkName:\"chunk-index\"*/'../pages/index')),\n        exact:true\n    },\n    {\n        path: '/list',\n        component: AsyncLoader(() => import('../pages/list')),\n        exact: true\n    },\n    {\n        path: '*',\n        component: pageNotFound,\n        exact: true\n    }\n]\n\n")])])]),n("h1",{attrs:{id:"react-ssr-按需加载的坑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-ssr-按需加载的坑"}},[t._v("#")]),t._v(" react ssr 按需加载的坑")]),t._v(" "),n("p",[t._v("路由改造完成后，已经可以看效果，同时控制台也能看到按需加载的包。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/6/16f7afadf72ace7e?w=1488&h=688&f=png&s=131673",alt:""}})]),t._v(" "),n("p",[t._v("但是页面效果并不是我们所期望的。")]),t._v(" "),n("p",[t._v("页面显示时会先显示"),n("code",[t._v("loading...")]),t._v("，然后又渲染了对应的组件。")]),t._v(" "),n("p",[t._v("此时查看网页源代码发现并没有具体内容，也就是我们的"),n("code",[t._v("ssr")]),t._v("无效了。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/6/16f7afd0bdf69f2f?w=726&h=334&f=png&s=33097",alt:""}})]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/6/16f7afd75596dca7?w=729&h=365&f=png&s=38204",alt:""}})]),t._v(" "),n("h1",{attrs:{id:"处理-ssr-无效问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#处理-ssr-无效问题"}},[t._v("#")]),t._v(" 处理 ssr 无效问题")]),t._v(" "),n("p",[t._v("路由按需加载后，服务端渲染的组件发生了改变。")]),t._v(" "),n("p",[t._v("组件按需加载仅仅是针对浏览器端的，在服务器端是没必要。由于路由对应的组件外层包裹了一个动态渲染组件，服务端执行时他并没有得到真正的组件，所以"),n("code",[t._v("ssr")]),t._v("直出的内容会显示为一个"),n("code",[t._v("loading")]),t._v("。")]),t._v(" "),n("p",[t._v("比如非按需时会渲染"),n("code",[t._v("A")]),t._v("组件，现在改造成按需渲染此时"),n("code",[t._v("A")]),t._v("外层会包裹"),n("code",[t._v("AsyncBundle")]),t._v("组件，所以在服务端渲染的组件变成了"),n("code",[t._v("AsyncBundle")]),t._v(" 容器组件。")]),t._v(" "),n("p",[t._v("其实在服务端根本不需要按需，只需要一个路由的静态配置就可以了。")]),t._v(" "),n("p",[t._v("如何处理呢？")]),t._v(" "),n("p",[t._v("服务端在路由匹配前，将动态化为静态路由（也就是预加载）。")]),t._v(" "),n("p",[t._v("看下转换代码，就明白了。")]),t._v(" "),n("p",[n("code",[t._v("转为静态路由")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//将路由转换为静态路由\nasync function getStaticRoutes(routes) {\n\n    let len = routes.length,\n        i = 0;\n    const staticRoutes = [];\n\n    for (; i < len; i++) {\n        let item = routes[i];\n        if (checkIsAsyncRoute(item.component)) {\n            staticRoutes.push({\n                ...item,\n                ...{\n                    component: (await item.component().props.load()).default\n                }//调用下load方法得到返回值即可\n            });\n        } else {\n            staticRoutes.push({\n                ...item\n            });\n        }\n    }\n    return staticRoutes; //返回静态路由\n}\n\n")])])]),n("p",[t._v("上面方法返回了一个静态配置的路由，之后的匹配和渲染都基于这个静态路由。")]),t._v(" "),n("p",[t._v("这里有个点可以优化一下，把查找的结果缓存起来，没必要每次请求都去转换一次。")]),t._v(" "),n("p",[t._v("看下"),n("code",[t._v("ssr")]),t._v("中间件代码的改造")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// src/server/middlewares/react-ssr.js 主要变更代码\n//...\n\n//获得静态路由\nconst staticRoutesList = await getStaticRoutes(routeList);\n\n//查找到的目标路由对象\n\nlet matchResult = await matchRoute(path, staticRoutesList);\n\nlet { targetRoute, targetMatch } = matchResult;\n//....\n\n//staticRouter 也是用静态路由 staticRoutesList\n\nconst html = renderToString(<StaticRouter location={path} context={context}>\n        <App routeList={staticRoutesList}></App>\n    </StaticRouter>);\n\n\n")])])]),n("p",[t._v("查看效果后，"),n("code",[t._v("ssr")]),t._v(" 组件直出问题解决。")]),t._v(" "),n("p",[t._v("不过还有问题。。。")]),t._v(" "),n("p",[t._v("这次页面的效果更加神奇了，先显示服务端直出的内容，随后显示"),n("code",[t._v("loading")]),t._v("，然后"),n("code",[t._v("loading")]),t._v("消失，又显示了组件的内容。")]),t._v(" "),n("h1",{attrs:{id:"处理客户端覆盖渲染问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#处理客户端覆盖渲染问题"}},[t._v("#")]),t._v(" 处理客户端覆盖渲染问题")]),t._v(" "),n("p",[t._v("为什么浏览器接管后，页面还会出现"),n("code",[t._v("...loading")]),t._v("并且一闪而过呢?")]),t._v(" "),n("p",[t._v("这里请大家屏气凝神的想一下，其实很简单。")]),t._v(" "),n("p",[t._v("非按需渲染时是不会出现 "),n("code",[t._v("loading")]),t._v(" 的吧，不过这好像是废话。")]),t._v(" "),n("p",[t._v("那么按需的时候出现"),n("code",[t._v("loading")]),t._v("，其实是在等待异步 "),n("code",[t._v("js")]),t._v(" 代码的加载， 动态创建 "),n("code",[t._v("script")]),t._v("后，"),n("code",[t._v("js")]),t._v("代码的请求和下载也是需要时间的。")]),t._v(" "),n("p",[t._v("所以呢？")]),t._v(" "),n("p",[t._v("我们应该等这段异步"),n("code",[t._v("js")]),t._v("代码下载完后再去执行渲染是不是就好了呢？")]),t._v(" "),n("p",[t._v("答案是对的！")]),t._v(" "),n("p",[t._v("那如何做呢？")]),t._v(" "),n("p",[n("code",[t._v("组件查找")])]),t._v(" "),n("p",[t._v("客户端渲染前先进行路由查找,得到对应的组件后，调用组件的异步渲染方法"),n("code",[t._v("load")]),t._v("，等待其加载完后，再进行组件的"),n("code",[t._v("DOM")]),t._v("渲染。")]),t._v(" "),n("p",[t._v("具体实现如下")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//提取出挂载到 dom 方法\nfunction renderDom(routeList) {\n        //渲染index\n        ReactDom.hydrate(<BrowserRouter>\n                <App routeList={routeList} />\n        </BrowserRouter>\n                , document.getElementById('root'))\n}\n\n//渲染入口\nfunction clientRender(routeList) {\n\n        let initialData = JSON.parse(document.getElementById('ssrTextInitData').value);\n\n        //查找路由\n        let matchResult = matchRoute(document.location.pathname, routeList);\n        let { targetRoute } = matchResult;\n        if (targetRoute) {\n                //设置组件初始化数据\n                targetRoute.initialData = initialData;\n                //****等待异步脚本加载完成****\n                if (targetRoute.component[proConfig.asyncComponentKey]) {\n                    targetRoute.component().props.load().then(res => {\n                    //异步组件加载完成后再渲染页面\n                    console.log('异步组件加完成');\n                            \n                    //加载完成再执行 dom 挂载    \n                    renderDom(routeList);\n                    });\n                }\n\n        } else {\n                renderDom(routeList);\n        }\n}\n\n//渲染入口\nclientRender(routeList);\n\n\n")])])]),n("p",[t._v("到这里，一个完整的"),n("code",[t._v("react ssr")]),t._v(" 路由按需加载就完成了，小伙伴们抓紧来试试吧。")]),t._v(" "),n("h1",{attrs:{id:"其他方式实现按需渲染"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其他方式实现按需渲染"}},[t._v("#")]),t._v(" 其他方式实现按需渲染")]),t._v(" "),n("p",[t._v("在上面我们是自己手写的异步组件加载器,当然业界也有很多比较成熟的工具库,原理和我们的实现差不多，只是容错更强，功能更丰富。")]),t._v(" "),n("p",[t._v("下面几个现有库，有兴趣的可以自己试试。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("react-async-component\nreact-loadable //广泛使用\n@loadable/component\nreact-imported-component\nreact-universal-component\n\n")])])]),n("p",[n("code",[t._v("react-loadable")]),t._v(" 该库是一个轻量级的代码分割组件，用于加载动态导入的组件，而且它考虑了非常多的边界情况，支持预加载、"),n("code",[t._v("ssr")]),t._v("，业内使用度很高。")]),t._v(" "),n("p",[n("strong",[t._v("遗留问题")])]),t._v(" "),n("p",[t._v("路由分割后，会导致热更新无效，现在官方也依然存在这个 "),n("code",[t._v("issue")]),t._v("，现在唯一的办法就是牺牲热更新对状态的保存,但不影响模块热替换。")]),t._v(" "),n("h1",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),n("p",[t._v("这一节我们完成了一个重大的优化，实现了基于路由的按需渲染。")]),t._v(" "),n("p",[t._v("单纯实现组件的按需加载还是很容易的，关键是和"),n("code",[t._v("react ssr")]),t._v("结合后该如何解决出现的各种问题。")]),t._v(" "),n("p",[t._v("要知道在服务端不需要动态导入，服务端只需要处理静态路由即可，所以我们在使用前将动态路由转换为了静态路由。")]),t._v(" "),n("p",[t._v("另外客户端渲染也需要注意，需使用预加载，等异步组件加载完成再进行"),n("code",[t._v("DOM")]),t._v("的挂载，否则会出现客户端覆盖服务端渲染的问题。")]),t._v(" "),n("p",[t._v("本节代码已上传")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-routesplit",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-routesplit"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("感谢你的阅读。")]),t._v(" "),n("p",[t._v("如果有问题欢迎留言，也欢迎在留言区留下你的想法和思考。")])])}),[],!1,null,null,null);e.default=s.exports}}]);