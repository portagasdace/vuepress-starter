(window.webpackJsonp=window.webpackJsonp||[]).push([[346],{702:function(e,t,n){"use strict";n.r(t);var a=n(42),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"导读"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#导读"}},[e._v("#")]),e._v(" 导读")]),e._v(" "),n("p",[e._v("本节标题：对比业内已有框架的实现")]),e._v(" "),n("p",[e._v("本节主旨：对比业内 next.js，egg-react-ssr 的实现方案，验证自身实现的标准性")]),e._v(" "),n("h1",{attrs:{id:"正文"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[e._v("#")]),e._v(" 正文")]),e._v(" "),n("p",[n("code",[e._v("react ssr")]),e._v(" 到现在已经不是新技术，技术原理也不复杂，但是真要自己弄出一个完整的轮子并非易事，有非常多的细节和边边角角需要处理。")]),e._v(" "),n("p",[e._v("所以除了自己来造轮子，我们还可以站在巨人的肩膀上，直接使用业内现成的框架进行开发。")]),e._v(" "),n("p",[e._v("造轮子可以，但是不要闭门造车，所以本节我们来了解下业内框架他们是怎样实现的，也侧面的看下我们已有功能的实现是否合理，是为了验证我们的方案，更是学习。")]),e._v(" "),n("p",[e._v("这里主要来看下"),n("code",[e._v("next.js")]),e._v("和"),n("code",[e._v("egg-react-ssr")]),e._v("的实现。")]),e._v(" "),n("p",[e._v("当然还有"),n("code",[e._v("umi")]),e._v("，不过"),n("code",[e._v("umi ssr")]),e._v("代码核心部分也是"),n("code",[e._v("egg-react-ssr")]),e._v("团队贡献的代码，所以就不做对比了。")]),e._v(" "),n("p",[e._v("另外在客户端组件渲染时会使用服务端直出的数据问题，也是参考"),n("code",[e._v("egg-react-ssr")]),e._v("来实现的,只是细节不同。")]),e._v(" "),n("h1",{attrs:{id:"数据预取"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据预取"}},[e._v("#")]),e._v(" 数据预取")]),e._v(" "),n("p",[e._v("看下这两个框架在服务端如何获取组件数据的。")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("next.js")]),e._v(" 数据预取代码")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React from 'react'\n\nexport default class extends React.Component {\n  static async getInitialProps({ req }) {\n    const userAgent = req ? req.headers['user-agent'] : navigator.userAgent\n    return { userAgent }\n  }\n\n  render() {\n    return (\n      <div>\n        Hello World {this.props.userAgent}\n      </div>\n    )\n  }\n}\n\n")])])]),n("p",[e._v("当页面渲染时加载数据，使用了一个异步方法"),n("code",[e._v("getInitialProps")]),e._v("。它能异步获取数据，并绑定在"),n("code",[e._v("props")]),e._v("上。当服务渲染时，"),n("code",[e._v("getInitialProps")]),e._v("将会把数据序列化，就像"),n("code",[e._v("JSON.stringify")]),e._v("。")]),e._v(" "),n("p",[e._v("当第一次进入页面时,"),n("code",[e._v("getInitialProps")]),e._v("只会在服务端执行。只有当路由跳转（Link组件跳转或 API 方法跳转）时，客户端才会执行"),n("code",[e._v("getInitialProps")]),e._v("。")]),e._v(" "),n("p",[e._v("另外此方法只能用于页面组件内，不能在子组件内使用。")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("egg-react-ssr")]),e._v(" 数据预取代码")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React from 'react'\nimport { Link } from 'react-router-dom'\nimport './index.less'\n\nfunction Page (props) {\n  return (\n    <div className='normal'>\n      <div className='welcome' />\n      <ul className='list'>\n        {\n          props.news && props.news.map(item => (\n            <li key={item.id}>\n              <div>文章标题: {item.title}</div>\n              <div className='toDetail'><Link to={`/news/${item.id}`}>点击查看详情</Link></div>\n            </li>\n          ))\n        }\n      </ul>\n    </div>\n  )\n}\n\nPage.getInitialProps = async (ctx) => {\n  // ssr渲染模式只在服务端通过Node获取数据，csr渲染模式只在客户端通过http请求获取数据，getInitialProps方法在整个页面生命周期只会执行一次\n  return __isBrowser__ ? (await window.fetch('/api/getIndexData')).json() : ctx.service.api.index()\n}\n\nexport default Page\n\n\n")])])]),n("p",[e._v("页面初始化时，服务端根据当前请求的"),n("code",[e._v("path")]),e._v("，来确定我们要渲染哪一个组件，"),n("code",[e._v("getComponent")]),e._v("可以理解为一个根据"),n("code",[e._v("path")]),e._v("从路由表中找到匹配的组件的方法,检测该组件上有没有"),n("code",[e._v("getInitialProps")]),e._v("静态方法，这里之所以要用静态方法，是为了不需要实例化就可以拿到方法。")]),e._v(" "),n("p",[e._v("如果有的话，将调用这个方法,将数据作为组件的"),n("code",[e._v("props")]),e._v("传入，使得组件可以通过"),n("code",[e._v("props.xxx")]),e._v("的方式来读取到服务端获取的数据。")]),e._v(" "),n("h1",{attrs:{id:"本应用的数据预取"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#本应用的数据预取"}},[e._v("#")]),e._v(" 本应用的数据预取")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React from 'react';\nimport {\n    Link\n} from 'react-router-dom';\nimport './index.scss';\nimport img from '../../public/img.jpg';\nimport PageContainer from '../../common/components/page-container';\n\n\nfunction Index(props) {\n        return <div className=\"page-index-box\">\n            <p>首页</p>\n            <img src={img} />\n        </div>\n}\n\nIndex.getInitialProps= async ()=>{\n    console.log('fetch data index');\n    //模拟数据请求方法\n    //...\n\n    return {\n        page: {\n            tdk: {\n                title: '首页 - koa-react-ssr',\n                keywords: '关键词 - koa-react-ssr',\n                description: '描述'\n            }\n        }\n    };\n}\n\nexport default PageContainer(Index); \n\n")])])]),n("p",[e._v("同样为组件添加"),n("code",[e._v("getInitialProps")]),e._v("静态方法，服务端根据当前请求的"),n("code",[e._v("path")]),e._v("，调用"),n("code",[e._v("matchRoute")]),e._v("方法查找到对应的路由，得到具体的组件，判断组件上是否有"),n("code",[e._v("getInitialProps")]),e._v("此方法，然后进行数据预取。")]),e._v(" "),n("p",[e._v("最后把数据作为组件的"),n("code",[e._v("props")]),e._v("，在组件内可以通过"),n("code",[e._v("props.initialData")]),e._v("固定属性来获取。")]),e._v(" "),n("p",[e._v("整体来看，本应用的实现方式和"),n("code",[e._v("egg-react-ssr")]),e._v(","),n("code",[e._v("next.js")]),e._v("非常相似，可能这也是业内一种默认的通用做法吧。")]),e._v(" "),n("h1",{attrs:{id:"数据脱水"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据脱水"}},[e._v("#")]),e._v(" 数据脱水")]),e._v(" "),n("p",[e._v("从运行时的页面看下服务端直出数据的方式。")]),e._v(" "),n("ul",[n("li",[e._v("next.js")])]),e._v(" "),n("p",[e._v("数据直出到页面后，通过"),n("code",[e._v("script")]),e._v("标签来进行包裹，且"),n("code",[e._v('type="application/json"')]),e._v("，标签内直接是 "),n("code",[e._v("json")]),e._v("数据。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/15/16fa81cd98823742?w=919&h=365&f=png&s=132732",alt:""}})]),e._v(" "),n("ul",[n("li",[e._v("egg-react-ssr")])]),e._v(" "),n("p",[e._v("也是作为脚本加载,然后将数据保存在了"),n("code",[e._v("window.__INITIAL_DATA__")]),e._v("全局变量内。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/15/16fa81fc6d4b70de?w=808&h=449&f=png&s=87585",alt:""}})]),e._v(" "),n("ul",[n("li",[e._v("本应用")])]),e._v(" "),n("p",[e._v("为了防止"),n("code",[e._v("xss")]),e._v("攻击，将数据放在了"),n("code",[e._v("textarea")]),e._v("标签内，客户端使用前先进行一次获取。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/15/16fa82210490222e?w=796&h=326&f=png&s=80946",alt:""}})]),e._v(" "),n("p",[e._v("最后，本应用和他们两个框架的结果相同，只是表现形式不同。")]),e._v(" "),n("h1",{attrs:{id:"热更新"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#热更新"}},[e._v("#")]),e._v(" 热更新")]),e._v(" "),n("p",[e._v("都实现了模块热替换的功能。")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("next.js")]),e._v("采用"),n("code",[e._v("hot-middleware")]),e._v(" + "),n("code",[e._v("webpackHotDevClient.js")]),e._v("实现")]),e._v(" "),n("li",[n("code",[e._v("egg-react-ssr")]),e._v("采用社区成熟库"),n("code",[e._v("webpack-dev-server")]),e._v("实现，使用代理抹平了双服务模式，对外看到的是一个服务")]),e._v(" "),n("li",[e._v("本应用采用社区成熟库"),n("code",[e._v("webpack-dev-server")]),e._v("实现,未做代理转发，目前是使用双服务模式")])]),e._v(" "),n("p",[e._v("再次确认了下这两个框架是否支持了模块热更新的同时，是否能保存组件的状态，不过都不支持。")]),e._v(" "),n("h1",{attrs:{id:"路由配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#路由配置"}},[e._v("#")]),e._v(" 路由配置")]),e._v(" "),n("ul",[n("li",[e._v("next.js")])]),e._v(" "),n("p",[e._v("该框架是约定式路由，没有路由配置文件，只要在 "),n("code",[e._v("pages")]),e._v(" 文件夹下创建的文件，都会默认生成以文件名命名的路由,的确很方便，但是有些过度封装了。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/15/16fa88ea4d7e8fb5?w=239&h=264&f=png&s=22913",alt:""}})]),e._v(" "),n("ul",[n("li",[e._v("本骨架和"),n("code",[e._v("egg-react-ssr")]),e._v(" 直接使用"),n("code",[e._v("react-router")]),e._v(",依旧使用传统的"),n("code",[e._v("spa")]),e._v("应用的使用方式,手动编写路由规则，更加方便你去控制你的项目结构。")])]),e._v(" "),n("p",[n("code",[e._v("egg-react-ssr")]),e._v(" 配置方式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const resolvePath = (path) => require('path').resolve(__dirname, path)\n\nmodule.exports = {\n  type: 'ssr', // 指定运行类型可设置为csr切换为客户端渲染\n  routes: [\n    {\n      path: '/',\n      exact: true,\n      Component: () => (require('@/page/index').default), // 这里使用一个function包裹为了让它延迟require\n      controller: 'page',\n      handler: 'index'\n    },\n    {\n      path: '/news/:id',\n      exact: true,\n      Component: () => (require('@/page/news').default),\n      controller: 'page',\n      handler: 'index'\n    },\n    {\n      path: '/test',\n      exact: true,\n      Component: () => (require('@/page/test').default),\n      controller: 'page',\n      handler: 'index'\n    }\n  ],\n  baseDir: resolvePath('../'),\n  injectCss: [\n    `/static/css/Page.chunk.css`\n  ], // 客户端需要加载的静态样式表\n  injectScript: [\n    `<script src='/static/js/runtime~Page.js'><\/script>`,\n    `<script src='/static/js/vendor.chunk.js'><\/script>`,\n    `<script src='/static/js/Page.chunk.js'><\/script>`\n  ], // 客户端需要加载的静态资源文件表\n  serverJs: resolvePath(`../dist/Page.server.js`)\n}\n\n\n")])])]),n("p",[n("code",[e._v("本骨架")]),e._v("的配置方式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//路由配置文件\nimport React from 'react';\n\n//组件动态加载容器\nimport AsyncLoader from './async-loader';\n\nfunction pageNotFound() {\n    return <div>404页面</div>\n}\n\nexport default [\n    {\n        path: ['/','/index'],\n        component: AsyncLoader(() => import('../pages/index')),\n        exact:true\n    },\n    {\n        path: '/list',\n        component: AsyncLoader(() => import('../pages/list')),\n        exact: true\n    },\n    {\n        path: '/about',\n        component: AsyncLoader(() => import('../pages/about')),\n        exact: true\n    },\n    {\n        path: '*',\n        component: pageNotFound,\n        exact: true\n    }\n]\n\n")])])]),n("p",[e._v("这两者都属于集中式路由配置，更加直观和更灵活的进行配置。多人开发的时候可能维护上有点小瑕疵，容易有冲突。")]),e._v(" "),n("h1",{attrs:{id:"路由分割"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#路由分割"}},[e._v("#")]),e._v(" 路由分割")]),e._v(" "),n("h2",{attrs:{id:"next-js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#next-js"}},[e._v("#")]),e._v(" "),n("code",[e._v("next.js")])]),e._v(" "),n("p",[e._v("自动根据页面进行代码分割,无需配置。")]),e._v(" "),n("h2",{attrs:{id:"egg-react-ssr-实现方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#egg-react-ssr-实现方式"}},[e._v("#")]),e._v(" egg-react-ssr 实现方式")]),e._v(" "),n("p",[e._v("使用"),n("code",[e._v("react-loadable")]),e._v("库实现，实现方式和官方的方式不同。")]),e._v(" "),n("p",[e._v("没有将服务端"),n("code",[e._v("bundle")]),e._v("打包成多个文件,依然保持一个文件,因为服务端直接处理的是静态路由。")]),e._v(" "),n("p",[e._v("可以参考以下配置")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  {\n        path: '/news/:id',\n        exact: true,\n        Component: () => (__isBrowser__ ? require('react-loadable')({\n        loader: () => import(/* webpackChunkName: \"news\" */ '@/page/news'),\n        loading: function Loading () {\n            return React.createElement('div')\n        }\n        }) : require('@/page/news').default // 通过这种方式来让服务端bundle不要分块打包\n        ),\n        controller: 'page',\n        handler: 'index'\n    }\n\n")])])]),n("p",[e._v("这样配置有个坑，导致"),n("code",[e._v("Loadable")]),e._v("没办法预先知道你有哪些组件被包裹了，所以没办法直接调用"),n("code",[e._v("Loadable.preloadReady()")]),e._v("来预加载。")]),e._v(" "),n("p",[e._v("只能自己写一个"),n("code",[e._v("preloadComponen")]),e._v("方法来手动调用组件的"),n("code",[e._v("preload")]),e._v("方法了。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import { pathToRegexp } from 'path-to-regexp'\nimport cloneDeepWith from 'lodash.clonedeepwith'\nimport { RouteItem } from './interface/route'\n\nconst preloadComponent = async (Routes: RouteItem[]) => {\n  const _Routes = cloneDeepWith(Routes)\n  for (let i in _Routes) {\n    const { Component, path } = _Routes[i]\n    let activeComponent = Component()\n    if (activeComponent.preload && pathToRegexp(path).test(location.pathname)) {\n        // 只有在你访问的path和组件为同一个path才拿到真实的组件，其他情况还是返回Loadable Compoennt来让首屏不要去加载这些组件\n      activeComponent = (await activeComponent.preload()).default\n    }\n    _Routes[i].Component = () => activeComponent\n  }\n  return _Routes\n}\n\nexport {\n    preloadComponent\n}\n\n")])])]),n("p",[e._v("然后在客户端渲染的时候调用一下该方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const clientRender = async () => {\n //预加载\n  const clientRoutes = await preloadComponent(Routes)\n  // 客户端渲染||hydrate\n  ReactDOM[window.__USE_SSR__ ? 'hydrate' : 'render'](\n    <BrowserRouter>\n      {\n        // 使用高阶组件getWrappedComponent使得csr首次进入页面以及csr/ssr切换路由时调用getInitialProps\n        clientRoutes.map(({ path, exact, Component }) => {\n          const activeComponent = Component()\n          const WrappedComponent = getWrappedComponent(activeComponent)\n          const Layout = WrappedComponent.Layout || defaultLayout\n          return <Route exact={exact} key={path} path={path} render={() => <Layout><WrappedComponent /></Layout>} />\n        })\n      }\n    </BrowserRouter>\n    , document.getElementById('app'))\n\n  if (process.env.NODE_ENV === 'development' && module.hot) {\n    module.hot.accept()\n  }\n}\n\n")])])]),n("h2",{attrs:{id:"本骨架实现方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#本骨架实现方式"}},[e._v("#")]),e._v(" 本骨架实现方式")]),e._v(" "),n("p",[e._v("没有使用"),n("code",[e._v("react-loadable")]),e._v("，而是依据动态导入原理，包装了一个自定义异步组件加载器"),n("code",[e._v("AsyncBundle")]),e._v(",基本原理和"),n("code",[e._v("react-loadable")]),e._v("都是一样的。")]),e._v(" "),n("ol",[n("li",[e._v("通过高阶函数对返回一个函数组件，同时为函数添加异步属性,后面服务端和客户端预加载直接通过此属性进行判断")]),e._v(" "),n("li",[e._v("服务端代码会被打包成多个文件")]),e._v(" "),n("li",[e._v("服务端在请求前对组件进行预加载，也就是转换为静态组件")]),e._v(" "),n("li",[e._v("客户端代码会打包成多个文件")]),e._v(" "),n("li",[e._v("客户端"),n("code",[e._v("bundle")]),e._v("预加载后再渲染页面")])]),e._v(" "),n("p",[n("code",[e._v("容器组件")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\nimport React from 'react';\nimport LoadingCompoent from './loading-compoent';\n\n\n/**\n * 动态加载组件组的容器组件\n *\n * @class Bundle\n * @extends {Component}\n */\nexport default class AsyncBundle extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            mod: null\n        };\n    }\n\n    componentDidMount() {\n        if (!this.state.mod) {\n            this.load(this.props);\n        }\n    }\n\n    load(props) {\n        this.setState({\n            mod: null\n        });\n        //注意这里，使用Promise对象; mod.default导出默认\n        props.load().then((mod) => {\n            this.setState({\n                mod: mod.default ? mod.default : mod\n            });\n        });\n    }\n\n    render() {\n        return this.state.mod ? this.props.children(this.state.mod) : <LoadingCompoent/>;\n    }\n}\n\n\n")])])]),n("p",[n("code",[e._v("高阶函数，返回异步加载组件的包装组件")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import AsyncBundle from './async-bundle';\nimport proConfig from '../../share/pro-config';\nimport React from 'react';\nfunction AsyncLoader (loader) {\n\n    function asyncFn(props) {\n       return <AsyncBundle load={loader}>\n            {(Comp) => <Comp {...props} />}\n        </AsyncBundle>\n    }\n\n    //标记为异步组件，双端会根据此属性进行预加载\n    asyncFn[proConfig.asyncComponentKey] = true;\n\n    return asyncFn;\n}\n\nexport default AsyncLoader;\n\n\n")])])]),n("p",[n("code",[e._v("参考一个路由配置")])]),e._v(" "),n("p",[n("code",[e._v("AsyncLoader")]),e._v("函数内会标记此组件为异步组件")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    {\n        path: '/list',\n        component: AsyncLoader(() => import('../pages/list')),\n        exact: true\n    }\n\n")])])]),n("p",[n("code",[e._v("服务端组件预加载")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//将路由转换为静态路由，进行组件预加载\nasync function getStaticRoutes(routes) {\n\n    const key ='__dynamics_route_to_static';\n    if (global[key]){\n        console.log('cache route');\n        return global[key];\n    }\n\n    let len = routes.length,\n        i = 0;\n    const staticRoutes = [];\n\n    for (; i < len; i++) {\n        let item = routes[i];\n        if (checkIsAsyncRoute(item.component)) {\n            staticRoutes.push({\n                ...item,\n                ...{\n                    component: (await item.component().props.load()).default\n                }\n            });\n        } else {\n            staticRoutes.push({\n                ...item\n            });\n        }\n    }\n    global[key]=staticRoutes;\n    return staticRoutes; //返回静态路由\n}\n\n")])])]),n("p",[n("code",[e._v("客户端渲染")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\nfunction clientRender(routeList) {\n      \n\n        let initialData = JSON.parse(document.getElementById('ssrTextInitData').value);\n        window.__INITIAL_DATA__ = initialData;\n\n        //查找路由\n        let matchResult = matchRoute(document.location.pathname, routeList);\n        let { targetRoute } = matchResult;\n        if (targetRoute) {\n                //预加载完成后进行 render\n                if (targetRoute.component[proConfig.asyncComponentKey]) {\n                        targetRoute.component().props.load().then(res => {\n                                //异步组件加载完成后再渲染页面\n                                console.log('异步组件加载完成.....');\n                                renderDom(routeList,initialData);\n                        });\n                }\n\n        } else {\n                renderDom(routeList);\n\n        }\n}\n\n\n")])])]),n("h1",{attrs:{id:"css-资源"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#css-资源"}},[e._v("#")]),e._v(" CSS 资源")]),e._v(" "),n("p",[e._v("主要看下 "),n("code",[e._v("css")]),e._v(" 资源是如何处理的。")]),e._v(" "),n("ul",[n("li",[e._v("next.js")])]),e._v(" "),n("p",[e._v("该框架采用的是将"),n("code",[e._v("css")]),e._v("代码最终打包到一个文件内，作为资源进行加载。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/15/16fa831e6f7eea47?w=947&h=335&f=png&s=56977",alt:""}})]),e._v(" "),n("ul",[n("li",[e._v("egg-react-ssr")])]),e._v(" "),n("p",[e._v("也是最终将"),n("code",[e._v("css")]),e._v("代码提取到一个文件内。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/15/16fa835dc17b8b79?w=990&h=523&f=png&s=100547",alt:""}})]),e._v(" "),n("ul",[n("li",[e._v("本骨架实现方式")])]),e._v(" "),n("p",[e._v("我们目前有两种方式来处理"),n("code",[e._v("css")]),e._v("，一种是将代码进行提取到一个文件内作为资源进行加载。")]),e._v(" "),n("p",[e._v("另外一种是同构处理，页面初始化时服务端会搜集组件所需的 "),n("code",[e._v("css")]),e._v("，然后作为内联形式输出。")]),e._v(" "),n("p",[e._v("客户端渲染时会判断当前页面内是否已存在，只有不存在的情况下才会动态的插入样式。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/15/16fa839e647e8c39?w=811&h=572&f=png&s=148321",alt:""}})]),e._v(" "),n("p",[e._v("其实"),n("code",[e._v("css")]),e._v("同构处理的配置比较繁琐，直接提取为一个"),n("code",[e._v("css")]),e._v("文件也不失为一种便捷的处理方式。")]),e._v(" "),n("h1",{attrs:{id:"csr-ssr-双模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#csr-ssr-双模式"}},[e._v("#")]),e._v(" csr/ssr 双模式")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("next.js")]),e._v("是一个纯粹的"),n("code",[e._v("ssr")]),e._v("应用服务框架")]),e._v(" "),n("li",[e._v("本应用和"),n("code",[e._v("egg-react-ssr")]),e._v("即支持"),n("code",[e._v("ssr")]),e._v("也支持"),n("code",[e._v("csr")]),e._v("，且支持本地开发与生产环境"),n("code",[e._v("ssr/csr")]),e._v("两种渲染模式无缝切换")])]),e._v(" "),n("h1",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("本骨架的方案和"),n("code",[e._v("egg-react-ssr")]),e._v("比较相似，不过仍然有很多区别，还有很多地方可以借鉴和学习,但整体方向比较相似。")]),e._v(" "),n("p",[n("code",[e._v("next.js")]),e._v("是很成熟的"),n("code",[e._v("React SSR")]),e._v("应用开发框架，进行了大量的封装，很多东西都是黑盒的，只能按照他已有的模式进行开发，很难进行改造，且只支持"),n("code",[e._v("ssr")]),e._v("一种渲染模式。")]),e._v(" "),n("p",[e._v("比较方便的一个是它的约定式路由，根据你的目录和文件来处理的，不需要对路由进行维护，但是需要按照他的规则来创建文件，让你可以有更多时间来关注业务，而无需关注底层和配置。")]),e._v(" "),n("p",[e._v("我们的骨架是完全透明的，所有的配置和代码都在项目里，可以很方便的进行改造，路由仍然是传统的集中配置的路由，符合我们以往的开发习惯，但是多人开发可能有些问题，会产生冲突。不过也可以进行优化一下，在每个页面内增加一个路由配置，分开维护，最后通过一些手段将各个页面的路由合并为一个再使用。")]),e._v(" "),n("p",[e._v("另外本骨架同时支持"),n("code",[e._v("csr")]),e._v("和"),n("code",[e._v("ssr")]),e._v("两种渲染模式无缝切换。")]),e._v(" "),n("p",[e._v("生产环境来说，大家都采用的是将所有的"),n("code",[e._v("css")]),e._v("打包合并到为一个文件方式，如果项目过大的话 "),n("code",[e._v("css")]),e._v("文件可能会过大，导致页面渲染变慢。")]),e._v(" "),n("p",[e._v("所以本骨架使用同构对 "),n("code",[e._v("css")]),e._v("进行按需加载，消除了独立"),n("code",[e._v("css")]),e._v("文件，"),n("code",[e._v("css")]),e._v("代码在服务端渲染时会和"),n("code",[e._v("html")]),e._v("内容一起直出，客户端渲染时会动态的创建"),n("code",[e._v("style")]),e._v("标签插入到"),n("code",[e._v("head")]),e._v("内。")]),e._v(" "),n("p",[e._v("这样的方式可以让客户端加载更少的代码，不好的地方就是"),n("code",[e._v("css")]),e._v("代码会打包进"),n("code",[e._v("js")]),e._v("，修改"),n("code",[e._v("css")]),e._v("代码也会导致相关的"),n("code",[e._v("js")]),e._v("模块缓存失效，另外同构配置比较繁琐，坑较多，另外对代码侵入性较大，这也可能是其他框架不具备此能力的原因吧。")]),e._v(" "),n("p",[e._v("ok，对比完了，你怎么看呢？")]),e._v(" "),n("p",[e._v("感谢你的阅读。")]),e._v(" "),n("p",[e._v("如果有问题欢迎留言，也欢迎在留言区留下你的想法和思考。")])])}),[],!1,null,null,null);t.default=s.exports}}]);