(window.webpackJsonp=window.webpackJsonp||[]).push([[353],{709:function(e,n,s){"use strict";s.r(n);var r=s(42),t=Object(r.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"导读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#导读"}},[e._v("#")]),e._v(" 导读")]),e._v(" "),s("p",[e._v("本节标题：「建造毛坯」- 开发体验升级")]),e._v(" "),s("p",[e._v("本节主旨：工欲善其事，必先利其器，构建开发环境，提高开发体验，实现双端代码的自动编译以及服务的自动重启（手动实现多进程模型）")]),e._v(" "),s("p",[e._v("本节配套代码:")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr1",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr1"),s("OutboundLink")],1)]),e._v(" "),s("h1",{attrs:{id:"正文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[e._v("#")]),e._v(" 正文")]),e._v(" "),s("p",[e._v("前几节我们了解并实现了组件的直出和基本同构，完成了一个组件在服务端和浏览器端的渲染，并且实现了基本的交互-绑定事件。但这毕竟只能是算是"),s("code",[e._v("demo")]),e._v(",用于实际的项目开发还差的远。")]),e._v(" "),s("p",[e._v("所以从本节正式开始建造 "),s("code",[e._v("react ssr")]),e._v(" 同构应用开发骨架，如同开始建造房子的骨架。")]),e._v(" "),s("p",[e._v("要想这个骨架能用于实际项目开发，最基本的就是要开发方便，用起来省事儿，另一个就是具备一些基础的能力，让我们只专注于业务开发。")]),e._v(" "),s("p",[s("strong",[e._v("哪些能力呢？")])]),e._v(" "),s("p",[e._v("比如路由处理、副作用处理、seo支持、css 支持等。")]),e._v(" "),s("p",[e._v("现在从头开始吗？")]),e._v(" "),s("p",[e._v("前两节的内容呢？")]),e._v(" "),s("p",[e._v("当然不是，每一个小结都是层层递进的，都作为后面小结的基础，都是我们建造骨架的重要组成部分。")]),e._v(" "),s("p",[e._v("基于前几节的内容，同时为了方便后续的开发和调试，我们先来让这个项目的使用变得方便一些，就像是建房子的工具，不然咱们这个房子盖的太累，浪费时间和精力。")]),e._v(" "),s("p",[e._v("怎样才能更方便呢？")]),e._v(" "),s("h1",{attrs:{id:"工程化支持第一步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#工程化支持第一步"}},[e._v("#")]),e._v(" 工程化支持第一步")]),e._v(" "),s("p",[e._v("大家有没有发现我们现在的 "),s("code",[e._v("demo")]),e._v("存在严重的体验问题。")]),e._v(" "),s("p",[e._v("服务的运行需要经过多次手动操作。")]),e._v(" "),s("p",[e._v("前端代码的构建需要手动执行编译")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("npm run dev\n\n")])])]),s("p",[e._v("服务端代码的编译需要手动执行编译")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("npm run babel-node\n\n")])])]),s("p",[e._v("最后手动启动服务")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("node app.js\n\n")])])]),s("p",[e._v("后续的文件改动还要重新执行上面的步骤。")]),e._v(" "),s("p",[e._v("大家可以自行运行起来，体验一下这个过程。")]),e._v(" "),s("p",[s("code",[e._v("工欲善其事，必先利其器")])]),e._v(" "),s("p",[e._v("这种开发体验太差了，会浪费我们很多时间且严重影响心情，良好的开发体验可以让我们事半功倍，心情舒畅。")]),e._v(" "),s("p",[e._v("既然这样，那我们势必需要进行优化，通过程序或者工具来代替人工执行，以达到提升效率的目的。")]),e._v(" "),s("h2",{attrs:{id:"确定优化目标"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#确定优化目标"}},[e._v("#")]),e._v(" 确定优化目标")]),e._v(" "),s("p",[e._v("如何实现这个优化呢？")]),e._v(" "),s("p",[e._v("做之前我们先进行问题分析，然后设计出一套解决方案。")]),e._v(" "),s("p",[e._v("首先要明确我们想达到的一个具体的目标。")]),e._v(" "),s("ul",[s("li",[e._v("前后端代码可以自动编译")]),e._v(" "),s("li",[e._v("每次修改代码，"),s("code",[e._v("node")]),e._v(" 服务可以自动重启")])]),e._v(" "),s("p",[e._v("另外我也不想自己刷新页面，所以热更新也是必须的，不过本节不打算直接介绍热更新，在后面章节会介绍。")]),e._v(" "),s("h2",{attrs:{id:"实现思路分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现思路分析"}},[e._v("#")]),e._v(" 实现思路分析")]),e._v(" "),s("p",[s("strong",[e._v("前端代码构建体验优化")])]),e._v(" "),s("p",[e._v("前端代码的构建可以使用 "),s("code",[e._v("webpack")]),e._v(" 搞定，开启 "),s("code",[e._v("watch")]),e._v(" 功能就可以了，更改了文件就会自动打包。")]),e._v(" "),s("p",[s("strong",[e._v("后端代码构建")])]),e._v(" "),s("p",[e._v("后端代码这里分为两部分，一个是用来处理请求的 "),s("code",[e._v("node")]),e._v(" 代码，只运行于服务端。")]),e._v(" "),s("p",[e._v("另一部分就是组件以及组件相关的代码，也需要在服务端运行来完成组件的 "),s("code",[e._v("ssr")]),e._v("，所以我们也需要打包一份给服务端使用。")]),e._v(" "),s("p",[e._v("在上一节我们使用的是"),s("code",[e._v("babel cli")]),e._v("来编译的，当然这是一个有效的方法，还有一个更好的办法就是使用"),s("code",[e._v("webpack")]),e._v("来编译。")]),e._v(" "),s("p",[e._v("诶？也能用"),s("code",[e._v("webpapck")]),e._v("?")]),e._v(" "),s("p",[e._v("不要以为"),s("code",[e._v("webpack")]),e._v("只能用于前端代码的构建，一切皆模块，只要是 "),s("code",[e._v("js")]),e._v(" 代码都可以被编译，只是编译的目标平台不同而已。")]),e._v(" "),s("p",[e._v("使用 "),s("code",[e._v("webpack")]),e._v(" 编译，并且开启"),s("code",[e._v("watch")]),e._v("监听，就能做到实时编译了。")]),e._v(" "),s("p",[s("strong",[e._v("node 服务自启")])]),e._v(" "),s("p",[s("code",[e._v("node")]),e._v(" 服务这里要分两部分来看待。")]),e._v(" "),s("ul",[s("li",[e._v("(1)服务的启动")]),e._v(" "),s("li",[e._v("(2)服务的自启")])]),e._v(" "),s("p",[e._v("单纯的服务启动和自启，很简单，可以使用工具"),s("code",[e._v("nodemon")]),e._v("来完成，不过除了使用工具外是否还有其他的方法处理？")]),e._v(" "),s("p",[s("strong",[e._v("我们可以使用自定义进程")])]),e._v(" "),s("p",[e._v("让一个服务运行在我们创建的进程中，然后在适当的时机杀掉进程（关闭服务），重新创建一个服务进程启动服务（重启启动）。")]),e._v(" "),s("p",[s("strong",[e._v("综合分析")])]),e._v(" "),s("p",[e._v("上面我们分析了各个环节的实现思路，单纯的实现每一步应该没什么难度，但是多个操作如何才能统一为一个操作呢？")]),e._v(" "),s("p",[e._v("也就是可以通过一个命令来启动前端代码编译和监听、后端代码编译和监听、同时启动 "),s("code",[e._v("node")]),e._v(" 服务并且能够自动重启。")]),e._v(" "),s("p",[e._v("好了，问题很明确了，实现方案也有了。")]),e._v(" "),s("h2",{attrs:{id:"自定义进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义进程"}},[e._v("#")]),e._v(" 自定义进程")]),e._v(" "),s("p",[e._v("上面的多个操作可以看做是独立的服务，可以让每个服务运行在独立的进程中，然后利用进程间通信来达到我们要的效果。")]),e._v(" "),s("p",[s("strong",[e._v("启动阶段")])]),e._v(" "),s("p",[e._v("在这个阶段启动各个服务。")]),e._v(" "),s("p",[s("strong",[e._v("监听阶段")])]),e._v(" "),s("p",[s("code",[e._v("webpack")]),e._v("开启 "),s("code",[e._v("watch")]),e._v("选项后可以自动编译，这个不用我们来干预。")]),e._v(" "),s("p",[s("code",[e._v("node")]),e._v("服务的自启，可以在服务端代码构建完成的时候执行。")]),e._v(" "),s("h1",{attrs:{id:"相关实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#相关实现"}},[e._v("#")]),e._v(" 相关实现")]),e._v(" "),s("h2",{attrs:{id:"项目目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#项目目录"}},[e._v("#")]),e._v(" 项目目录")]),e._v(" "),s("p",[e._v("先来规定下本骨架的目录结构,可以大概的了解下都包含哪些资源。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("├── dist // 生产环境打包后的资源存放目录\n│ ├── static //打包的静态资源文件\n│ | ├── index.js // 打包后的文件\n│ ├── server //服务端文件目录\n│ | ├── app.js //node server 启动入口\n├── src // 源码目录\n│ ├── client //前端代码\n│ │ ├── app // 前端渲染入口\n│ | ├── pages // 业务页面\n│ │ | ├── index //默认首页\n│ │ ├── router // 路由配置\n│ │ ├── common // 存放通用组件和通用模块\n│ ├── server // node 代码\n│ │ ├── app // 服务入口 \n│ │ ├── middlewares //中间件\n│ │ | ├──  react-ssr.js //ssr 中间件\n│ ├── share // 双端共享的代码可以放这里\n├── webpack //构建配置\n│ ├── scripts //构建脚本目录\n│ │ | ├──  start.js //开发环境的所有服务启动入口\n│ ├── webpack.dev.config.js //前端代码的开发环境编译配置\n│ ├── webpack.server.config.js 服务端代码的编译配置\n\n\n")])])]),s("h2",{attrs:{id:"确定执行命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#确定执行命令"}},[e._v("#")]),e._v(" 确定执行命令")]),e._v(" "),s("p",[e._v("开发环境的启动入口")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("npm run dev // 用来启动开发环境\n\n")])])]),s("p",[e._v("对应的"),s("code",[e._v("package.json")]),e._v("配置")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('"dev": "node webpack/scripts/start.js",\n\n')])])]),s("p",[s("strong",[e._v("前端代码编译开启 watch")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(' "scripts": {\n    //...\n    "fe:watch": "webpack --config  ./webpack/webpack.dev.config.js --watch",\n    //...\n  },\n\n')])])]),s("p",[s("strong",[e._v("服务端代码打包配置")])]),e._v(" "),s("p",[e._v("和前端的打包配置差不多,需要配置"),s("code",[e._v("target=node")]),e._v(", 增加"),s("code",[e._v("externals")]),e._v(" 选项，使用"),s("code",[e._v("webpack-node-externals")]),e._v("来排除不需要打包的模块，因为 "),s("code",[e._v("node")]),e._v(" 端会自动载入这些包，可以让打包的文件更小。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// ./webpack/webpack.server.config\n\n//webpack 配置文件\nconst path = require('path')\nconst nodeExternals = require('webpack-node-externals')\nconst webpack = require('webpack');\nconst resolvePath = (pathstr) => path.resolve(__dirname, pathstr);\n\nprocess.env.BABEL_ENV = 'node';//设置 babel 的运行的环境变量\n\nconst isProd=process.env.NODE_ENV==='production';\n\nmodule.exports = {\n    target: 'node',\n    entry: resolvePath('../src/server/app/index.js'),//入口文件\n    output: {\n        filename: 'app.js',\n        path: resolvePath('../dist/server')\n    },\n    externals: [nodeExternals()],\n    module: {\n        rules: [{\n            test: /\\.jsx?$/,\n            loader: 'babel-loader',\n            exclude: /node_modules/\n        }\n        ]\n    }\n}\n\n\n")])])]),s("p",[s("strong",[e._v("通过 api 方式启动服务端代码监听")])]),e._v(" "),s("p",[e._v("因为我们需要监听服务端代码的构建过程，当每次编译完成时，通知主进程重启 "),s("code",[e._v("node")]),e._v(" 服务，"),s("code",[e._v("cli")]),e._v(" 模式下无法满足需要，所以需要调用"),s("code",[e._v("api")]),e._v(" 来执行构建监听。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("\n// ./webpack/scripts/svr-code-watch.js\n\n//基于 webpack  开启对服务端代码的编译和监听 \n//配置文件为 webpack.server.config.js\n\nconst webpack  = require('webpack');\nconst config =  require('../webpack.server.config');\nconst constantCode = require('./constant');\nconfig.mode='development';//设置编译模式\n\n\n//编译对象\nconst compiler = webpack(config);\n\nconst watching = compiler.watch({\n    aggregateTimeout: 300, // 类似节流功能,聚合多个更改一起构建\n    ignored: /node_modules/, //排除文件\n    poll: 2000, //轮训的方式检查变更 单位：秒  ,如果监听没生效，可以试试这个选项.\n}, (err, stats) => {\n   \n    let json = stats.toJson(\"minimal\");\n    if(json.errors){\n        json.errors.forEach(item => {\n            console.log(item);\n        });\n    }\n    if (json.warnings) {\n        json.warnings.forEach(item => {\n            console.log(item);\n        });\n    }\n\n    //定一个常量，编译完成后 通知主进程来重启node 服务，主进程通过此标志来进行判断是否重启\n    console.log(constantCode.SVRCODECOMPLETED);\n});\n\ncompiler.hooks.done.tap('done',function (data) {\n    console.log('\\n svr code done' ); //编译完成动作\n});\n\n//收到退出信号 退出自身进程\nprocess.stdin.on('data', function (data) {\n    if (data.toString() === 'exit') {\n        process.exit();\n    }\n});\n\n")])])]),s("p",[s("strong",[e._v("ps: 文件 './constant'说明")])]),e._v(" "),s("p",[e._v("该文件用来存放开发环境构建过程中的常量")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// ./webpack/scripts/constant.js \n\n//用于开发环境的构建过程中的常量\nmodule.exports = {\n    SVRCODECOMPLETED:'SVRCODECOMPLETED',//表示服务端代码编译完成的标志\n}\n\n")])])]),s("p",[s("strong",[e._v("配置服务端代码构建执行命令")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('  "scripts": {\n   //...\n    "svr:watch": "node ./webpack/scripts/svr-code-watch.js"\n  },\n\n')])])]),s("p",[s("strong",[e._v("创建node 服务启动入口")])]),e._v(" "),s("p",[e._v("为了方便控制，我们单独创建一个开发环境的"),s("code",[e._v("node")]),e._v(" 服务启动入口,引入打包后的入口文件即可。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// ./webpack/svr-dev-server.js\n\n//开发环境 node 服务启动入口\n\n//公用配置文件，定义一些通用的数据\nconst proConfig = require('../../src/share/pro-config');\n\n//node server port\nconst nodeServerPort = proConfig.nodeServerPort;\n\n\n//启动前检查端口是否占用，杀掉占用端口的进程\nrequire('./free-port')(nodeServerPort);\n\n//引入打包后的入口文件,这个入口我们在 webpack 配置中已设置好\nrequire('../../dist/server/app');\n\n\n")])])]),s("p",[s("strong",[e._v("最终编译入口处理")])]),e._v(" "),s("p",[e._v("通过创建子进程的方式，整合多个服务到统一入口。")]),e._v(" "),s("p",[e._v("使用"),s("code",[e._v("const {spawn} = require('child_process');//用于创建子进程")]),e._v(" 来创建子进程，此方式为异步执行。")]),e._v(" "),s("p",[e._v("然后通过子进程的"),s("code",[e._v("std")]),e._v("进行通信，达到重启 "),s("code",[e._v("node")]),e._v("服务的作用。")]),e._v(" "),s("p",[s("code",[e._v("启动入口 ./webpack/scripts/start.js")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("\nconst {spawn} = require('child_process');//用于创建子进程\nconst constantCode = require('./constant');\nconst chalk = require('chalk');//为控制台输出的信息增加点色彩\nconst log = console.log;\nconst proConfig  = require('../../src/share/pro-config');//双端的配置文件，配置一些基础参数，具体说明在后面\n\n//node server port\nconst nodeServerPort = proConfig.nodeServerPort;\n\nlog(chalk.red('servers starting....'));\n\n//前端代码构建 服务进程\nconst feCodeWatchProcess = spawn('npm', ['run', 'fe:watch'],{stdio:'inherit'});\n\n//服务端代码监控和编译进程\nconst svrCodeWatchProcess = spawn('npm', ['run', 'svr:watch']);\n\n//node 服务进程\nlet nodeServerProcess=null;\n//启动 node 服务\nconst startNodeServer = () => { //重启 node 服务 \n    nodeServerProcess && nodeServerProcess.kill();\n    nodeServerProcess = spawn('node',['./webpack/scripts/svr-dev-server.js']);\n    nodeServerProcess.stdout.on('data', print);\n}\n\n//控制台输出信息\nfunction print(data) {\n    let str = data.toString();\n    if (str.indexOf(constantCode.SVRCODECOMPLETED) > -1) { //接收到服务端代码编译完成的通知\n        startNodeServer();//重启 node 服务\n    } else {\n        console.log(str);\n    }\n}\n\n//监听服务端代码构建服务的对外输出  stdout 事件\nsvrCodeWatchProcess.stdout.on('data',print);\n\n//杀掉子进程\nconst killChild=()=>{\n    svrCodeWatchProcess && svrCodeWatchProcess.kill();\n    nodeServerProcess && nodeServerProcess.kill();\n    feCodeWatchProcess && feCodeWatchProcess.kill();\n}\n\n//主进程关闭退出子进程\nprocess.on('close', (code) => {\n    console.log('main process  close', code);\n    killChild();\n});\n//主进程关闭退出子进程\nprocess.on('exit', (code) => {\n    console.log('main process  exit', code);\n    killChild();\n});\n\n//非正常退出情况\nprocess.on('SIGINT', function () {\n    svrCodeWatchProcess.stdin.write('exit', (error) => {\n        console.log('svr code watcher process exit!');\n    });\n    killChild();\n});\n\n\n")])])]),s("p",[s("strong",[e._v("ps:文件（'../../src/share/pro-config'）说明")])]),e._v(" "),s("p",[e._v("该文件是服务端和客户端的公用基础配置文件，所以放在了share目录下")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// ./src/share/pro-config.js\n\n//双端公用的配置文件\nmodule.exports = {\n    wdsPort:9002,//webpack dev server 服务的运行端口\n    nodeServerPort:9001,//node server 的监听端口\n}\n\n\n")])])]),s("p",[s("code",[e._v("看下最终运行效果")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/12/30/16f56960104bf971?w=750&h=305&f=png&s=66992",alt:""}})]),e._v(" "),s("p",[e._v("服务端代码的构建日志信息已隐藏，只在有错误的时候才会输出，现在在编译完成时会通知主进程重启 "),s("code",[e._v("node")]),e._v(" 服务。")]),e._v(" "),s("p",[e._v("到这里，我们就基本上完成了一个重要的开发体验升级，为我们后续的进展提供了便利。")]),e._v(" "),s("h1",{attrs:{id:"另外一种方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#另外一种方式"}},[e._v("#")]),e._v(" 另外一种方式")]),e._v(" "),s("p",[e._v("下面给大家简单介绍另外一种方式")]),e._v(" "),s("p",[e._v("可以使用"),s("code",[e._v("npm-run-all")]),e._v("工具,该工具可以同时并行多个"),s("code",[e._v("npm")]),e._v(" 命令,只需要配置下就可以了。")]),e._v(" "),s("p",[e._v("举个栗子")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("npm-run-all --parallel fe:watch svr:watch node:server\n\n")])])]),s("p",[e._v("其实本质也是通过进程来完成的。")]),e._v(" "),s("p",[e._v("不过对于我个人来说，还是喜欢能自己实现的尽量自己来实现，这样可以学以致用，学习的东西不实践的话永远只是纸上谈兵。")]),e._v(" "),s("p",[e._v("当然工具的使用也必不可少，看具体的情况，因为它确实能够帮我们大大提高效率。")]),e._v(" "),s("h1",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),s("p",[e._v("这一节我们逐步分析并实现了一个基本的工程化的搭建和配置，让我们的项目在开发和调试的时候更加便利。")]),e._v(" "),s("p",[e._v("对于实现方式，本文算是其中一种，也可能还有其他方法，但是思想才是最重要的。只要有了思路，相信后面的实现也只是个时间问题。")]),e._v(" "),s("p",[e._v("我们应用骨架，走到这里就方便多了，但是还不够，不够彻底。")]),e._v(" "),s("p",[e._v("现在更改了代码，还需要刷新页面来查看效果，所以后面还需要加入热更新机制，这个优化我们后面再慢慢聊。")]),e._v(" "),s("p",[e._v("本节完整代码:")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr1",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr1"),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("感谢你的阅读。")]),e._v(" "),s("p",[e._v("如果有问题欢迎留言，也欢迎在留言区留下你的想法和思考。")])])}),[],!1,null,null,null);n.default=t.exports}}]);