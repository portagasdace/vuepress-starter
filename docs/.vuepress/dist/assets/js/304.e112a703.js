(window.webpackJsonp=window.webpackJsonp||[]).push([[304],{660:function(n,l,a){"use strict";a.r(l);var e=a(42),t=Object(e.a)({},(function(){var n=this,l=n.$createElement,a=n._self._c||l;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("blockquote",[a("p",[n._v("本节代码对应 GitHub 分支: chapter4")])]),n._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/sanyuan0704/react-cloud-music/tree/chapter4",target:"_blank",rel:"noopener noreferrer"}},[n._v("仓库传送门"),a("OutboundLink")],1)]),n._v(" "),a("h2",{attrs:{id:"上拉-下拉加载更多实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上拉-下拉加载更多实现"}},[n._v("#")]),n._v(" 上拉 / 下拉加载更多实现")]),n._v(" "),a("p",[n._v("在这里 Scroll 基础组件的作用就展现出来了。之前我们封装了 Scroll 组件，监听上拉 / 下拉刷新的功能已编写完成，但是相应的 loading 效果并没有考虑。现在，我们就来先完善 loading 效果。")]),n._v(" "),a("p",[n._v("首先引入 loading 组件：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("import Loading from '../loading/index';\n\n")])])]),a("p",[n._v("将 return 部分的代码修改为:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('const PullUpdisplayStyle = pullUpLoading ? {display: ""} : { display:"none" };\nconst PullDowndisplayStyle = pullDownLoading ? { display: ""} : { display:"none" };\nreturn (\n  <ScrollContainer ref={scrollContaninerRef}>\n    {props.children}\n    {/* 滑到底部加载动画 */}\n    <PullUpLoading style={ PullUpdisplayStyle }><Loading></Loading></PullUpLoading>\n    {/* 顶部下拉刷新动画 */}\n    <PullDownLoading style={ PullDowndisplayStyle }><LoadingV2></LoadingV2></PullDownLoading>\n  </ScrollContainer>\n);\n\n')])])]),a("p",[n._v("注意 PullUpdisplayStyle 和 PullDowndisplayStyle 都是外部传入的，这就方便了我们控制 loading 的显示和隐藏。")]),n._v(" "),a("p",[n._v("其中 Loading 组件即之前编写的两圆交错的涟漪效果组件，但 LoadingV2 并没有编写，现在就花一点时间来开发第二个 Loading 效果。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("//baseUI/loading-v2/index.js\nimport React from 'react';\nimport styled, {keyframes} from'styled-components';\nimport style from '../../assets/global-style'\n\nconst dance = keyframes`\n    0%, 40%, 100%{\n      transform: scaleY (0.4);\n      transform-origin: center 100%;\n    }\n    20%{\n      transform: scaleY (1);\n    }\n`\nconst Loading = styled.div`\n    height: 10px;\n    width: 100%;\n    margin: auto;\n    text-align: center;\n    font-size: 10px;\n    >div {\n      display: inline-block;\n      background-color: ${style [\"theme-color\"]};\n      height: 100%;\n      width: 1px;\n      margin-right:2px;\n      animation: ${dance} 1s infinite;\n    }\n    >div:nth-child (2) {\n      animation-delay: -0.4s;\n    }\n    >div:nth-child (3) {\n      animation-delay: -0.6s;\n    }\n    >div:nth-child (4) {\n      animation-delay: -0.5s;\n    }\n    >div:nth-child (5) {\n      animation-delay: -0.2s;\n    } \n\n`\n\nfunction LoadingV2 () {\n  return (\n    <Loading>\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n      <span > 拼命加载中...</span>\n    </Loading>\n  );\n}\n \nexport default React.memo (LoadingV2);\n\n")])])]),a("p",[n._v("OK, 现在在 scroll 组件中引入。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("//scroll/index.js\nimport Loading2 from '../loading-v2/index';\n\n")])])]),a("p",[n._v("接下来，我们在 Singers/index.js 中，传入相应的参数即可。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("<Scroll\n  pullUp={ handlePullUp }\n  pullDown = { handlePullDown }\n  pullUpLoading = { pullUpLoading }\n  pullDownLoading = { pullDownLoading }\n>\n  { renderSingerList () }\n</Scroll>\n\n")])])]),a("p",[n._v("现在 handlePullUp 和 handlePullDown 两个方法还没有定义，添加如下:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const handlePullUp = () => {\n  pullUpRefreshDispatch (category, alpha, category === '', pageCount);\n};\n\nconst handlePullDown = () => {\n  pullDownRefreshDispatch (category, alpha);\n};\n\n")])])]),a("p",[n._v("现在试一试上拉下拉，相应的 loading 动画能够出现了，同时数据也能正常加载。 对了，现在进场的 loading 效果还没有实现，我们在 Singers/index.js 中加入:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("import Loading from '../../baseUI/loading';\n//...\n//ListContainer 标签中\n<Loading show={enterLoading}></Loading>\n\n")])])]),a("p",[n._v("这样，当你第一次打开列表页或者切换不同分类的时候，会有 loading 效果出现，和我们的预期一致。")]),n._v(" "),a("h2",{attrs:{id:"相关优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关优化"}},[n._v("#")]),n._v(" 相关优化")]),n._v(" "),a("h3",{attrs:{id:"图片懒加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图片懒加载"}},[n._v("#")]),n._v(" 图片懒加载")]),n._v(" "),a("p",[n._v("同样是引入 react-lazyload, 在 Singers/index.js 作如下修改:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 首先引入\nimport  LazyLoad, {forceCheck} from \'react-lazyload\';\n\n// 包裹 img 标签\n<LazyLoad placeholder={<img width="100%" height="100%" src={require (\'./singer.png\')} alt="music"/>}>\n  <img src={`${item.picUrl}?param=300x300`} width="100%" height="100%" alt="music"/>\n</LazyLoad>\n\n<Scroll\n  //...\n  onScroll={forceCheck}\n>\n</Scroll>\n\n')])])]),a("p",[n._v("现在懒加载的效果就完成了。")]),n._v(" "),a("h3",{attrs:{id:"防抖处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#防抖处理"}},[n._v("#")]),n._v(" 防抖处理")]),n._v(" "),a("p",[n._v("当你频繁地下拉时，事实上事件回调函数也会被频繁触发，导致发送很多无意义的请求。因此这里对 Scroll 基础组件做一下防抖处理。")]),n._v(" "),a("p",[n._v("防抖函数写在 api/utils.js 中，")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\n// 防抖函数\nexport const debounce = (func, delay) => {\n  let timer;\n  return function (...args) {\n    if (timer) {\n      clearTimeout (timer);\n    }\n    timer = setTimeout (() => {\n      func.apply (this, args);\n      clearTimeout (timer);\n    }, delay);\n  }\n}\n\n")])])]),a("p",[n._v("然后在 scroll/index.js 中:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("import { debounce } from \"../../api/utils\";\n\n//...\n\nlet pullUpDebounce = useMemo (() => {\n  return debounce (pullUp, 300)\n}, [pullUp]);\n// 千万注意，这里不能省略依赖，\n// 不然拿到的始终是第一次 pullUp 函数的引用，相应的闭包作用域变量都是第一次的，产生闭包陷阱。下同。\n\nlet pullDownDebounce = useMemo (() => {\n  return debounce (pullDown, 300)\n}, [pullDown]);\n//...\n// 之后直接调用 useMemo 返回的函数\n// 滑动到底部\nuseEffect(() => {\n    if(!bScroll || !pullUp) return;\n    const handlePullUp = () => {\n      //判断是否滑动到了底部\n      if(bScroll.y <= bScroll.maxScrollY + 100){\n        pullUpDebounce();\n      }\n    };\n    bScroll.on('scrollEnd', handlePullUp);\n    // 解绑\n    return () => {\n      bScroll.off('scrollEnd', handlePullUp);\n    }\n}, [pullUp, pullUpDebounce, bScroll]);\n\n// 判断用户的下拉动作\nuseEffect(() => {\n    if(!bScroll || !pullDown) return;\n    const handlePullDown = (pos) => {\n      //判断用户的下拉动作\n      if(pos.y > 50) {\n        pullDownDebounce();\n      }\n    };\n    bScroll.on('touchEnd', handlePullDown);\n    return () => {\n      bScroll.off('touchEnd', handlePullDown);\n    }\n}, [pullDown, pullDownDebounce, bScroll]);\n\n")])])]),a("p",[n._v("这样当你频繁上拉下拉的时候就不会频繁触发回调了。")]),n._v(" "),a("blockquote",[a("p",[n._v("思考题：当我们切换组件的时候，事实上现在的 category 和 alpha 会丢失，如果想要切换组件后仍然能够缓存 category 和 alpha 的值应该怎么做？可以自己动手试试看。")])])])}),[],!1,null,null,null);l.default=t.exports}}]);