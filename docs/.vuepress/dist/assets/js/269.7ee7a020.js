(window.webpackJsonp=window.webpackJsonp||[]).push([[269],{625:function(e,t,s){"use strict";s.r(t);var r=s(42),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"编写兼容-html-与-json-的视图类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编写兼容-html-与-json-的视图类"}},[e._v("#")]),e._v(" 编写兼容 HTML 与 JSON 的视图类")]),e._v(" "),s("h2",{attrs:{id:"改造原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#改造原理"}},[e._v("#")]),e._v(" 改造原理")]),e._v(" "),s("h3",{attrs:{id:"为什么要改写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要改写"}},[e._v("#")]),e._v(" 为什么要改写")]),e._v(" "),s("p",[e._v("后面的章节中，我们将会为 Scrapyd 加上"),s("strong",[e._v("访问权限访问控制")]),e._v("的功能。而权限既要能够在请求 HTML 资源的时候发挥作用，也要在请求 JSON 资源的时候发挥作用，当你提交正确的验证信息，它会让你通过验证并返回正确的结果（这个结果有可能是 HTML 也有可能是 JSON ），所以这里就需要编写一个兼容 HTML 与 JSON 的视图类，并且对现有的 Home、Jobs 和其他 API 进行些许调整，以达到目的。")]),e._v(" "),s("h3",{attrs:{id:"原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),s("p",[e._v("主要是利用 Python 类的"),s("strong",[e._v("继承和多态")]),e._v("这两个特性")]),e._v(" "),s("blockquote",[s("p",[e._v("继承可以把父类的所有功能都直接拿过来，这样就不必从 0 做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写；")])]),e._v(" "),s("blockquote",[s("p",[e._v("有了继承，才能有多态。在调用类实例方法的时候，尽量把变量视作父类。这样，所有子类类型都可以正常被接收；")])]),e._v(" "),s("p",[e._v("在这里，笔者需要自定义一个类，它继承"),s("code",[e._v("WsResource")]),e._v("和"),s("code",[e._v("resource.Resource")]),e._v("这两个类，这样即可拥有他们的特性，然后笔者通过重写 render 就可以达到目的。")]),e._v(" "),s("h2",{attrs:{id:"改造代码和步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#改造代码和步骤"}},[e._v("#")]),e._v(" 改造代码和步骤")]),e._v(" "),s("h3",{attrs:{id:"自定义类与继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义类与继承"}},[e._v("#")]),e._v(" 自定义类与继承")]),e._v(" "),s("p",[e._v("在"),s("code",[e._v("webservice.py")]),e._v("中，笔者创建了一个名为"),s("code",[e._v("CustomResource")]),e._v("的类，它继承自 JsonResource 和 resource.Resource。由于 Python 中类继承的"),s("code",[e._v("__mro__")]),e._v("顺序存在，所以继承顺序不能随意，必须是"),s("code",[e._v("JsonResource")]),e._v(" 在前面，代码如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("from twisted.web import resource\n\nclass CustomResource(JsonResource, resource.Resource):\n\n")])])]),s("p",[e._v("上面也提到过，通过继承的方式，我们可以让新的子类具备父类的方法及特性，还可以通过重写或者新增方法来增加新特性。")]),e._v(" "),s("h3",{attrs:{id:"重写-render-与-init"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重写-render-与-init"}},[e._v("#")]),e._v(" 重写 render 与 init")]),e._v(" "),s("p",[e._v("因为继承了两个类，根据 Python 的"),s("code",[e._v("__mro__")]),e._v("顺序，如果不重写的话是有可能出现问题的，所以笔者需要先重写"),s("code",[e._v("__init__")]),e._v("方法")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("def __init__(self, root):\n    JsonResource.__init__(self)\n    self.root = root\n\n")])])]),s("p",[e._v("其实就是直接使用了 JsonResource 的"),s("code",[e._v("__init__")]),e._v("方法。")]),e._v(" "),s("p",[e._v("接着重写 render，以实现两种视图数据的兼容")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("def render(self, txrequest):\n    try:\n        return JsonResource.render(self, txrequest).encode('utf-8')\n    except Exception:\n        return self.content\n\n")])])]),s("p",[e._v("GIF 动态图中完整的演示了 "),s("code",[e._v("CustomResource")]),e._v(" 类的编码过程：")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/10/11/166627302981415b?w=1365&h=862&f=gif&s=2830332",alt:""}})]),e._v(" "),s("p",[e._v("通过"),s("code",[e._v("try except")]),e._v("的方式来实现，优先返回 json 格式数据，如果出现错误则返回"),s("code",[e._v("self.content")]),e._v("（原 JsonResource 在 except 中返回错误信息）。")]),e._v(" "),s("h3",{attrs:{id:"新视图类的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#新视图类的使用"}},[e._v("#")]),e._v(" 新视图类的使用")]),e._v(" "),s("p",[e._v("编写完自定义的视图类后，笔者将在"),s("code",[e._v("website.py")]),e._v("中使用，首先将它引入")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("from .webservice import CustomResource\n\n")])])]),s("p",[e._v("接着将 Home 方法的父类由 resource.Resource 改为"),s("code",[e._v("CustomResource")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Home(CustomResource)\n\n")])])]),s("p",[e._v("再在 render_GET 中将想要返回的页面赋值给变量"),s("code",[e._v("self.content")]),e._v("，最后将"),s("code",[e._v("self.content")]),e._v("返回")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("def render_GET(self, request):\n    ……\n    self.content = s.encode('utf-8')\n    return self.content\n\n")])])]),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/10/11/166627fda1053072?w=1170&h=781&f=gif&s=3507135",alt:""}})]),e._v(" "),s("blockquote",[s("p",[e._v("小提示：如果是 JSON 视图，直接继承 CustomResource 即可，Return 处无需改动。")])]),e._v(" "),s("p",[e._v("这样就完成了，当我们访问 Home 类的时候，它会根据父类 render 的设定优先返回 JSON 数据，现在是非 JSON 数据，所以会报错。进入 except 流程并返回 self.content，这样就完成了兼容 HTML 视图与 JSON 视图的自定义类"),s("code",[e._v("CustomResource")]),e._v("的编写。")]),e._v(" "),s("p",[e._v("在"),s("code",[e._v("Jobs")]),e._v("和其他 API 上的使用方法与在"),s("code",[e._v("Home")]),e._v("上的的使用方法是一样的。")]),e._v(" "),s("h2",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),s("p",[e._v("本节先理解改写原因和原理将逻辑整理清晰，然后通过实际的编码，实现了兼容 HTML 与 JSON 的视图类，为后面权限访问控制以及 Scrapyd 界面改造打下了基础。")])])}),[],!1,null,null,null);t.default=a.exports}}]);