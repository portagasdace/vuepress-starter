(window.webpackJsonp=window.webpackJsonp||[]).push([[324],{680:function(t,e,n){"use strict";n.r(e);var s=n(42),i=Object(s.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("blockquote",[n("p",[t._v("本节代码对应 GitHub 分支: chapter9")])]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/sanyuan0704/react-cloud-music/tree/chapter9",target:"_blank",rel:"noopener noreferrer"}},[t._v("仓库传送门"),n("OutboundLink")],1)]),t._v(" "),n("h1",{attrs:{id:"歌词解析插件封装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#歌词解析插件封装"}},[t._v("#")]),t._v(" 歌词解析插件封装")]),t._v(" "),n("p",[t._v("在封装插件之前，我想有必要给大家看一看歌词数据的格式。")]),t._v(" "),n("p",[t._v("在 Player/index.js 中：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 在组件内部编写\nconst currentLyric = useRef ();\n\nuseEffect (() => {\n  //...\n  getLyric (current.id);\n  setCurrentTime (0);\n  setDuration ((current.dt/ 1000) | 0);\n}, [currentIndex, playList]);\n\nconst getLyric = id => {\n  let lyric = "";\n  getLyricRequest (id)\n    .then (data => {\n      console.log (data)\n      lyric = data.lrc.lyric;\n      if (!lyric) {\n        currentLyric.current = null;\n        return;\n      }\n    })\n    .catch (() => {\n      songReady.current = true;\n      audioRef.current.play ();\n    });\n};\n\n')])])]),n("p",[t._v("其中 getLyricRequest 方法封装在 api/request.js 中。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export const getLyricRequest = id => {\n  return axiosInstance.get (`/lyric?id=${id}`);\n};\n\n")])])]),n("p",[t._v("在 Player/index.js 中引入。")]),t._v(" "),n("p",[t._v("目前打开播放器，点一首歌，便能在控制台看到获取到的歌词信息。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e0803db83a9fb4?w=473&h=654&f=jpeg&s=107908",alt:""}})]),t._v(" "),n("p",[t._v("可以看到，现在能获取到的歌词信息仅仅只是一个字符串，而且格式相对规整，[] 中的内容为时间戳，紧接着的内容是歌词内容。")]),t._v(" "),n("p",[t._v("如果想要将歌词集成到现有的项目中，那解析歌词是必不可少的工作。")]),t._v(" "),n("p",[t._v("现在，就带大家来一起完成这个相对复杂的插件的封装，后期会以彩蛋的形式对它进行扩展、升级。")]),t._v(" "),n("blockquote",[n("p",[t._v("第一版插件代码参考了现有 github 开源仓库 https://github.com/ustbhuangyi/lyric-parser，在此深表鸣谢！")])]),t._v(" "),n("h2",{attrs:{id:"初始化插件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#初始化插件"}},[t._v("#")]),t._v(" 初始化插件")]),t._v(" "),n("p",[t._v("构造器传入两个参数，一个是待解析的字符串，另一个是当歌曲播放抵达某个时间戳的时候，执行相应的回调。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 解析 [00:01.997] 这一类时间戳的正则表达式\nconst timeExp = /\\[(\\d{2,}):(\\d{2})(?:\\.(\\d{2,3}))?]/g\n\nconst STATE_PAUSE = 0\nconst STATE_PLAYING = 1\nexport default class Lyric {\n  /**\n   * @params {string} lrc\n   * @params {function} handler\n  */ \n  constructor (lrc, hanlder = () => {}) {\n    this.lrc = lrc;\n    this.lines = [];// 这是解析后的数组，每一项包含对应的歌词和时间\n    this.handler = hanlder;// 回调函数\n    this.state = STATE_PAUSE;// 播放状态\n    this.curLineIndex = 0;// 当前播放歌词所在的行数\n    this.startStamp = 0;// 歌曲开始的时间戳\n\n    this._initLines ();\n  }\n\n  _initLines () {\n    // 解析代码\n  }\n}\n\n")])])]),n("h2",{attrs:{id:"解析字符串-生成-lines-数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解析字符串-生成-lines-数组"}},[t._v("#")]),t._v(" 解析字符串，生成 lines 数组")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  _initLines () {\n    // 解析代码\n    const lines = this.lrc.split ('\\n');\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines [i];// 如 \"[00:01.997] 作词：薛之谦\"\n      let result = timeExp.exec (line);\n      if (!result) continue;\n      const txt = line.replace (timeExp, '').trim ();// 现在把时间戳去掉，只剩下歌词文本\n      if (txt) {\n        if (result [3].length === 3) {\n          result [3] = result [3]/10;//[00:01.997] 中匹配到的 997 就会被切成 99\n        }\n        this.lines.push ({\n          time: result [1] * 60 * 1000 + result [2] * 1000 + (result [3] || 0) * 10,// 转化具体到毫秒的时间，result [3] * 10 可理解为 (result / 100) * 1000\n          txt\n        });\n      }\n    }\n    this.lines.sort ((a, b) => {\n      return a.time - b.time;\n    });// 根据时间排序\n  }\n\n")])])]),n("p",[t._v("现在解析后的效果如下:")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e0803fc82c001c?w=531&h=763&f=jpeg&s=175005",alt:""}})]),t._v(" "),n("h2",{attrs:{id:"开始播放"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#开始播放"}},[t._v("#")]),t._v(" 开始播放")]),t._v(" "),n("p",[t._v("对应的插件方法为 play 方法，如下所示:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//offset 为时间进度，isSeek 标志位表示用户是否手动调整进度\nplay (offset = 0, isSeek = false) {\n  if (!this.lines.length) {\n    return;\n  }\n  this.state = STATE_PLAYING;\n  // 找到当前所在的行\n  this.curLineIndex = this._findcurLineIndex (offset);\n  // 现在正处于第 this.curLineIndex-1 行\n  // 立即定位，方式是调用传来的回调函数，并把当前歌词信息传给它\n  this._callHandler (this.curLineIndex-1);\n  // 根据时间进度判断歌曲开始的时间戳\n  this.startStamp = +new Date () - offset;\n\n  if (this.curLineIndex < this.lines.length) {\n    clearTimeout (this.timer);\n    // 继续播放\n    this._playRest (isSeek);\n  }\n}\n\n_findcurLineIndex (time) {\n  for (let i = 0; i < this.lines.length; i++) {\n    if (time <= this.lines [i].time) {\n      return i\n    }\n  }\n  return this.lines.length - 1\n}\n\n_callHandler (i) {\n  if (i < 0) {\n    return\n  }\n  this.handler ({\n    txt: this.lines [i].txt,\n    lineNum: i\n  })\n}\n\n")])])]),n("h2",{attrs:{id:"继续播放"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#继续播放"}},[t._v("#")]),t._v(" 继续播放")]),t._v(" "),n("p",[t._v("对应的方法为_playRest，如下所示:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//isSeek 标志位表示用户是否手动调整进度\n_playRest (isSeek=false) {\n  let line = this.lines [this.curLineIndex];\n  let delay;\n  if (isSeek) {\n    delay = line.time - (+new Date () - this.startStamp);\n  } else {\n    // 拿到上一行的歌词开始时间，算间隔\n    let preTime = this.lines [this.curLineIndex - 1] ? this.lines [this.curLineIndex - 1].time : 0;\n    delay = line.time - preTime;\n  }\n  this.timer = setTimeout (() => {\n    this._callHandler (this.curLineIndex++);\n    if (this.curLineIndex < this.lines.length && this.state === STATE_PLAYING) {\n      this._playRest ();\n    }\n  }, delay)\n}\n\n")])])]),n("p",[t._v("画图模拟一下 isSeek 为 true 和 false 的两种情况。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e08041cfd3ef47?w=618&h=312&f=jpeg&s=14343",alt:""}})]),t._v(" "),n("p",[t._v("那触发下一次_playRest 就还剩 00:03.123 - (new Date () - 歌曲开始的时间戳)。即:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("delay = line.time - (+new Date () - this.startStamp);\n\n")])])]),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e0804323d841a4?w=673&h=330&f=jpeg&s=13794",alt:""}})]),t._v(" "),n("p",[t._v("那这个时候触发下一次_playRest 就还剩 00:05.763 - 00:03:123 了。即:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 拿到上一行的歌词开始时间，算间隔\nlet preTime = this.lines [this.curLineIndex - 1] ? this.lines [this.curLineIndex - 1].time : 0;\ndelay = line.time - preTime;\n\n")])])]),n("h2",{attrs:{id:"两个状态切换-暂停和播放"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#两个状态切换-暂停和播放"}},[t._v("#")]),t._v(" 两个状态切换：暂停和播放")]),t._v(" "),n("p",[t._v("歌曲暂停 (播放) 的时候，歌词也应该相应地暂停 (播放)。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("togglePlay (offset) {\n  if (this.state === STATE_PLAYING) {\n    this.stop ()\n  } else {\n    this.state = STATE_PLAYING\n    this.play (offset, true)\n  }\n}\n\nstop () {\n  this.state = STATE_PAUSE\n  clearTimeout (this.timer)\n}\n\n")])])]),n("h2",{attrs:{id:"切到某个时间点播放"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#切到某个时间点播放"}},[t._v("#")]),t._v(" 切到某个时间点播放")]),t._v(" "),n("p",[t._v("由于之前做了很多的铺垫，现在用户手动调整进度的时候，只需要调用 play 方法，并对 isSeek 参数传入 true 就可以了。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("seek (offset) {\n  this.play (offset, true)\n}\n\n")])])]),n("p",[t._v("OK! 歌词插件初步封装完成，接下来我们需要将它集成项目中，不要走开，精彩继续！")])])}),[],!1,null,null,null);e.default=i.exports}}]);