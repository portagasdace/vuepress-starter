(window.webpackJsonp=window.webpackJsonp||[]).push([[322],{676:function(n,e,t){"use strict";t.r(e);var a=t(42),s=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("blockquote",[t("p",[n._v("本节代码对应 GitHub 分支: chapter9")])]),n._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/sanyuan0704/react-cloud-music/tree/chapter9",target:"_blank",rel:"noopener noreferrer"}},[n._v("仓库传送门"),t("OutboundLink")],1)]),n._v(" "),t("h2",{attrs:{id:"骨架搭建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#骨架搭建"}},[n._v("#")]),n._v(" 骨架搭建")]),n._v(" "),t("p",[n._v("首先完成播放列表的轮廓，以及将它和播放器进行对接。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import React from 'react';\nimport {connect} from \"react-redux\";\nimport { PlayListWrapper, ScrollWrapper } from './style';\nfunction PlayList (props) {\n  return (\n    <PlayListWrapper>\n      <div className=\"list_wrapper\">\n        <ScrollWrapper></ScrollWrapper>\n      </div>\n    </PlayListWrapper>\n  )\n}\nexport default PlayList;\n\n")])])]),t("p",[n._v("相应的 style.js 中:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('import styled from\'styled-components\';\nimport style from \'../../../assets/global-style\';\n\nexport const PlayListWrapper = styled.div `\n  position: fixed;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  z-index: 1000;\n  background-color: ${style ["background-color-shadow"]};\n  .list_wrapper {\n    position: absolute;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    opacity: 1;\n    border-radius: 10px 10px 0 0;\n    background-color: ${style ["highlight-background-color"]};\n    transform: translate3d (0, 0, 0);\n    .list_close {\n      text-align: center;\n      line-height: 50px;\n      background: ${style ["background-color"]};\n      font-size: ${style ["font-size-l"]};\n      color: ${style ["font-color-desc"]};\n    }\n  }\n`;\nexport const ScrollWrapper = styled.div`\n  height: 400px;\n  overflow: hidden;\n`;\n\n')])])]),t("p",[n._v("现在你可以看到弹出的一个白色浮层了，这就是播放列表组件。现在我们将它和播放器做一下对接。")]),n._v(" "),t("p",[n._v("首先，需要在 Player/index.js 中，往 miniPlayer 和 normalPlayer 子组件中分别传入这个属性：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 当然先要从 props 取出 togglePlayListDispatch，这部分大家自己加上即可\ntogglePlayList={togglePlayListDispatch}\n\n")])])]),t("p",[n._v("然后在 miniPlayer/index.js 中，增加以下逻辑:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 取出\nconst { togglePlayList } = props;\nconst handleTogglePlayList = (e) => {\n  togglePlayList (true);\n  e.stopPropagation ();\n};\n\n// 给列表图标绑定事件\n<div className="control" onClick={handleTogglePlayList}>\n\n')])])]),t("p",[n._v("同时，在 normalPlayer/index.js 中，增加:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const { togglePlayList } = props;\n//...\n<div\n  className="icon i-right"\n  onClick={() => togglePlayList (true)}\n>\n\n')])])]),t("p",[n._v("现在我们让 PlayList 组件对接上 redux 中的数据。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import { connect } from \"react-redux\";\n\n// 组件代码省略\n\n// 映射 Redux 全局的 state 到组件的 props 上\nconst mapStateToProps = (state) => ({\n  showPlayList: state.getIn (['player', 'showPlayList']),\n});\n// 映射 dispatch 到 props 上\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    togglePlayListDispatch (data) {\n      dispatch (changeShowPlayList (data));\n    }\n  }\n};\n\n// 将 ui 组件包装成容器组件\nexport default connect (mapStateToProps, mapDispatchToProps)(React.memo (PlayList));\n\n")])])]),t("p",[n._v("连接后我们专心来写组件内部的逻辑。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 即将引入的模块\nimport { connect } from "react-redux";\nimport { PlayListWrapper, ScrollWrapper, ListHeader, ListContent } from \'./style\';\nimport { CSSTransition } from \'react-transition-group\';\nimport React, { useRef, useState, useCallback } from \'react\';\nimport { prefixStyle, getName } from \'./../../../api/utils\';\nimport { changeShowPlayList, changeCurrentIndex, changePlayMode, changePlayList } from "../store/actionCreators";\nimport { playMode } from "../../../api/config";\nimport Scroll from \'../../../baseUI/scroll\';\n\n\n// 组件内代码\nfunction PlayList (props) {\n  const { showPlayList } = props;\n  const { togglePlayListDispatch } = props;\n  const playListRef = useRef ();\n  const listWrapperRef = useRef ();\n  const isShow = useState (false);\n\n  return (\n    <CSSTransition \n      in={showPlayList} \n      timeout={300} \n      classNames="list-fade"\n      onEnter={onEnterCB}\n      onEntering={onEnteringCB}\n      onExiting={onExitingCB}\n      onExited={onExitedCB}\n    >\n      <PlayListWrapper \n        ref={playListRef} \n        style={isShow === true ? { display: "block" } : { display: "none" }} \n        onClick={() => togglePlayListDispatch (false)}\n      >\n        <div className="list_wrapper" ref={listWrapperRef} >\n          <ScrollWrapper></ScrollWrapper>\n        </div>\n      </PlayListWrapper>\n    </CSSTransition>\n  )\n}\n\n\n')])])]),t("p",[n._v("接下来编写动画钩子里面的回调函数:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('import { prefixStyle } from \'./../../../api/utils\';\n\nconst transform = prefixStyle ("transform");\n\nconst onEnterCB = useCallback (() => {\n  // 让列表显示\n  setIsShow (true);\n  // 最开始是隐藏在下面\n  listWrapperRef.current.style [transform] = `translate3d (0, 100%, 0)`;\n}, [transform]);\n\nconst onEnteringCB = useCallback (() => {\n  // 让列表展现\n  listWrapperRef.current.style ["transition"] = "all 0.3s";\n  listWrapperRef.current.style [transform] = `translate3d (0, 0, 0)`;\n}, [transform]);\n\nconst onExitingCB = useCallback (() => {\n  listWrapperRef.current.style ["transition"] = "all 0.3s";\n  listWrapperRef.current.style [transform] = `translate3d (0px, 100%, 0px)`;\n}, [transform]);\n\nconst onExitedCB = useCallback (() => {\n  setIsShow (false);\n  listWrapperRef.current.style [transform] = `translate3d (0px, 100%, 0px)`;\n}, [transform]);\n\n')])])]),t("p",[n._v("在 style.js 中增加动画部分:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export const PlayListWrapper = styled.div `\n  /* 下面是动画部分的代码 */\n  &.list-fade-enter {\n    opacity: 0;\n  }\n  &.list-fade-enter-active {\n    opacity: 1;\n    transition: all 0.3s;\n  }\n  &.list-fade-exit {\n    opacity: 1;\n  }\n  &.list-fade-exit-active {\n    opacity: 0;\n    transition: all 0.3s;\n  }\n`\n\n")])])]),t("p",[n._v("现在大家点击列表图标便能弹出浮层了。")]),n._v(" "),t("h2",{attrs:{id:"完成列表展示功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#完成列表展示功能"}},[n._v("#")]),n._v(" 完成列表展示功能")]),n._v(" "),t("p",[n._v("现在我们来往浮层中增添列表的内容和功能。")]),n._v(" "),t("p",[n._v("首先，得从 redux 中拿到相应的数据。获取数据如下:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 映射 Redux 全局的 state 到组件的 props 上\nconst mapStateToProps = (state) => ({\n  currentIndex: state.getIn (['player', 'currentIndex']),\n  currentSong: state.getIn (['player', 'currentSong']),\n  playList: state.getIn (['player', 'playList']),// 播放列表\n  sequencePlayList: state.getIn (['player', 'sequencePlayList']),// 顺序排列时的播放列表\n  showPlayList: state.getIn (['player', 'showPlayList']),\n  mode: state.getIn (['player', 'mode'])\n});\n// 映射 dispatch 到 props 上\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    togglePlayListDispatch (data) {\n      dispatch (changeShowPlayList (data));\n    },\n    // 修改当前歌曲在列表中的 index，也就是切歌\n    changeCurrentIndexDispatch (data) {\n      dispatch (changeCurrentIndex (data));\n    },\n    // 修改当前的播放模式\n    changeModeDispatch (data) {\n      dispatch (changePlayMode (data));\n    },\n    // 修改当前的歌曲列表\n    changePlayListDispatch (data) {\n      dispatch (changePlayList (data));\n    },\n  }\n};\n\n")])])]),t("p",[n._v("从 props 中导入:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const {\n  currentIndex,\n  currentSong:immutableCurrentSong,\n  showPlayList,\n  playList:immutablePlayList,\n  mode,\n  sequencePlayList:immutableSequencePlayList\n} = props;\nconst {\n  togglePlayListDispatch,\n  changeCurrentIndexDispatch,\n  changePlayListDispatch,\n  changeModeDispatch,\n} = props;\n\nconst currentSong = immutableCurrentSong.toJS ();\nconst playList = immutablePlayList.toJS ();\nconst sequencePlayList = immutableSequencePlayList.toJS ();\n\n")])])]),t("p",[n._v("然后让列表组件对接这些数据，渲染出整个列表。JSX 结构如下:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//div.list_wrapper 标签中包裹下面的结构\n<ListHeader>\n  <h1 className="title">\n    { getPlayMode () }\n    <span className="iconfont clear" onClick={handleShowClear}>&#xe63d;</span>\n  </h1>\n</ListHeader>\n<ScrollWrapper>\n  <Scroll >\n    <ListContent>\n      {\n        playList.map ((item, index) => {\n          return (\n            <li className="item" key={item.id}>\n              {getCurrentIcon (item)}\n              <span className="text">{item.name} - {getName (item.ar)}</span>\n              <span className="like">\n                <i className="iconfont">&#xe601;</i>\n              </span>\n              <span className="delete">\n                <i className="iconfont">&#xe63d;</i>\n              </span>\n            </li>\n          )\n        })\n      }\n    </ListContent>\n  </Scroll>\n</ScrollWrapper>\n\n')])])]),t("p",[n._v("其中有一些 UI 相关的逻辑封装，包括 getPlayMode、getPlayMode 和 changeMode，比较直观，没有参杂太多的业务逻辑，直接贴出代码:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const getCurrentIcon = (item) => {\n  // 是不是当前正在播放的歌曲\n  const current = currentSong.id === item.id;\n  const className = current ? \'icon-play\' : \'\';\n  const content = current ? \'&#xe6e3;\': \'\';\n  return (\n    <i className={`current iconfont ${className}`} dangerouslySetInnerHTML={{__html:content}}></i>\n  )\n};\nconst getPlayMode = () => {\n  let content, text;\n  if (mode === playMode.sequence) {\n    content = "&#xe625;";\n    text = "顺序播放";\n  } else if (mode === playMode.loop) {\n    content = "&#xe653;";\n    text = "单曲循环";\n  } else {\n    content = "&#xe61b;";\n    text = "随机播放";\n  }\n  return (\n    <div>\n      <i className="iconfont" onClick={(e) => changeMode (e)}  dangerouslySetInnerHTML={{__html: content}}></i>\n      <span className="text" onClick={(e) => changeMode (e)}>{text}</span>\n    </div>\n  )\n};\nconst changeMode = (e) => {\n  let newMode = (mode + 1) % 3;\n  // 具体逻辑比较复杂 后面来实现\n};\n\n')])])]),t("p",[n._v("当然，还有对应的 style.js 中的样式组件，首先是 ListHead , 作为列表头部包裹播放模式和清空按钮的容器组件:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('export const ListHeader = styled.div `\n  position: relative;\n  padding: 20px 30px 10px 20px;\n  .title {\n    display: flex;\n    align-items: center;\n    >div {\n      flex:1;\n      .text {\n        flex: 1;\n        font-size: ${style ["font-size-m"]};\n        color: ${style ["font-color-desc"]};\n      }\n    }\n    .iconfont {\n      margin-right: 10px;\n      font-size: ${style ["font-size-ll"]};\n      color: ${style ["theme-color"]};\n    }\n    .clear {\n      ${style.extendClick ()}\n      font-size: ${style ["font-size-l"]};\n    }\n  }\n`\n\n')])])]),t("p",[n._v("ListContent 组件用来包裹整个歌曲的列表，是一个列表包裹组件， 样式代码如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('export const ListContent = styled.div `\n  .item {\n    display: flex;\n    align-items: center;\n    height: 40px;\n    padding: 0 30px 0 20px;\n    overflow: hidden;\n    .current {\n      flex: 0 0 20px;\n      width: 20px;\n      font-size: ${style ["font-size-s"]};\n      color: ${style ["theme-color"]};\n    }\n    .text {\n      flex: 1;\n      ${style.noWrap ()}\n      font-size: ${style ["font-size-m"]};\n      color: ${style ["font-color-desc-v2"]};\n      .icon-favorite {\n        color: ${style ["theme-color"]};\n      }\n    }\n    .like {\n      ${style.extendClick ()}\n      margin-right: 15px;\n      font-size: ${style ["font-size-m"]};\n      color: ${style ["theme-color"]};\n    }\n    .delete {\n      ${style.extendClick ()}\n      font-size: ${style ["font-size-s"]};\n      color: ${style ["theme-color"]};\n    }\n  }\n`\n\n')])])]),t("p",[n._v("现在列表的展示已经成功完成！接下来就是处理对应的业务逻辑了，梳理一下，分别是点击切歌、删除歌曲和切换播放模式这三大功能。")]),n._v(" "),t("h2",{attrs:{id:"点击切歌实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#点击切歌实现"}},[n._v("#")]),n._v(" 点击切歌实现")]),n._v(" "),t("p",[n._v("首先，我们需要绑定对应的事件:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const handleChangeCurrentIndex = (index) => {\n  if (currentIndex === index) return;\n  changeCurrentIndexDispatch (index);\n}\n\n// 绑定点击事件\n<li className="item" key={item.id} onClick={() => handleChangeCurrentIndex (index)}>\n\n')])])]),t("p",[n._v("你现在点击一下歌曲，好像可以切歌，但是你发现有一个问题:")]),n._v(" "),t("p",[n._v("当你点击之后列表突然被隐藏了。这个 bug 是怎么产生的呢？其实我们之前在 PlayWrapper 绑定了这样一个事件:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("onClick={() => togglePlayListDispatch (false)}\n\n")])])]),t("p",[n._v("其实这是为了在用户点击列表外部的时候，直接将列表隐藏掉，也符合常理。但是 PlayWrapper 的范围是整个屏幕，包含了列表内容，因此出现了这个 bug。")]),n._v(" "),t("p",[n._v("如何解决这个问题？")]),n._v(" "),t("p",[n._v("且看这样一行代码:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('<div className="list_wrapper" ref={listWrapperRef} onClick={e => e.stopPropagation ()}>\n\n')])])]),t("p",[n._v("在 list_wrapper 中绑定点击事件，阻止它冒泡就行了。因为这个 div 包裹的就是整个歌曲的列表。")]),n._v(" "),t("p",[n._v("OK！接下来，我们来实现删除歌曲的功能，这里面又包括删除一首歌曲和清空全部歌曲。")]),n._v(" "),t("h2",{attrs:{id:"删除一首歌曲"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除一首歌曲"}},[n._v("#")]),n._v(" 删除一首歌曲")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('import { deleteSong } from "../store/actionCreators";\n\nconst { deleteSongDispatch } = props;\nconst handleDeleteSong = (e, song) => {\n  e.stopPropagation ();\n  deleteSongDispatch (song);\n};\n\n<span className="delete" onClick={(e) => handleDeleteSong (e, item)}>\n  <i className="iconfont">&#xe63d;</i>\n</span>\n\n')])])]),t("p",[n._v("重点在于 deleteSongDispatch 的逻辑，我们来一步步拆解它。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//mapDispatchToProps 中\ndeleteSongDispatch (data) {\n  dispatch (deleteSong (data));\n}\n\n")])])]),t("p",[n._v("然后在 Player/store/constants.js 中增加:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export const DELETE_SONG = 'player/DELETE_SONG';\n\n")])])]),t("p",[n._v("在 store/actionCreator.js 中导入 DELETE_SONG, 然后增加一个新的 action:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export const deleteSong = (data) => ({\n  type: DELETE_SONG,\n  data\n});\n\n")])])]),t("p",[n._v("现在转到 store/reducer.js 下编写删除的逻辑:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import { findIndex } from '../../../api/utils';// 注意引入工具方法\n//...\nconst handleDeleteSong = (state, song) => {\n  // 也可用 loadsh 库的 deepClone 方法。这里深拷贝是基于纯函数的考虑，不对参数 state 做修改\n  const playList = JSON.parse (JSON.stringify (state.get ('playList').toJS ()));\n  const sequenceList = JSON.parse (JSON.stringify (state.get ('sequencePlayList').toJS ()));\n  let currentIndex = state.get ('currentIndex');\n  // 找对应歌曲在播放列表中的索引\n  const fpIndex = findIndex (song, playList);、\n  // 在播放列表中将其删除\n  playList.splice (fpIndex, 1);\n  // 如果删除的歌曲排在当前播放歌曲前面，那么 currentIndex--，让当前的歌正常播放\n  if (fpIndex < currentIndex) currentIndex--;\n  \n  // 在 sequenceList 中直接删除歌曲即可\n  const fsIndex = findIndex (song, sequenceList);\n  sequenceList.splice (fsIndex, 1);\n\n  return state.merge ({\n    'playList': fromJS (playList),\n    'sequencePlayList': fromJS (sequenceList),\n    'currentIndex': fromJS (currentIndex),\n  });\n}\n\nexport default (state = defaultState, action) => {\n  switch (action.type) {\n    //...\n    case actionTypes.DELETE_SONG:\n      return handleDeleteSong (state, action.data);\n    default:\n      return state;\n  }\n}\n\n")])])]),t("p",[n._v("现在点击单个歌曲后面的删除按钮便能成功地将歌曲从列表删除啦！")]),n._v(" "),t("h2",{attrs:{id:"清空歌曲功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#清空歌曲功能"}},[n._v("#")]),n._v(" 清空歌曲功能")]),n._v(" "),t("p",[n._v("一般而言，删除全部是一个影响比较大的操作，如果弹出一个确定框，让用户点击确定再操作，无疑是更加合理的。")]),n._v(" "),t("p",[n._v("因此，我们首先来封装弹框组件，然后进行事件绑定。")]),n._v(" "),t("p",[n._v("在 baseUI 目录下新建 confirm 文件夹，然后新建 index.js 文件。")]),n._v(" "),t("p",[n._v("其代码从 "),t("a",{attrs:{href:"https://github.com/sanyuan0704/react-cloud-music/blob/master/src/baseUI/confirm/index.js",target:"_blank",rel:"noopener noreferrer"}},[n._v("代码地址"),t("OutboundLink")],1),n._v(" 中获取，也是一个非常基础的组件，里面的封装操作和之前的类似，就不再浪费篇幅了。")]),n._v(" "),t("p",[n._v("回到 PlayList 组件，我们引入 Confirm 组件:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('import Confirm from \'./../../../baseUI/confirm/index\';\nconst confirmRef = useRef ();\n//JSX\nreturn (\n  <PlayListWrapper>\n    //...\n    <Confirm \n      ref={confirmRef}\n      text={"是否删除全部？"} \n      cancelBtnText={"取消"} \n      confirmBtnText={"确定"} \n      handleConfirm={handleConfirmClear}\n    />\n  </PlayListWrapper>\n)\n\n')])])]),t("p",[n._v("现在来绑定一下清空事件:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const handleShowClear = () => {\n  confirmRef.current.show ();\n} \n\n<span className="iconfont clear" onClick={handleShowClear}>&#xe63d;</span>\n\n')])])]),t("p",[n._v("现在的工作是编写 Confirm 组件的回调函数 handleConfirmClear。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import { changeSequecePlayList, changeCurrentSong, changePlayingState } from '../store/actionCreators';\n//...\nconst { clearDispatch } = props;\nconst handleConfirmClear = () => {\n  clearDispatch ();\n}\n\n")])])]),t("p",[n._v("clearDispatch 在 mapDispatchToProps 中定义:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const mapDispatchToProps = (dispatch) => {\n  return {\n    //...\n    clearDispatch () {\n      // 1. 清空两个列表\n      dispatch (changePlayList ([]));\n      dispatch (changeSequecePlayList ([]));\n      // 2. 初始 currentIndex\n      dispatch (changeCurrentIndex (-1));\n      // 3. 关闭 PlayList 的显示\n      dispatch (changeShowPlayList (false));\n      // 4. 将当前歌曲置空\n      dispatch (changeCurrentSong ({}));\n      // 5. 重置播放状态\n      dispatch (changePlayingState (false));\n    }\n  }\n};\n\n")])])]),t("h2",{attrs:{id:"修改播放模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修改播放模式"}},[n._v("#")]),n._v(" 修改播放模式")]),n._v(" "),t("p",[n._v("直接复用当时完成 normalPlayer 时修改播放模式的代码，当时我们实现过，估计你已经不陌生了。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 从 utils.js 中再引入 shuffle 和 findIndex\nimport { prefixStyle, getName, shuffle, findIndex } from './../../../api/utils';\n\nconst changeMode = () => {\n  let newMode = (mode + 1) % 3;\n  if (newMode === 0) {\n    // 顺序模式\n    changePlayListDispatch (sequencePlayList);\n    let index = findIndex (currentSong, sequencePlayList);\n    changeCurrentIndexDispatch (index);\n  } else if (newMode === 1) {\n    // 单曲循环\n    changePlayListDispatch (sequencePlayList);\n  } else if (newMode === 2) {\n    // 随机播放\n    let newList = shuffle (sequencePlayList);\n    let index = findIndex (currentSong, newList);\n    changePlayListDispatch (newList);\n    changeCurrentIndexDispatch (index);\n  }\n  changeModeDispatch (newMode);\n};\n\n")])])]),t("h2",{attrs:{id:"下滑关闭及反弹效果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#下滑关闭及反弹效果"}},[n._v("#")]),n._v(" 下滑关闭及反弹效果")]),n._v(" "),t("p",[n._v("作为一个精美的 App，在完成基本功能的同时，我们也有其他交互细节的考量。比如在安卓中下滑小段距离时会有反弹，下滑超过了一定阈值就会关闭浮层。现在就带大家来完成这个移动端常用的功能。")]),n._v(" "),t("p",[n._v("实现这个交互的关键在于利用好 touchStart， touchMove, touchEnd 这三个事件的回调。")]),n._v(" "),t("p",[n._v("首先来绑定事件:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const handleTouchStart = (e) => {};\nconst handleTouchMove = (e) => {};\nconst handleTouchEnd = (e) => {};\n//...\n<div \n  className="list_wrapper" \n  ref={listWrapperRef} \n  onClick={e => e.stopPropagation ()}\n  onTouchStart={handleTouchStart}\n  onTouchMove={handleTouchMove}\n  onTouchEnd={handleTouchEnd}\n>\n\n')])])]),t("p",[n._v("其次，对于 Scroll 组件:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 是否允许滑动事件生效\nconst [canTouch,setCanTouch] = useState (true);\n\nconst listContentRef = useRef ();\nconst handleScroll = (pos) => {\n  // 只有当内容偏移量为 0 的时候才能下滑关闭 PlayList。否则一边内容在移动，一边列表在移动，出现 bug\n  let state = pos.y === 0;\n  setCanTouch (state);\n}\n\n<Scroll \n  ref={listContentRef} \n  onScroll={pos => handleScroll (pos)}\n  bounceTop={false}\n>\n\n")])])]),t("p",[n._v("接下来我们来具体地编写那三个 touch 事件的回调函数。")]),n._v(" "),t("p",[n._v("首先初始化三个变量:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//touchStart 后记录 y 值\nconst [startY, setStartY] = useState (0);\n//touchStart 事件是否已经被触发\nconst [initialed, setInitialed] = useState (0);\n// 用户下滑的距离\nconst [distance, setDistance] = useState (0);\n\n")])])]),t("p",[n._v("对于 touchStart 事件：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const handleTouchStart = (e) => {\n  if (!canTouch || initialed) return;\n  listWrapperRef.current.style ["transition"] = "";\n  setStartY (e.nativeEvent.touches [0].pageY);// 记录 y 值\n  setInitialed (true);\n};\n\n')])])]),t("p",[n._v("对于 touchMove 事件:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const handleTouchMove = (e) => {\n  if (!canTouch || !initialed) return;\n  let distance = e.nativeEvent.touches [0].pageY - startY;\n  if (distance < 0) return;\n  setDistance (distance);// 记录下滑距离\n  listWrapperRef.current.style.transform = `translate3d (0, ${distance} px, 0)`;\n};\n\n")])])]),t("p",[n._v("对于 touchEnd:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const handleTouchEnd = (e) => {\n  setInitialed (false);\n  // 这里设置阈值为 150px\n  if (distance >= 150) {\n    // 大于 150px 则关闭 PlayList\n    togglePlayListDispatch (false);\n  } else {\n    // 否则反弹回去\n    listWrapperRef.current.style ["transition"] = "all 0.3s";\n    listWrapperRef.current.style [transform] = `translate3d (0px, 0px, 0px)`;\n  }\n};\n\n')])])]),t("p",[n._v("恭喜你，现在终于开发完成了这个看似简单却实际上并不简单的 PlayList 组件。如今播放器的功能已经比较完整了，但是仍然有一个非常重要的功能需要完成 —— 歌词功能，下一节就让我们开始歌词开发的第一步 —— 歌词解析插件的封装。")])])}),[],!1,null,null,null);e.default=s.exports}}]);