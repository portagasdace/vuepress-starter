(window.webpackJsonp=window.webpackJsonp||[]).push([[453],{809:function(t,n,a){"use strict";a.r(n);var s=a(42),e=Object(s.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"实战篇-5-为天气页面制作雨雪效果的粒子系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实战篇-5-为天气页面制作雨雪效果的粒子系统"}},[t._v("#")]),t._v(" 实战篇 5：为天气页面制作雨雪效果的粒子系统")]),t._v(" "),a("p",[t._v("经过前两节的内容，基本天气预报页面的布局和数据交互都已经完成了，本节来介绍使用小程序的绘图 API 在「实时天气」模块上做一个雨雪效果。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/13/165314726eeabb28?w=640&h=960&f=gif&s=2606064",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"小程序的绘图-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小程序的绘图-api"}},[t._v("#")]),t._v(" 小程序的绘图 API")]),t._v(" "),a("p",[t._v("小程序的绘图 API 跟 HTML5 的 Canvas 本质上有很大区别的，造成用法区别的原因是：")]),t._v(" "),a("blockquote",[a("p",[t._v("小程序的绘图（Canvas）是客户端实现的 Native UI 组件，而不是普通的 H5 组件，所以在使用上跟普通的 H5 组件用法略有不同。")])]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("Tips：")]),t._v(" 微信的 Canvas 在 iOS 上是 "),a("a",{attrs:{href:"https://github.com/phoboslab/Ejecta",target:"_blank",rel:"noopener noreferrer"}},[t._v("Ejecta"),a("OutboundLink")],1),t._v(" 实现的。")])]),t._v(" "),a("h3",{attrs:{id:"上下文获取方式不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上下文获取方式不同"}},[t._v("#")]),t._v(" 上下文获取方式不同")]),t._v(" "),a("p",[t._v("小程序绘图 API 的 "),a("code",[t._v("canvasContext")]),t._v(" 获取方式是通过 "),a("code",[t._v("<canvas>")]),t._v(" 的 "),a("code",[t._v("canvas-id")]),t._v(" 来获取的，即")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<canvas canvas-id="test"></canvas>\n\n')])])]),a("p",[t._v("获取 Context：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let ctx = wx.createCanvasContext('test')\n\n")])])]),a("h3",{attrs:{id:"api-写法不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#api-写法不同"}},[t._v("#")]),t._v(" API 写法不同")]),t._v(" "),a("p",[t._v("小程序的绘图 API 跟 HTML5 的 Canvas 在用法上主要是绝大部分的 HTML5 Canvas 属性写法，变成了小程序的方法写法，例如：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const ctx = wx.createCanvasContext('myCanvas')\nctx.setFillStyle('red')\nctx.fillRect(10, 10, 150, 75)\nctx.draw()\n\n")])])]),a("p",[t._v("不过值得一提的是，在 1.9.0 基础库以上，类似 "),a("code",[t._v("fillStyle")]),t._v("、"),a("code",[t._v("lineWidth")]),t._v(" 这类的，可以直接跟 H5 的写法一样，不需要使用 "),a("code",[t._v("setXxxx")]),t._v(" 的方式了。")]),t._v(" "),a("h3",{attrs:{id:"想要显示绘制效果-需要-ctx-draw-使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#想要显示绘制效果-需要-ctx-draw-使用"}},[t._v("#")]),t._v(" 想要显示绘制效果，需要 "),a("code",[t._v("ctx.draw()")]),t._v(" 使用")]),t._v(" "),a("p",[t._v("在小程序的绘图使用中，对 "),a("code",[t._v("context")]),t._v(" 进行绘制之后，并不会立即绘制到画布上，而是通过执行 "),a("code",[t._v("ctx.draw()")]),t._v(" 的方式，将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中。"),a("code",[t._v("ctx.draw()")]),t._v(" 方法比较消耗性能，因此不建议在一个绘制周期内多次调用。")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("Tips：")]),t._v(" 小程序绘图中的内部尺寸单位都是 px，例如 "),a("code",[t._v("clearRect()")]),t._v(" 这类方法，所以在使用 "),a("code",[t._v("rpx")]),t._v(" 布局的页面中，需要注意 Canvas 内部 rpx 到 px 的转换关系，详细解释见本节粒子系统实现部分。")])]),t._v(" "),a("h2",{attrs:{id:"粒子系统设计思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#粒子系统设计思路"}},[t._v("#")]),t._v(" 粒子系统设计思路")]),t._v(" "),a("p",[t._v("在 Canvas 开发中，经常会提到粒子系统，使用粒子系统可以模拟出火、雾、云、雪、尘埃、烟气等抽象视觉效果。")]),t._v(" "),a("p",[t._v("在这个小程序中，笔者使用粒子系统做了雨雪效果，通过雨雪效果的编写，可以让读者学会粒子系统的基础知识，以及在小程序中使用绘图 API 相关的接口。")]),t._v(" "),a("p",[t._v("本小册中的粒子系统由基类和子类组成。"),a("code",[t._v("Particle")]),t._v(" 是基类，定义了子类统一的方法，如 "),a("code",[t._v("run()")]),t._v("、"),a("code",[t._v("stop()")]),t._v("、"),a("code",[t._v("clear()")]),t._v(" 等。基类负责整个粒子系统动画周期和流程的维护，子类负责具体实现的粒子效果，比如下雨下雪的效果是子类实现的，而下雨下雪的开关和公共处理流程是基类控制的。")]),t._v(" "),a("p",[t._v("基类由如下几个方法组成：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("_init()")]),t._v("：实例化时第一执行的方法；空，由子类具体实现")]),t._v(" "),a("li",[a("code",[t._v("_draw()")]),t._v("：每个动效周期内画图用的方法；空，由子类具体实现")]),t._v(" "),a("li",[a("code",[t._v("run")]),t._v("：设置定时器，定时执行 "),a("code",[t._v("_draw()")]),t._v("，实现动画周期")]),t._v(" "),a("li",[a("code",[t._v("stop")]),t._v("：停止动画")]),t._v(" "),a("li",[a("code",[t._v("clear")]),t._v("：停止动画，并且清空画板")])]),t._v(" "),a("p",[t._v("这些方法之间的关系是：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/13/16531478f272863c?w=803&h=558&f=png&s=64293",alt:""}})]),t._v(" "),a("p",[t._v("上面的关系图很清晰地展现了整个粒子系统的设计思路：")]),t._v(" "),a("ol",[a("li",[t._v("在构造器内调用 "),a("code",[t._v("_init")]),t._v("，随机生成单个粒子，放进数组对象")]),t._v(" "),a("li",[t._v("在执行实例 "),a("code",[t._v("run")]),t._v(" 的时候，设置定时器，定时器回调调用 "),a("code",[t._v("_draw")]),t._v(" 绘制粒子，设置单个粒子下一步的属性")]),t._v(" "),a("li",[t._v("而 "),a("code",[t._v("_init")]),t._v(" 和 "),a("code",[t._v("_draw")]),t._v(" 是子类具体根据效果实现的")])]),t._v(" "),a("p",[t._v("根据这个关系图，基类就很简单实现了：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// lib/effect.js\n// 两个状态\nconst STATUS_STOP = 'stop'\nconst STATUS_RUNNING = 'running'\nclass Particle {\n  constructor(ctx, width, height, opts) {\n    this._timer = null\n    this._options = opts || {}\n    // canvas 上下文\n    this.ctx = ctx\n    this.status = STATUS_STOP\n    this.w = width\n    this.h = height\n\n    this._init()\n  }\n  _init() {}\n  _draw() {}\n  run() {\n    if (this.status !== STATUS_RUNNING) {\n      // 更改状态\n      this.status = STATUS_RUNNING\n      // 绘制循环\n      this._timer = setInterval(() => {\n        this._draw()\n      }, 30)\n    }\n    return this\n  }\n  stop() {\n    // 清理定时器，状态修改\n    this.status = STATUS_STOP\n    clearInterval(this._timer)\n    return this\n  }\n  clear(){\n    this.stop()\n    this.ctx.clearRect(0, 0, this.w, this.h)\n    this.ctx.draw()\n    return this\n  }\n}\n\n")])])]),a("h2",{attrs:{id:"下雨效果的粒子系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#下雨效果的粒子系统"}},[t._v("#")]),t._v(" 下雨效果的粒子系统")]),t._v(" "),a("p",[t._v("根据上面的内容，具体的子类只需要在 "),a("code",[t._v("_init")]),t._v(" 中，根据需要生成的粒子个数 "),a("code",[t._v("amount")]),t._v(" 循环随机生成每个粒子，放入 "),a("code",[t._v("this.particles")]),t._v(" 数组即可：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// lib/effect.js\n// _init\n\nlet h = this.h\nlet w = this.w\n// 数量，根据不同雨大小，数量可调\nlet amount = this._options.amount || 100\n// 速度参数，调节下落速度\nlet speedFactor = this._options.speedFactor || 0.03\nlet speed = speedFactor * h\nlet ps = (this.particles = [])\nfor (let i = 0; i < amount; i++) {\n  let p = {\n    x: Math.random() * w,\n    y: Math.random() * h,\n    l: 2 * Math.random(),\n    xs: -1,\n    ys: 10 * Math.random() + speed,\n    color: 'rgba(255, 255, 255, 0.1)'\n  }\n  ps.push(p)\n}\n\n")])])]),a("p",[t._v("其中：")]),t._v(" "),a("ul",[a("li",[t._v("x、y 代表单个粒子的位置，即雨滴开始绘图的位置")]),t._v(" "),a("li",[t._v("xs、ys 分别代表 x、y 方向上的加速度，即雨滴的下落速度和角度")]),t._v(" "),a("li",[t._v("l 代表雨滴的长度")])]),t._v(" "),a("p",[a("code",[t._v("_draw")]),t._v("的方法，是先将画布清空，然后遍历 "),a("code",[t._v("this.particles")]),t._v(" 数组取出单个雨滴并进行绘制，最后调用一个单独实现的 "),a("code",[t._v("_update")]),t._v(" 重新计算单个雨滴的位置：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// lib/effect.js\n// _draw\nlet ps = this.particles\nlet ctx = this.ctx\n// 清空画布\nctx.clearRect(0, 0, this.w, this.h)\n// 遍历绘制雨滴\nfor (let i = 0; i < ps.length; i++) {\n  let s = ps[i]\n  ctx.beginPath()\n  ctx.moveTo(s.x, s.y)\n  // 画线绘制雨点效果\n  ctx.lineTo(s.x + s.l * s.xs, s.y + s.l * s.ys)\n  ctx.setStrokeStyle(s.color)\n  ctx.stroke()\n}\nctx.draw()\nreturn this._update()\n\n")])])]),a("p",[a("code",[t._v("_update")]),t._v(" 的具体实现如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// lib/effect.js\n\n// _update\nlet {w, h} = this // 获取画布大小\nfor (let ps = this.particles, i = 0; i < ps.length; i++) {\n  // 开始下一个周期的位置计算\n  let s = ps[i]\n  s.x += s.xs\n  s.y += s.ys\n  // 超出范围，重新回收，重复利用\n  if (s.x > w || s.y > h) {\n    s.x = Math.random() * w\n    s.y = -10\n  }\n}\n\n")])])]),a("h2",{attrs:{id:"下雪效果子类实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#下雪效果子类实现"}},[t._v("#")]),t._v(" 下雪效果子类实现")]),t._v(" "),a("p",[t._v("下雪的效果跟下雨不同的是，下雨是长条的线，雪花是圆形的雪片，另外为了增加「灵性」做出飘来飘去的效果，在 "),a("code",[t._v("_update")]),t._v(" 方法中，使用了 "),a("code",[t._v("Math.cos")]),t._v(" 来随机生成下一步 "),a("code",[t._v("x")]),t._v(" 轴的位置，这里就直接贴出代码来：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// lib/effect.js\nclass Snow extends Particle {\n  _init() {\n    let {w, h} = this\n    let colors = this._options._colors || ['#ccc', '#eee', '#fff', '#ddd']\n    // 雪的大小用数量来计算\n    let amount = this._options.amount || 100\n\n    let speedFactor = this._options.speedFactor || 0.03\n    // 速度\n    let speed = speedFactor * h * 0.15\n\n    let radius = this._options.radius || 2\n    let ps = (this.particles = [])\n\n    for (let i = 0; i < amount; i++) {\n      let x = Math.random() * w\n      let y = Math.random() * h\n      // console.log(x, y)\n      ps.push({\n        x,\n        y,\n        // 原始 x 坐标，后面计算随机雪摆动是以此为基础\n        ox: x,\n        // 向下运动动能变量\n        ys: Math.random() + speed,\n        // 雪的半径大小\n        r: Math.floor(Math.random() * (radius + 0.5) + 0.5),\n        // 颜色随机取\n        color: colors[Math.floor(Math.random() * colors.length)],\n        rs: Math.random() * 80\n      })\n    }\n  }\n  _draw() {\n    let ps = this.particles\n    let ctx = this.ctx\n    ctx.clearRect(0, 0, this.w, this.h)\n    for (let i = 0; i < ps.length; i++) {\n      let {x, y, r, color} = ps[i]\n      ctx.beginPath()\n      // 绘制下雪的效果\n      ctx.arc(x, y, r, 0, Math.PI * 2, false)\n      ctx.setFillStyle(color)\n      ctx.fill()\n      ctx.closePath()\n    }\n\n    ctx.draw()\n    this._update()\n  }\n  _update() {\n    let {w, h} = this\n    let v = this._options.speedFactor / 10\n    for (let ps = this.particles, i = 0; i < ps.length; i++) {\n      let p = ps[i]\n      let {ox, ys} = p\n      p.rs += v\n      // 这里使用了 cos，做成随机左右摆动的效果\n      p.x = ox + Math.cos(p.rs) * w / 2\n      p.y += ys\n      // console.log(ys)\n      // 重复利用\n      if (p.x > w || p.y > h) {\n        p.x = Math.random() * w\n        p.y = -10\n      }\n    }\n  }\n}\n\n")])])]),a("p",[t._v("注意，不管是下雨还是下雪，在 "),a("code",[t._v("_draw")]),t._v(" 的最开始都是执行 "),a("code",[t._v("ctx.clearRect")]),t._v(" 清空画布，最后都是执行 "),a("code",[t._v("ctx.draw")]),t._v(" 使 native 对画布进行统一绘制。")]),t._v(" "),a("h2",{attrs:{id:"使用粒子系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用粒子系统"}},[t._v("#")]),t._v(" 使用粒子系统")]),t._v(" "),a("p",[t._v("上面介绍了雨雪的粒子系统 JS 类实现，下面讲解怎样将 Canvas 效果画到网页上，首先看下效果图。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/17/165469d660043a27?w=400&h=718&f=png&s=257746",alt:""}})]),t._v(" "),a("p",[t._v("效果图的黄色框内为下雨的效果，这个红色框大小跟顶部「实时天气模块」是等大的。首先，在 WXML 代码中，给实时天气模块增加 "),a("code",[t._v("id")]),t._v(" 为 "),a("code",[t._v("effect")]),t._v(" 的 Canvas 组件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\x3c!-- weather/index.wxml --\x3e\n<view class="container" id="canvas-wrapper">\n  \x3c!-- 下面是雨雪效果的 Canvas --\x3e\n  <canvas canvas-id="effect" id="effect"></canvas>\n  <view class="now">\n    <view class="location" bindtap="chooseLocation">\n      ...\n    </view>\n    <view class="air-quality" wx:if="{{air.aqi}}">\n      ...\n    </view>\n    <view class="now-weather">\n      ...\n    </view>\n  </view>\n  <view class="two-days">\n    ....\n  </view>\n</view>\n\n')])])]),a("p",[t._v("在样式中，设置 Canvas 的大小跟实时天气模块大小一样，并且绝对定位，完全覆盖到实时天气模块上：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// weather/index.scss\n#effect {\n  width: 750rpx;\n  height: 768rpx;\n  position: absolute;\n  top: 0;\n  right: 0;\n}\n\n")])])]),a("p",[a("strong",[t._v("重点")]),t._v("：在微信小程序内，绘图 API（Canvas）内的长宽单位为 px，而我们页面布局用的是 rpx，虽然我们在 CSS 内已经使用 rpx 设置了 Canvas 的大小，但是由于内部单位的缘故，在实例化 Rain/Snow 粒子系统的时候，传入的 "),a("code",[t._v("width")]),t._v(" 和 "),a("code",[t._v("height")]),t._v(" 参数应该是实际的 px 大小。")]),t._v(" "),a("p",[t._v("根据之前章节的介绍，rpx 转 px 是根据不同的设备屏幕尺寸转换的。虽然切图可以按照 "),a("code",[t._v("1rpx=2px")]),t._v(" 这样标准的 iPhone 6 视觉稿做页面，但是涉及实际 px 计算时，不能简单采用 "),a("code",[t._v("1rpx=2px")]),t._v(" 的方式来解决，需要我们按照实际的 rpx 对应 px 的比例进行转换。如何获取 rpx 和 px 的实际比例呢？我们知道微信小程序中默认规定了屏幕宽度为 750rpx，根据这个设计，我们可以通过 "),a("code",[t._v("wx.getSystemInfo")]),t._v(" 获取到的信息，找到手机屏幕的宽度大小 "),a("code",[t._v("windowWidth")]),t._v(" 即可算出对应的比例，代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// weather/index.js\n// 在 onload 内\nwx.getSystemInfo({\n  success: (res) => {\n    let width = res.windowWidth\n    this.setData({\n      width,\n      scale: width / 375\n    })\n  }\n})\n\n")])])]),a("p",[t._v("这样，上面的 "),a("code",[t._v("width")]),t._v("就是屏幕的实际 "),a("strong",[t._v("px 宽度")]),t._v("，而每个元素的实际 "),a("strong",[t._v("px 高度")]),t._v("则由 "),a("code",[t._v("元素 rpx 高度 / 2 * scale")]),t._v(" 得到。")]),t._v(" "),a("p",[t._v("最后，我们在页面代码中，实际使用 "),a("code",[t._v("Rain/Snow")]),t._v(" 类时的代码是下面这样的：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// weather/index.js\n// 下面是 canvas 的 canvas-id\nconst canvasId = 'effect'\nconst ctx = wx.createCanvasContext(canvasId)\nlet {width, scale} = this.data\n// 768 为 CSS 中设置的 rpx 值\nlet height = 768 / 2 * scale\nlet rain = new Rain(ctx, width, height, {\n  amount: 100,\n  speedFactor: 0.03\n})\n// 跑起来\nrain.run()\n// 如果切换了城市，不在下雨/雪，则执行\nrain.clear()\n\n")])])]),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[t._v("本节介绍使用小程序绘图 API（Canvas）绘制雨雪效果的粒子系统，给整个天气页面添加动效。")]),t._v(" "),a("p",[t._v("在使用粒子系统中应该注意小程序绘图 API 的写法跟 HTML5 中 Canvas API 的差异。除了 API 的差异，还要在绘图结束后调用 "),a("code",[t._v("ctx.draw()")]),t._v(" 使绘制执行。最后介绍了怎样在 rpx 的布局中绘制不定宽高的效果，需要根据屏幕的宽度跟 rpx 的实际比例计算出元素的实际 px 宽高，然后给 Canvas 使用。")])])}),[],!1,null,null,null);n.default=e.exports}}]);