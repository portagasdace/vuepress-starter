(window.webpackJsonp=window.webpackJsonp||[]).push([[242],{598:function(e,t,a){"use strict";a.r(t);var s=a(42),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"拓展篇-2-系统稳定性测试-使用-lab-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拓展篇-2-系统稳定性测试-使用-lab-code"}},[e._v("#")]),e._v(" 拓展篇 2：系统稳定性测试 —— 使用 Lab & Code")]),e._v(" "),a("p",[e._v("测试框架，是运行测试的工具。通过它，可以为 JavaScript 应用添加测试，从而保证代码的质量。现行的 Javascript 常用流行测试库有 Jasmine，Mocha， Karma 等，虽然框架的名称不同，但背后的核心套件却大同小异。")]),e._v(" "),a("p",[e._v("以常见的 JavaScript 单元测试框架 Mocha 为例。我们要为一个求和模块 "),a("code",[e._v("sum")]),e._v(" 方法来做一个简单的单元测试：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// sum.js\n\nmodule.exports = (x, y) => x + y\n\n// sum.test.js\n\nconst sum = require('./sum.js');\nconst expect = require('chai').expect;\n\n// 测试套件(test suite) -- describe\ndescribe('求和模块的测试', () => {\n  // 测试用例(test case) -- it\n  it('1 加 2 应该等于 3', () => {\n    // 测试断言(test expect) -- expect\n    expect(sum(1, 2)).to.be.equal(3);\n  });\n});\n\n")])])]),a("p",[e._v("由案例中的注视标记可以大致了解到单元测试的三个关键术语：")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("describe")]),e._v("：测试套件")]),e._v(" "),a("li",[a("strong",[e._v("it")]),e._v("：测试用例")]),e._v(" "),a("li",[a("strong",[e._v("expect")]),e._v("：测试断言")])]),e._v(" "),a("p",[e._v("一个完整的测试，可以由多个 describe 组成； 每个 describe 里可以包含多个 describe 或者多个 it ； 每个 it 里可以包涵多个 expect，来最终描述每个测试用例，得到最终的程序执行结果校验。")]),e._v(" "),a("p",[e._v("其他还有一些高级的属性，诸如 before / after / beforeEach / afterEach 等测试用例生命周期的钩子，以及其他特性，我们可以后续再系统学习。")]),e._v(" "),a("h2",{attrs:{id:"lab-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lab-code"}},[e._v("#")]),e._v(" Lab & Code")]),e._v(" "),a("p",[e._v("Lab & Code 是 hapi 的配套测试框架。")]),e._v(" "),a("h3",{attrs:{id:"lab"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lab"}},[e._v("#")]),e._v(" Lab")]),e._v(" "),a("p",[e._v("Lab 库支持 async/await，尽可能保持测试引擎的足够简单，并包含了我们希望从现代 Node.js 测试框架程序中需要的所有特性。提供了 describe 和 it，以及生命周期的钩子等功能。")]),e._v(" "),a("p",[e._v("Lab 仅使用 async/await 功能，并包含了你希望从现代 Node.js测试框架程序中需要的所有特性。")]),e._v(" "),a("h3",{attrs:{id:"code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#code"}},[e._v("#")]),e._v(" Code")]),e._v(" "),a("p",[e._v("Code 库用于提供 expect 断言的相关函数库，code-expect 与 mocha-expect 用法上几乎完全一致。")]),e._v(" "),a("h3",{attrs:{id:"使用-lab-code-测试求和模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-lab-code-测试求和模块"}},[e._v("#")]),e._v(" 使用 Lab & Code 测试求和模块")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// sum.js\n\nmodule.exports = (x, y) => x + y\n\n// sum.test.js\nvar const = require('./sum.js');\n// requires for testing\nconst Code        = require('code');\nconst Lab         = require('lab');\nconst lab         = Lab.script();\n\n// 测试框架方法提取\nconst describe    = lab.describe;\nconst it          = lab.it;\nconst expect      = Code.expect;\n\n// 测试套件(test suite) -- describe\ndescribe('求和模块的测试', () => {\n  // 测试用例(test case) -- it\n  it('1 加 2 应该等于 3', () => {\n    // 测试断言(test expect) -- expect\n    expect(sum(1, 2)).to.equal(3);\n  });\n});\n\n")])])]),a("p",[e._v("执行单元测试命令 "),a("code",[e._v("node node_modules/lab/bin/lab -v")]),e._v("。 "),a("code",[e._v("-v")]),e._v(" 的参数打印测试明细，在只想关注错误的测试用例结果时，可以不带上此参数，保持控制台信息输出的简洁性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  # 执行结果\n  求和模块的测试\n    ✓ 1 加 2 应该等于 3\n\n  1 tests complete\n  Test duration: 236 ms\n  No global variable leaks detected\n\n")])])]),a("h2",{attrs:{id:"在-hapi-中测试-api-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在-hapi-中测试-api-接口"}},[e._v("#")]),e._v(" 在 hapi 中测试 API 接口")]),e._v(" "),a("p",[e._v("以测试用户登录为例，我们希望测试接口的异步调用是否返回 200 的状态编码，并且返回的 response 的 result 中，签发的 JWT payload 中的信息如 userid、openid 符合预期。")]),e._v(" "),a("p",[e._v("hapi 的测试用例中，直接使用 app.inject，即服务器 server 自身的 API，来实现指定接口的调用。代码如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// users.test.js\n\nconst app = require('../app.js')\n\n// appJWT 用于暂存已登录的用户jwt，供后续需要 jwt 登录认证的测试套件使用\nlet appJWT = ''\ndescribe(\"POST: /user/login-jwt-test\", () => {  \n  it(\"状态码200并且返回了正确的jwt\", async() => {\n    const response = await app.inject({\n      method: 'POST',\n      url: '/users/login-jwt-test'\n    })\n    expect(response.statusCode).to.equal(200)\n    const JWT = require('jsonwebtoken')\n    appJWT = response.result\n    const jwtPayload = JWT.decode(response.result)\n    expect(jwtPayload.userId).to.equal(1)\n    expect(jwtPayload.openId).to.equal(1)\n  })\n})\n\n// 获取店铺列表需要用到 authorization 的 jwt 验证，语法实现如下\ndescribe(\"GET /shops\", () => {\n  it(\"状态码200\", async() => {\n    const response = await app.inject({\n      method: 'GET',\n      url: '/shops',\n      headers: {\n        authorization: appJWT\n      }\n    })\n    expect(response.statusCode).to.equal(200)  \n  })\n})\n\n")])])]),a("p",[e._v("hapi 的单元测试框架还会在执行基础测试后，贴心地检测系统中是否存在有全局变量，例如下述的全局变量声明：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("foo = 'bar';\nhello = 'hapi';\n\n")])])]),a("p",[e._v("在运行完测试后，会红字提示： "),a("em",[e._v("The following leaks were detected:foo，hello")]),e._v("，引起开发者的重视。")]),e._v(" "),a("p",[e._v("而 "),a("em",[e._v("No global variable leaks detected")]),e._v(" 的结果，则表示系统中不存在任何的全局变量，较好地确保了变量作用域的安全可靠性。")]),e._v(" "),a("h2",{attrs:{id:"常用的断言表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用的断言表达式"}},[e._v("#")]),e._v(" 常用的断言表达式")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 相等或不相等 equal()\nexpect(1 + 2).to.be.equal(3);\nexpect(1 + 2).to.be.not.equal(4);\nexpect(hello).to.be.deep.equal({ hapi: 'hapi' });\n\n// 布尔值检测 boolean\nexpect(true).to.be.true();\nexpect(false).to.not.be.false();\n\n// 数据类型检测 type\nexpect('hapi').to.be.a.string();\nexpect({ hello: 'hapi' }).to.be.an.object();\nexpect(hello).to.be.an.instanceof(Hello);\n\n// 包含检测 include\nexpect([1,2,3]).to.include(2);\nexpect('hello hapi').to.contain('hapi');\nexpect({ hello: 'hapi' }).to.include.keys('hello');\n\n// 判空检测 empty()\nexpect('').to.be.empty();\nexpect([]).to.be.empty();\nexpect({}).to.be.empty();\n\n// 正则匹配 match()\nexpect('foobar').to.match(/^foo/);\n\n// 断言条件与 and\nexpect('hello hapi').to.be.a.string().and.contain('hapi');\n\n")])])]),a("blockquote",[a("p",[a("a",{attrs:{href:"https://github.com/hapijs/code/blob/master/API.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("断言表达式详细手册"),a("OutboundLink")],1),e._v("。")])]),e._v(" "),a("h2",{attrs:{id:"coverage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coverage"}},[e._v("#")]),e._v(" coverage")]),e._v(" "),a("p",[e._v("coverage 用于量化代码的被测试的比例与程度。被测试的代码数量处以总代码量所得的比例即为覆盖率值。")]),e._v(" "),a("p",[e._v("开启测试覆盖率，可以帮助我们快速定位测试用例所未涵盖的代码区域，决定是否追加测试用例，并且高覆盖率的测试用例，能在一定程度上确保我们的系统基础可执行性。")]),e._v(" "),a("p",[e._v("执行 "),a("code",[e._v("node node_modules/lab/bin/lab -v -c")]),e._v("，追加的 "),a("code",[e._v("-c")]),e._v(" 可以额外统计测试用例的覆盖率。覆盖率的测试结果会以比例与未覆盖明细的方式输出显示。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Coverage: 92.26% (57/736)\nmodels/index.js missing coverage on line(s): 35, 41, 49, 50\nroutes/hello-hapi.js missing coverage on line(s): 8, 9\n\n")])])]),a("p",[e._v("当然，实际的项目实践中，业务型系统做得越深，代码覆盖率 100% 的实现成本也会越来越高。能效与稳定性之间的平衡点会存在一个分寸的问题，盲目追求 100% 是极度不可取的。我们有几种手法可以帮助优化 coverage 的质量。")]),e._v(" "),a("p",[e._v("1）使用 threshold")]),e._v(" "),a("p",[e._v("针对 coverage，可以设定一个 "),a("code",[e._v("-t (--threshold)")]),e._v(" 的参数，来设定一个域值。比如 "),a("code",[e._v("-t 80")]),e._v(" 表征覆盖率高于 80% 即满足要求，用来粗颗粒度降低覆盖标准。笔者以为，这样的域值调整意义不大，更多的是一种心理暗示。")]),e._v(" "),a("p",[e._v("2） 使用 "),a("code",[e._v("--coverage-exclude")]),e._v(" / "),a("code",[e._v("--coverage-path")])]),e._v(" "),a("p",[a("code",[e._v("--coverage-exclude")]),e._v(" 与 "),a("code",[e._v("--coverage-exclude")]),e._v(" 可以帮助我们直接排除或指定一些目录或是单个文件，来更加明确覆盖率所要覆盖的目标，但精度仅限于文件。一些快速迭代的局部业务级代码，或是非核心主干的代码，可以采用这种方式。")]),e._v(" "),a("p",[e._v("3） 使用 "),a("code",[e._v("/* $lab:coverage:(off|on)$ */")])]),e._v(" "),a("p",[e._v("使用 "),a("code",[e._v("/* $lab:coverage:(off|on)$ */")]),e._v(" 可以帮助我们在最终单个文件中的任意代码部分，增加一个特殊约定的表达式，来标记不需要测试覆盖的局部代码，从而提升测试的有效覆盖率。例如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/* $lab:coverage:off$ */\nif (typeof value === 'symbol') {\n    // do something with value\n}\n/* $lab:coverage:on$ */\n\n")])])]),a("h2",{attrs:{id:"使用-labrc-js-来进行配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-labrc-js-来进行配置"}},[e._v("#")]),e._v(" 使用 .labrc.js 来进行配置")]),e._v(" "),a("p",[e._v(".labrc.js 是 Lab 的直观配置文件，我们把 .labrc.js 放在当前工程目录的根目录，后续执行 Lab 的指令，将自动从 .labrc.js 中提取相应的运行参数。下面是一个简单的例子等价于执行了 "),a("code",[e._v("lab -c -t 100")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module.exports = {\n  coverage: true, //开启覆盖率测试\n  threshold: 100,  //覆盖率搁值为 100%\n};\n\n")])])]),a("blockquote",[a("p",[a("a",{attrs:{href:"https://github.com/hapijs/lab",target:"_blank",rel:"noopener noreferrer"}},[e._v("Lab 说明手册"),a("OutboundLink")],1),e._v("。")])]),e._v(" "),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),a("p",[e._v("关键词：单元测试，Lab，Code，coverage 覆盖率")]),e._v(" "),a("p",[e._v("本小节，我们介绍了如何使用 Lab & Code，解决测试用例过程中所需要解决的常见问题，从套件定义、用例声明，到最终的断言验证，并通过 coverage 量化测试用例的覆盖率。")]),e._v(" "),a("p",[e._v("基于 REST 接口的开发，一个相对好的习惯是先完成接口文档的书写。利用 hapi-swagger 和 Joi，可以高效地帮助我们完成接口文档化任务。接下来便是书写测试用例，将测试用例通过 BDD 或者 TDD 的方式，进行组合书写，最终得到一套文档完备、测试配套的良好接口。这是一个值得去持续实践优化与体会的好习惯。")]),e._v(" "),a("p",[a("strong",[e._v("本小节参考代码汇总")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/hapijs/code/blob/master/API.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("断言表达式详细手册"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/hapijs/lab",target:"_blank",rel:"noopener noreferrer"}},[e._v("Lab 说明手册"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);