(window.webpackJsonp=window.webpackJsonp||[]).push([[319],{675:function(n,e,t){"use strict";t.r(e);var a=t(42),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("现在，我们终于进入到了逻辑层的开发，之前我们已经准备好了相关的数据并且已经让组件连接，这里会省不少事情。但是整个交互的逻辑还是比较复杂的，希望大家能够提前做好心理准备，迎接这个挑战吧。")]),n._v(" "),t("p",[n._v("首先把问题拆分一下，对播放器而言，进行交互的部分无非就是两个部分：mini版和全屏版。我们先从简单一些的mini版开始入手吧。")]),n._v(" "),t("h2",{attrs:{id:"mini播放器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mini播放器"}},[n._v("#")]),n._v(" mini播放器")]),n._v(" "),t("p",[n._v("mini播放器目前依赖的数据是播放状态和播放进度数据。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const { song, fullScreen, playing, percent } = props;\n\nconst { clickPlaying, setFullScreen } = props;\n\n")])])]),t("p",[n._v("进度条这里的JSX代码也需要修改一下:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 暂停的时候唱片也停止旋转\n<img className={`play ${playing ? "": "pause"}`} src={song.al.picUrl} width="40" height="40" alt="img"/>\n\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('<ProgressCircle radius={32} percent={percent}>\n  { playing ? \n    <i className="icon-mini iconfont icon-pause" onClick={e => clickPlaying(e, false)}>&#xe650;</i>\n    :\n    <i className="icon-mini iconfont icon-play" onClick={e => clickPlaying(e, true)}>&#xe61e;</i> \n  }\n</ProgressCircle>\n\n')])])]),t("p",[n._v("当然在父组件中也要做相应修改:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const clickPlaying = (e, state) => {\n  e.stopPropagation();\n  togglePlayingDispatch(state);\n};\nreturn (\n  <div>\n    <MiniPlayer\n      song={currentSong}\n      fullScreen={fullScreen}\n      playing={playing}\n      toggleFullScreen={toggleFullScreenDispatch}\n      clickPlaying={clickPlaying}\n    />\n    <NormalPlayer \n      song={currentSong}\n      fullScreen={fullScreen}\n      playing={playing}\n      toggleFullScreen={toggleFullScreenDispatch}\n      clickPlaying={clickPlaying}\n    />\n  </div>\n)\n\n")])])]),t("h2",{attrs:{id:"初次完成播放"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初次完成播放"}},[n._v("#")]),n._v(" 初次完成播放")]),n._v(" "),t("p",[n._v("Ok, 现在我们来处理更复杂的全屏播放器部分。")]),n._v(" "),t("p",[n._v("首先定义必要的播放器属性:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//Player/index.js\n\n//目前播放时间\nconst [currentTime, setCurrentTime] = useState(0);\n//歌曲总时长\nconst [duration, setDuration] = useState(0);\n//歌曲播放进度\nlet percent = isNaN(currentTime / duration) ? 0 : currentTime / duration;\n\n")])])]),t("p",[n._v("同时需要接受redux中的currentIndex:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("  const { fullScreen, playing, currentIndex, currentSong: immutableCurrentSong } = props;\n  const { toggleFullScreenDispatch, togglePlayingDispatch, changeCurrentIndexDispatch, changeCurrentDispatch } = props;\n\n  let currentSong = immutableCurrentSong.toJS();\n\n")])])]),t("p",[n._v("我们现在的当务之急是让播放器能够播放, 所以现在我们需要放上我们的核心元素————audio标签:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//绑定ref\nconst audioRef = useRef();\n\nreturn (\n  <div>\n    //...\n    <audio ref={audioRef}></audio>\n  </div>\n)\n\n")])])]),t("p",[n._v("现在先写一些逻辑:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//mock一份playList，后面直接从 redux 拿，现在只是为了调试播放效果。\nconst playList = [\n    {\n      ftype: 0,\n      djId: 0,\n      a: null,\n      cd: '01',\n      crbt: null,\n      no: 1,\n      st: 0,\n      rt: '',\n      cf: '',\n      alia: [\n        '手游《梦幻花园》苏州园林版推广曲'\n      ],\n      rtUrls: [],\n      fee: 0,\n      s_id: 0,\n      copyright: 0,\n      h: {\n        br: 320000,\n        fid: 0,\n        size: 9400365,\n        vd: -45814\n      },\n      mv: 0,\n      al: {\n        id: 84991301,\n        name: '拾梦纪',\n        picUrl: 'http://p1.music.126.net/M19SOoRMkcHmJvmGflXjXQ==/109951164627180052.jpg',\n        tns: [],\n        pic_str: '109951164627180052',\n        pic: 109951164627180050\n      },\n      name: '拾梦纪',\n      l: {\n        br: 128000,\n        fid: 0,\n        size: 3760173,\n        vd: -41672\n      },\n      rtype: 0,\n      m: {\n        br: 192000,\n        fid: 0,\n        size: 5640237,\n        vd: -43277\n      },\n      cp: 1416668,\n      mark: 0,\n      rtUrl: null,\n      mst: 9,\n      dt: 234947,\n      ar: [\n        {\n          id: 12084589,\n          name: '妖扬',\n          tns: [],\n          alias: []\n        },\n        {\n          id: 12578371,\n          name: '金天',\n          tns: [],\n          alias: []\n        }\n      ],\n      pop: 5,\n      pst: 0,\n      t: 0,\n      v: 3,\n      id: 1416767593,\n      publishTime: 0,\n      rurl: null\n    }\n];\nuseEffect(() => {\n  if(!currentSong) return;\n  changeCurrentIndexDispatch(0);//currentIndex默认为-1，临时改成0\n  let current = playList[0];\n  changeCurrentDispatch(current);//赋值currentSong\n  audioRef.current.src = getSongUrl(current.id);\n  setTimeout(() => {\n    audioRef.current.play();\n  });\n  togglePlayingDispatch(true);//播放状态\n  setCurrentTime(0);//从头开始播放\n  setDuration((current.dt / 1000) | 0);//时长\n}, []);\n\n")])])]),t("p",[n._v("其中，getSongUrl为一个封装在api/utils.js中的方法:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//拼接出歌曲的url链接\nexport const getSongUrl = id => {\n  return `https://music.163.com/song/media/outer/url?id=${id}.mp3`;\n};\n\n")])])]),t("p",[n._v("引入:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('import { getSongUrl } from "../../api/utils";\n\n')])])]),t("p",[n._v("但是你现在会看到这样的报错信息:")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/16/16fac32579302b6b?w=473&h=23&f=jpeg&s=6902",alt:""}})]),n._v(" "),t("p",[n._v("这是因为初始化store数据的时候，currentSong是一个空对象，song.al为undefined, 因此song.al.picUrl就会报错。")]),n._v(" "),t("p",[n._v("那怎么来规避这个问题呢？")]),n._v(" "),t("p",[n._v("很简单，我们在渲染播放器的时候判断一下currentSong是否对空对象就可以了。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('import { isEmptyObject } from "../../api/utils";\n\n//JSX\nreturn (\n  <div>\n    { isEmptyObject(currentSong) ? null : \n      <MiniPlayer\n        song={currentSong}\n        fullScreen={fullScreen}\n        playing={playing}\n        toggleFullScreen={toggleFullScreenDispatch}\n        clickPlaying={clickPlaying}\n      /> \n    }\n    { isEmptyObject(currentSong) ? null : \n      <NormalPlayer\n        song={currentSong}\n        fullScreen={fullScreen}\n        playing={playing}\n        toggleFullScreen={toggleFullScreenDispatch}\n        clickPlaying={clickPlaying}\n      />\n    }\n    <audio ref={audioRef}></audio>\n  </div>\n)\n\n')])])]),t("p",[n._v("好，现在你打开项目应该可以听到背景音乐了，现在我们迈出了第一步。接下来就是一步步不断地完善播放的逻辑。")]),n._v(" "),t("h2",{attrs:{id:"播放和暂停"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#播放和暂停"}},[n._v("#")]),n._v(" 播放和暂停")]),n._v(" "),t("p",[n._v("首先是播放和暂停的逻辑。")]),n._v(" "),t("p",[n._v("其实之前已经完成，只不过没有和audio元素对接。现在通过监听playing变量来实现:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("useEffect(() => {\n  playing ? audioRef.current.play() : audioRef.current.pause();\n}, [playing]);\n\n")])])]),t("p",[n._v("现在在mini播放器可以看到效果，但是normalPlayer里面却没反应，现在补充上里面的逻辑。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//normalPlayer/index.js\nconst { song, fullScreen, playing } =  props;\nconst { toggleFullScreen, clickPlaying } = props;\n\n//JSX中的修改\n//CdWrapper下唱片图片\n<div className="cd">\n  <img\n    className={`image play ${playing ? "" : "pause"}`}\n    src={song.al.picUrl + "?param=400x400"}\n    alt=""\n  />\n</div>\n//中间暂停按钮\n<div className="icon i-center">\n  <i\n    className="iconfont"\n    onClick={e => clickPlaying(e, !playing)}\n    dangerouslySetInnerHTML={{\n      __html: playing ? "&#xe723;" : "&#xe731;"\n    }}\n  ></i>\n</div>\n\n')])])]),t("h2",{attrs:{id:"进度控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进度控制"}},[n._v("#")]),n._v(" 进度控制")]),n._v(" "),t("p",[n._v("之前写的播放时间都是mock数据, 现在填充成动态数据。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//父组件传值\n<NormalPlayer\n  song={currentSong}\n  fullScreen={fullScreen}\n  playing={playing}\n  duration={duration}//总时长\n  currentTime={currentTime}//播放时间\n  percent={percent}//进度\n  toggleFullScreen={toggleFullScreenDispatch}\n  clickPlaying={clickPlaying}\n/>\n\n")])])]),t("p",[n._v("同时有一点需要注意，就是audio标签在播放的过程中会不断地触发onTimeUpdate事件，在此需要更新currentTime变量。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const updateTime = e => {\n  setCurrentTime(e.target.currentTime);\n};\n//JSX\n<audio\n  ref={audioRef}\n  onTimeUpdate={updateTime}\n></audio>\n\n")])])]),t("p",[n._v("现在在normalPlayer中：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const { song, fullScreen, playing, percent, duration, currentTime } =  props;\nconst { toggleFullScreen, clickPlaying, onProgressChange } = props;\n\n//相应属性传给进度条\n<ProgressWrapper>\n  <span className="time time-l">{formatPlayTime(currentTime)}</span>\n  <div className="progress-bar-wrapper">\n    <ProgressBar\n      percent={percent}\n      percentChange={onProgressChange}\n    ></ProgressBar>\n  </div>\n  <div className="time time-r">{formatPlayTime(duration)}</div>\n</ProgressWrapper>\n\n')])])]),t("p",[n._v("ps: 其中，formatPlayTime为api/utils.js中的一个工具函数：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//转换歌曲播放时间\nexport const formatPlayTime = interval => {\n  interval = interval | 0;// |0表示向下取整\n  const minute = (interval / 60) | 0;\n  const second = (interval % 60).toString().padStart(2, "0");\n  return `${minute}:${second}`;\n};\n\n')])])]),t("p",[n._v("我要强调的重点是传给ProgressBar的两个参数，一个是percent，用来控制进度条的显示长度，另一个是onProgressChange，这个其实是一个进度条被滑动或点击时用来改变percent的回调函数。我们在父组件来定义它：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const onProgressChange = curPercent => {\n  const newTime = curPercent * duration;\n  setCurrentTime(newTime);\n  audioRef.current.currentTime = newTime;\n  if (!playing) {\n    togglePlayingDispatch(true);\n  }\n};\n\n//父组件传值\n<NormalPlayer\n  //...\n  onProgressChange={onProgressChange}\n/>\n\n")])])]),t("p",[n._v("那么之前封装的进度条组件并没有处理percent相关的逻辑，现在在进度条组件中来增加。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const transform = prefixStyle('transform');\n\nconst { percent } = props;\n\nconst { percentChange } = props;\n\n//监听percent\nuseEffect(() => {\n  if(percent >= 0 && percent <= 1 && !touch.initiated) {\n    const barWidth = progressBar.current.clientWidth - progressBtnWidth;\n    const offsetWidth = percent * barWidth;\n    progress.current.style.width = `${offsetWidth}px`;\n    progressBtn.current.style[transform] = `translate3d(${offsetWidth}px, 0, 0)`;\n  }\n  // eslint-disable-next-line\n}, [percent]);\n\nconst _changePercent = () => {\n  const barWidth = progressBar.current.clientWidth - progressBtnWidth;\n  const curPercent = progress.current.clientWidth / barWidth;\n  percentChange(curPercent);\n}\n\n//点击和滑动结束事件改变percent\nconst progressClick = (e) => {\n  //...\n  _changePercent();\n}\n\nconst progressTouchEnd = (e) => {\n  //...\n  _changePercent();\n}\n\n")])])]),t("p",[n._v("OK, 进度条被我们改了差不多了，现在就能够对接我们的播放器进度啦！")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/16/16fac32f825fb728?w=372&h=60&f=gif&s=88277",alt:""}})]),n._v(" "),t("p",[n._v("在最后，我们也把mini播放器的进度对接一下:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//父组件传值\n<MiniPlayer\n  //...\n  percent={percent}\n></MiniPlayer>\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//miniPlayer/index.js\nconst { full, song, playing, percent } = props;\n\n//JSX\n<ProgressCircle radius={32} percent={percent}>\n//...\n\n")])])]),t("p",[n._v("做到这里大家可以完完整整地听一首歌了，实在不容易，接下来还有上一曲和下一曲的功能，我们慢慢来。")]),n._v(" "),t("h2",{attrs:{id:"上下曲切换逻辑"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#上下曲切换逻辑"}},[n._v("#")]),n._v(" 上下曲切换逻辑")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//一首歌循环\nconst handleLoop = () => {\n  audioRef.current.currentTime = 0;\n  changePlayingState(true);\n  audioRef.current.play();\n};\n\nconst handlePrev = () => {\n  //播放列表只有一首歌时单曲循环\n  if (playList.length === 1) {\n    handleLoop();\n    return;\n  }\n  let index = currentIndex - 1;\n  if (index < 0) index = playList.length - 1;\n  if (!playing) togglePlayingDispatch(true);\n  changeCurrentIndexDispatch(index);\n};\n\nconst handleNext = () => {\n  //播放列表只有一首歌时单曲循环\n  if (playList.length === 1) {\n    handleLoop();\n    return;\n  }\n  let index = currentIndex + 1;\n  if (index === playList.length) index = 0;\n  if (!playing) togglePlayingDispatch(true);\n  changeCurrentIndexDispatch(index);\n};\n\n")])])]),t("p",[n._v("这部分逻辑传给normalPlayer:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//传递给normalPlayer\nhandlePrev={handlePrev}\nhandleNext={handleNext}\n\n")])])]),t("p",[n._v("在normalPlayer中绑定按钮点击事件:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('const { toggleFullScreen, clickPlaying, onProgressChange, handlePrev, handleNext } = props;\n\n//JSX\n<div className="icon i-left" onClick={handlePrev}>\n  <i className="iconfont">&#xe6e1;</i>\n</div>\n//...\n<div className="icon i-right" onClick={handleNext}>\n  <i className="iconfont">&#xe718;</i>\n</div>\n\n')])])]),t("p",[n._v("现在我们把父组件中控制歌曲播放的的逻辑完善一下:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//记录当前的歌曲，以便于下次重渲染时比对是否是一首歌\nconst [preSong, setPreSong] = useState({});\n\n//先mock一份currentIndex\nuseEffect(() => {\n  changeCurrentIndexDispatch(0);\n}, [])\n\nuseEffect(() => {\n  if (\n    !playList.length ||\n    currentIndex === -1 ||\n    !playList[currentIndex] ||\n    playList[currentIndex].id === preSong.id \n  )\n    return;\n  let current = playList[currentIndex];\n  changeCurrentDispatch(current);//赋值currentSong\n  setPreSong(current);\n  audioRef.current.src = getSongUrl(current.id);\n  setTimeout(() => {\n    audioRef.current.play();\n  });\n  togglePlayingDispatch(true);//播放状态\n  setCurrentTime(0);//从头开始播放\n  setDuration((current.dt / 1000) | 0);//时长\n}, [playList, currentIndex]);\n\n")])])]),t("h2",{attrs:{id:"播放模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#播放模式"}},[n._v("#")]),n._v(" 播放模式")]),n._v(" "),t("p",[n._v("分三种: 单曲循环、顺序循环和随机播放")]),n._v(" "),t("p",[n._v("我们先在Player/index.js，也就是父组件中写相应逻辑：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//从props中取redux数据和dispatch方法\nconst {\n  playing,\n  currentSong:immutableCurrentSong,\n  currentIndex,\n  playList:immutablePlayList,\n  mode,//播放模式\n  sequencePlayList:immutableSequencePlayList,//顺序列表\n  fullScreen\n} = props;\n\nconst {\n  togglePlayingDispatch,\n  changeCurrentIndexDispatch,\n  changeCurrentDispatch,\n  changePlayListDispatch,//改变playList\n  changeModeDispatch,//改变mode\n  toggleFullScreenDispatch\n} = props;\n\nconst playList = immutablePlayList.toJS();\nconst sequencePlayList = immutableSequencePlayList.toJS();\nconst currentSong = immutableCurrentSong.toJS();\n\n")])])]),t("p",[n._v("现在的需求是点击normalPlayer最左边的按钮，能够切换播放模式，我们现在在父组件写相应的逻辑。")]),n._v(" "),t("p",[n._v("顺便说一句。不知道你发现没有: 关于业务逻辑的部分都是在父组件完成然后直接传给子组件，而子组件虽然也有自己的状态，但大部分是控制UI层面的，逻辑都是从props中接受， 这也是在潜移默化中给大家展示了UI和逻辑分离的组件设计模式。通过分离关注点，解耦不同的模块，能够大量节省开发和维护成本。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//Player/index\nconst changeMode = () => {\n  let newMode = (mode + 1) % 3;\n  if (newMode === 0) {\n    //顺序模式\n    changePlayListDispatch(sequencePlayList);\n    let index = findIndex(currentSong, sequencePlayList);\n    changeCurrentIndexDispatch(index);\n  } else if (newMode === 1) {\n    //单曲循环\n    changePlayListDispatch(sequencePlayList);\n  } else if (newMode === 2) {\n    //随机播放\n    let newList = shuffle(sequencePlayList);\n    let index = findIndex(currentSong, newList);\n    changePlayListDispatch(newList);\n    changeCurrentIndexDispatch(index);\n  }\n  changeModeDispatch(newMode);\n};\n\n")])])]),t("p",[n._v("目前的播放列表是在组件内mock的，现在已经不太合适，我们把mock列表移动到reducer中的defaultState中，这里就不展示了，要注意playList和sequenceList都要mock并且mock一样的数据。")]),n._v(" "),t("p",[n._v("接下来我们来解释一下changeMode中的内容,findIndex方法用来找出歌曲在对应列表中的索引，shuffle方法用来打乱一个列表，达成随机列表的效果，这两个函数都定义在api/utils.js中。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n// 随机算法\nexport function shuffle(arr) {\n  let new_arr = [];\n  arr.forEach(item => {\n    new_arr.push(item);\n  });\n  for (let i = 0; i < new_arr.length; i++) {\n    let j = getRandomInt(0, i);\n    let t = new_arr[i];\n    new_arr[i] = new_arr[j];\n    new_arr[j] = t;\n  }\n  return new_arr;\n}\n\n// 找到当前的歌曲索引\nexport const findIndex = (song, list) => {\n  return list.findIndex(item => {\n    return song.id === item.id;\n  });\n};\n\n")])])]),t("p",[n._v("引入到父组件:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('import { getSongUrl, isEmptyObject, shuffle, findIndex } from "../../api/utils";\n\n')])])]),t("p",[n._v("接下来我们给normalPlayer传入:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("<NormalPlayer\n  //...\n  mode={mode}\n  changeMode={changeMode}\n/>\n\n")])])]),t("p",[n._v("现在就需要对normalPlayer做一些事情了：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//Operator标签下\n<div className="icon i-left" onClick={changeMode}>\n  <i\n    className="iconfont"\n    dangerouslySetInnerHTML={{ __html: getPlayMode() }}\n  ></i>\n</div>\n\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//getPlayMode方法\nconst getPlayMode = () => {\n  let content;\n  if (mode === playMode.sequence) {\n    content = "&#xe625;";\n  } else if (mode === playMode.loop) {\n    content = "&#xe653;";\n  } else {\n    content = "&#xe61b;";\n  }\n  return content;\n};\n\n\n')])])]),t("p",[n._v("其中playMode常量我们已经定义过，直接引入:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import { playMode } from '../../../api/config';\n\n")])])]),t("p",[n._v("现在大家打开redux-devtools可以看到数据的变化，下面是随机模式")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/16/16fac33621418e87?w=590&h=522&f=jpeg&s=65672",alt:""}})]),n._v(" "),t("p",[n._v("可以看到playList现在已经乱序了。")]),n._v(" "),t("p",[n._v("功能是实现了，但是只有一个图标放在这里，可能很多用户不知道是什么意思，如果能够文字提示一下，体验会更好一些。废话不多说，直接开始封装崭新的Toast组件，这里只是由于是侧重项目， 不可能将Toast的功能面面俱到，只是让大家体会一下封装的过程，以此来提升自己的内功，这也是我不用UI框架的原因。")]),n._v(" "),t("p",[n._v("在baseUI目录下新建Toast文件夹:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//Toast/index.js\nimport React, {useState, useImperativeHandle, forwardRef} from 'react';\nimport styled from 'styled-components';\nimport { CSSTransition } from 'react-transition-group';\nimport style from '../../assets/global-style';\n\nconst ToastWrapper = styled.div`\n  position: fixed;\n  bottom: 0;\n  z-index: 1000;\n  width: 100%;\n  height: 50px;\n  /* background: ${style[\"highlight-background-color\"]}; */\n  &.drop-enter{\n    opacity: 0;\n    transform: translate3d(0, 100%, 0);\n  }\n  &.drop-enter-active{\n    opacity: 1;\n    transition: all 0.3s;\n    transform: translate3d(0, 0, 0);\n  }\n  &.drop-exit-active{\n    opacity: 0;\n    transition: all 0.3s;\n    transform: translate3d(0, 100%, 0);\n  }\n  .text{\n    line-height: 50px;\n    text-align: center;\n    color: #fff;\n    font-size: ${style[\"font-size-l\"]};\n  }\n`\n//外面组件需要拿到这个函数组件的ref，因此用forwardRef\nconst Toast = forwardRef((props, ref) => {\n  const [show, setShow] = useState(false);\n  const [timer, setTimer] = useState('');\n  const {text} = props;\n  //外面组件拿函数组件ref的方法，用useImperativeHandle这个hook\n  useImperativeHandle(ref, () => ({\n    show() {\n      // 做了防抖处理\n      if(timer) clearTimeout(timer);\n      setShow(true);\n      setTimer(setTimeout(() => {\n        setShow(false)\n      }, 3000));\n    }\n  }))\n  return (\n    <CSSTransition in={show} timeout={300} classNames=\"drop\" unmountOnExit>\n      <ToastWrapper>\n        <div className=\"text\">{text}</div>\n      </ToastWrapper>\n    </CSSTransition>\n  )\n});\n\nexport default React.memo(Toast);\n\n")])])]),t("p",[n._v("现在放到Player/index.js中使用:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('import Toast from "./../../baseUI/toast/index";\n\n//...\nconst [modeText, setModeText] = useState("");\n\nconst toastRef = useRef();\n\n//...\nconst changeMode = () => {\n  let newMode = (mode + 1) % 3;\n  if (newMode === 0) {\n    //...\n    setModeText("顺序循环");\n  } else if (newMode === 1) {\n    //...\n    setModeText("单曲循环");\n  } else if (newMode === 2) {\n    //...\n    setModeText("随机播放");\n  }\n  changeModeDispatch(newMode);\n  toastRef.current.show();\n};\n\n//JSX\nreturn (\n  <div>\n    //...\n    <Toast text={modeText} ref={toastRef}></Toast>  \n  </div>\n)\n\n')])])]),t("p",[n._v("效果:")]),n._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/16/16fac3421b9d1c07?w=372&h=133&f=gif&s=185323",alt:""}})]),n._v(" "),t("p",[n._v("那现在还有最后一个问题需要处理，就是歌曲播放完了之后，紧接着需要怎么处理。")]),n._v(" "),t("p",[n._v("我们回到父组件，把这个处理逻辑写在audio标签的onEnded事件回调中:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("<audio\n  ref={audioRef}\n  onTimeUpdate={updateTime}\n  onEnded={handleEnd}\n></audio>\n\n")])])]),t("p",[n._v("由于之前封装了下一曲和单曲循环的逻辑，这里就非常简单了。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import { playMode } from '../../api/config';\n//...\nconst handleEnd = () => {\n  if (mode === playMode.loop) {\n    handleLoop();\n  } else {\n    handleNext();\n  }\n};\n\n")])])]),t("p",[n._v("OK，到这里，mini/全屏播放器基本的功能都完成了！")])])}),[],!1,null,null,null);e.default=r.exports}}]);