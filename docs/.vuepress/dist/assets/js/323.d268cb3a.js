(window.webpackJsonp=window.webpackJsonp||[]).push([[323],{678:function(e,t,a){"use strict";a.r(t);var n=a(42),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("上一节我们已经知道，shouldComponentUpdate 是我们进行性能优化的利器，我们之后的优化方案都会基于它来进行。")]),e._v(" "),a("h2",{attrs:{id:"优化方案一-purecomponent-memo-进行浅层比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化方案一-purecomponent-memo-进行浅层比较"}},[e._v("#")]),e._v(" 优化方案一：PureComponent (memo) 进行浅层比较")]),e._v(" "),a("p",[e._v("上一节我埋下了一个伏笔，就是 PureComponent 或者 memo 将会进行新旧数据的浅层比对。你可能会比较好奇，浅层比较是怎么比较的呢？口说无凭，我觉得让大家直观地感受一下比较重要，所以我暂且扒出 PureComponent 浅比较部分的核心源码让大家体会一下，大家不用紧张，其实逻辑非常简单。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function shallowEqual (objA: mixed, objB: mixed): boolean {\n  // 下面的 is 相当于 === 的功能，只是对 + 0 和 - 0，以及 NaN 和 NaN 的情况进行了特殊处理\n  // 第一关：基础数据类型直接比较出结果\n  if (is (objA, objB)) {\n    return true;\n  }\n  // 第二关：只要有一个不是对象数据类型就返回 false\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  // 第三关：在这里已经可以保证两个都是对象数据类型，比较两者的属性数量\n  const keysA = Object.keys (objA);\n  const keysB = Object.keys (objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // 第四关：比较两者的属性是否相等，值是否相等\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !hasOwnProperty.call (objB, keysA [i]) ||\n      !is (objA [keysA [i]], objB [keysA [i]])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n")])])]),a("p",[e._v("从我写的注释可以看出，在这里开启了四道关卡，但终究还是浅层比较。在下面的情况会判断失灵。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// 调用 state.a.push("2")\nstate: {a: ["1"]} -> state: {a: ["1", "2"]}\n\n')])])]),a("p",[e._v("其实 a 数组已经改变了，但是浅层比较会表示没有改变，因为数组的引用没有变。看到没有？一旦属性的值为引用类型的时候浅比较就失灵了。")]),e._v(" "),a("p",[e._v("这就是这种方式最大的弊端，由于 JS 引用赋值的原因，这种方式仅仅适用于无状态组件或者状态数据非常简单的组件，对于大量的应用型组件，它是无能为力的。")]),e._v(" "),a("h2",{attrs:{id:"优化方案二-shouldcomponentupdate-中进行深层比对"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化方案二-shouldcomponentupdate-中进行深层比对"}},[e._v("#")]),e._v(" 优化方案二:shouldComponentUpdate 中进行深层比对")]),e._v(" "),a("p",[e._v("为了解决方案一带来的问题，我们现在不做浅层比对了，我们把 props 中所有的属性和值进行递归比对。")]),e._v(" "),a("p",[e._v("我们把上面浅层比对的代码进行一些魔改:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" function deepEqual (objA: mixed, objB: mixed): boolean {\n  // 下面的 is 相当于 === 的功能，只是对 + 0 和 - 0，以及 NaN 和 NaN 的情况进行了特殊处理\n  // 第一关：保证两者都是基本数据类型。基础数据类型直接比较出结果。\n  // 对象类型咱就不比了\n  if (objA == null && objB == null) return true;\n  if (typeof objA !== 'object' &&\n      typeof objB !== 'object' &&\n      is (objA, objB)) {\n    return true;\n  }\n  // 第二关：只要有一个不是对象数据类型就返回 false\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  // 第三关：在这里已经可以保证两个都是对象数据类型，比较两者的属性数量\n  const keysA = Object.keys (objA);\n  const keysB = Object.keys (objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // 第四关：比较两者的属性是否相等，值是否相等\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !hasOwnProperty.call (objB, keysA [i]) ||\n      !is (objA [keysA [i]], objB [keysA [i]])\n    ) {\n      return false;\n    } else {\n        if (!deepEqual (objA [keysA [i]], objB [keysA [i]])){\n            return false;\n        }\n    }\n  }\n\n  return true;\n}\n\n")])])]),a("p",[e._v("当访问到对象的属性值的时候，将属性值再进行递归比对，这样就达到了深层比对的效果。但是想想一种极端的情况，就是在属性有一万条的时候，只有最后一个属性发生了变化，那我们就不得已将一万条属性都遍历。这是非常浪费性能的。")]),e._v(" "),a("h2",{attrs:{id:"优化方案-3-immutable-数据结构-scu-memo-浅层比对"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化方案-3-immutable-数据结构-scu-memo-浅层比对"}},[e._v("#")]),e._v(" 优化方案 3: immutable 数据结构 + SCU (memo) 浅层比对")]),e._v(" "),a("p",[e._v("回到问题的本质，无论是直接用浅层比对，还是进行深层比对，我们最终是想z知道组件的 props (或 state) 数据有无发生改变。")]),e._v(" "),a("p",[e._v("在这样的条件下，immutable 数据应运而生。")]),e._v(" "),a("h3",{attrs:{id:"什么是-immutable-数据-它有什么优势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-immutable-数据-它有什么优势"}},[e._v("#")]),e._v(" 什么是 immutable 数据？它有什么优势？")]),e._v(" "),a("p",[e._v("immutable 数据一种利用结构共享形成的持久化数据结构，一旦有部分被修改，那么将会返回一个全新的对象，并且原来相同的节点会直接共享。")]),e._v(" "),a("p",[e._v("具体点来说，immutable 对象数据内部采用是多叉树的结构，凡是有节点被改变，那么它和与它相关的所有上级节点都更新。")]),e._v(" "),a("p",[e._v("用一张动图来模拟一下这个过程：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/20/16de7a154c8b30b8?w=613&h=575&f=webp&s=294850",alt:""}})]),e._v(" "),a("p",[e._v("是吧！只更新了父节点，比直接比对所有的属性简直强太多，并且更新后返回了一个全新的引用，即使是浅比对也能感知到数据的改变。")]),e._v(" "),a("p",[e._v("因此，采用 immutable 既能够最大效率地更新数据结构，又能够和现有的 PureComponent (memo) 顺利对接，感知到状态的变化，是提高 React 渲染性能的极佳方案。")]),e._v(" "),a("p",[e._v("不过有一说一，immutable 也有一些被部分开发者吐槽的点，首先是 immutable 对象和 JS 对象要注意转换，不能混用，这个大家注意适当的时候调用 toJS 或者 fromJS 即可，问题并不大。")]),e._v(" "),a("p",[e._v("其次就是对于 immutable API 的学习成本的争议。我觉得这个问题见仁见智吧，我的观点是：如果你目前沉溺在已经运用得非常熟练的技术栈当中，不说深入学习新技术，连新的 API 都懒得学，我觉得对个人成长来说是一个不太好的征兆。")]),e._v(" "),a("p",[e._v("而且，项目中涉及的 api 并没有那么复杂，完全没必要从头到尾把 immutable.js 的 Api 全都记住。接下来我们就来悉数一下项目将要用到的 immutable 的功能。")]),e._v(" "),a("h3",{attrs:{id:"项目中涉及的-immutable-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目中涉及的-immutable-方法"}},[e._v("#")]),e._v(" 项目中涉及的 immutable 方法")]),e._v(" "),a("h4",{attrs:{id:"_1-fromjs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-fromjs"}},[e._v("#")]),e._v(" 1.fromJS")]),e._v(" "),a("p",[e._v("它的功能是将 JS 对象转换为 immutable 对象。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import {fromJS} from 'immutable';\nconst immutableState = fromJS ({\n    count: 0\n});\n\n")])])]),a("p",[e._v("大家以后会经常在 redux 的 reducer 文件中看到这个 api, 是 immutable 库当中导出的方法。")]),e._v(" "),a("h4",{attrs:{id:"_2-tojs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-tojs"}},[e._v("#")]),e._v(" 2. toJS")]),e._v(" "),a("p",[e._v("和 fromJS 功能刚好相反，用来将 immutable 对象转换为 JS 对象。但是值得注意的是，这个方法并没有在 immutable 库中直接导出，而是需要让 immutable 对象调用。比如:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const jsObj = immutableState.toJS ();\n\n")])])]),a("h4",{attrs:{id:"_3-get-getin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-get-getin"}},[e._v("#")]),e._v(" 3.get/getIn")]),e._v(" "),a("p",[e._v("用来获取 immutable 对象属性。通过与 JS 对象的对比来体会一下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//JS 对象\nlet jsObj = {a: 1};\nlet res = jsObj.a;\n//immutable 对象\nlet immutableObj = fromJS (jsObj);\nlet res = immutableObj.get ('a');\n\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("//JS 对象\nlet jsObj = {a: {b: 1}};\nlet res = jsObj.a.b;\n//immutable 对象\nlet immutableObj = fromJS (jsObj);\nlet res = immutableObj.getIn (['a', 'b']);// 注意传入的是一个数组\n\n")])])]),a("h4",{attrs:{id:"_4-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-set"}},[e._v("#")]),e._v(" 4.set")]),e._v(" "),a("p",[e._v("用来对 immutable 对象的属性赋值。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let immutableObj = fromJS ({a: 1});\nimmutableObj.set ('a', 2);\n\n")])])]),a("h4",{attrs:{id:"_5-merge"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-merge"}},[e._v("#")]),e._v(" 5. merge")]),e._v(" "),a("p",[e._v("新数据与旧数据对比，旧数据中不存在的属性直接添加，旧数据中已存在的属性用新数据中的覆盖。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let immutableObj = fromJS ({a: 1});\nimmutableObj.merge ({\n    a: 2,\n    b: 3\n});// 修改了 a 属性，增加了 b 属性\n\n")])])]),a("p",[e._v("好了，到这里项目中为什么要使用 immutable 数据以及基本的使用就给大家讲清楚了，欢迎大家在留言区与我交流。接下来我们正式进入到实战部分。")])])}),[],!1,null,null,null);t.default=s.exports}}]);