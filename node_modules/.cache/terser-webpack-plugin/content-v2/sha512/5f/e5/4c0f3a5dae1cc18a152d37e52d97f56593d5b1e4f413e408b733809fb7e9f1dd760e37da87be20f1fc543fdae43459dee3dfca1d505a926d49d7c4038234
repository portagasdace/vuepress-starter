{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[353],{707:function(e,n,s){\"use strict\";s.r(n);var r=s(42),t=Object(r.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[s(\"h2\",{attrs:{id:\"导读\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#导读\"}},[e._v(\"#\")]),e._v(\" 导读\")]),e._v(\" \"),s(\"p\",[e._v(\"本节标题：「建造毛坯」- 开发体验升级\")]),e._v(\" \"),s(\"p\",[e._v(\"本节主旨：工欲善其事，必先利其器，构建开发环境，提高开发体验，实现双端代码的自动编译以及服务的自动重启（手动实现多进程模型）\")]),e._v(\" \"),s(\"p\",[e._v(\"本节配套代码:\")]),e._v(\" \"),s(\"p\",[s(\"a\",{attrs:{href:\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr1\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr1\"),s(\"OutboundLink\")],1)]),e._v(\" \"),s(\"h1\",{attrs:{id:\"正文\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#正文\"}},[e._v(\"#\")]),e._v(\" 正文\")]),e._v(\" \"),s(\"p\",[e._v(\"前几节我们了解并实现了组件的直出和基本同构，完成了一个组件在服务端和浏览器端的渲染，并且实现了基本的交互-绑定事件。但这毕竟只能是算是\"),s(\"code\",[e._v(\"demo\")]),e._v(\",用于实际的项目开发还差的远。\")]),e._v(\" \"),s(\"p\",[e._v(\"所以从本节正式开始建造 \"),s(\"code\",[e._v(\"react ssr\")]),e._v(\" 同构应用开发骨架，如同开始建造房子的骨架。\")]),e._v(\" \"),s(\"p\",[e._v(\"要想这个骨架能用于实际项目开发，最基本的就是要开发方便，用起来省事儿，另一个就是具备一些基础的能力，让我们只专注于业务开发。\")]),e._v(\" \"),s(\"p\",[s(\"strong\",[e._v(\"哪些能力呢？\")])]),e._v(\" \"),s(\"p\",[e._v(\"比如路由处理、副作用处理、seo支持、css 支持等。\")]),e._v(\" \"),s(\"p\",[e._v(\"现在从头开始吗？\")]),e._v(\" \"),s(\"p\",[e._v(\"前两节的内容呢？\")]),e._v(\" \"),s(\"p\",[e._v(\"当然不是，每一个小结都是层层递进的，都作为后面小结的基础，都是我们建造骨架的重要组成部分。\")]),e._v(\" \"),s(\"p\",[e._v(\"基于前几节的内容，同时为了方便后续的开发和调试，我们先来让这个项目的使用变得方便一些，就像是建房子的工具，不然咱们这个房子盖的太累，浪费时间和精力。\")]),e._v(\" \"),s(\"p\",[e._v(\"怎样才能更方便呢？\")]),e._v(\" \"),s(\"h1\",{attrs:{id:\"工程化支持第一步\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#工程化支持第一步\"}},[e._v(\"#\")]),e._v(\" 工程化支持第一步\")]),e._v(\" \"),s(\"p\",[e._v(\"大家有没有发现我们现在的 \"),s(\"code\",[e._v(\"demo\")]),e._v(\"存在严重的体验问题。\")]),e._v(\" \"),s(\"p\",[e._v(\"服务的运行需要经过多次手动操作。\")]),e._v(\" \"),s(\"p\",[e._v(\"前端代码的构建需要手动执行编译\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"npm run dev\\n\\n\")])])]),s(\"p\",[e._v(\"服务端代码的编译需要手动执行编译\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"npm run babel-node\\n\\n\")])])]),s(\"p\",[e._v(\"最后手动启动服务\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"node app.js\\n\\n\")])])]),s(\"p\",[e._v(\"后续的文件改动还要重新执行上面的步骤。\")]),e._v(\" \"),s(\"p\",[e._v(\"大家可以自行运行起来，体验一下这个过程。\")]),e._v(\" \"),s(\"p\",[s(\"code\",[e._v(\"工欲善其事，必先利其器\")])]),e._v(\" \"),s(\"p\",[e._v(\"这种开发体验太差了，会浪费我们很多时间且严重影响心情，良好的开发体验可以让我们事半功倍，心情舒畅。\")]),e._v(\" \"),s(\"p\",[e._v(\"既然这样，那我们势必需要进行优化，通过程序或者工具来代替人工执行，以达到提升效率的目的。\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"确定优化目标\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#确定优化目标\"}},[e._v(\"#\")]),e._v(\" 确定优化目标\")]),e._v(\" \"),s(\"p\",[e._v(\"如何实现这个优化呢？\")]),e._v(\" \"),s(\"p\",[e._v(\"做之前我们先进行问题分析，然后设计出一套解决方案。\")]),e._v(\" \"),s(\"p\",[e._v(\"首先要明确我们想达到的一个具体的目标。\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"前后端代码可以自动编译\")]),e._v(\" \"),s(\"li\",[e._v(\"每次修改代码，\"),s(\"code\",[e._v(\"node\")]),e._v(\" 服务可以自动重启\")])]),e._v(\" \"),s(\"p\",[e._v(\"另外我也不想自己刷新页面，所以热更新也是必须的，不过本节不打算直接介绍热更新，在后面章节会介绍。\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"实现思路分析\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现思路分析\"}},[e._v(\"#\")]),e._v(\" 实现思路分析\")]),e._v(\" \"),s(\"p\",[s(\"strong\",[e._v(\"前端代码构建体验优化\")])]),e._v(\" \"),s(\"p\",[e._v(\"前端代码的构建可以使用 \"),s(\"code\",[e._v(\"webpack\")]),e._v(\" 搞定，开启 \"),s(\"code\",[e._v(\"watch\")]),e._v(\" 功能就可以了，更改了文件就会自动打包。\")]),e._v(\" \"),s(\"p\",[s(\"strong\",[e._v(\"后端代码构建\")])]),e._v(\" \"),s(\"p\",[e._v(\"后端代码这里分为两部分，一个是用来处理请求的 \"),s(\"code\",[e._v(\"node\")]),e._v(\" 代码，只运行于服务端。\")]),e._v(\" \"),s(\"p\",[e._v(\"另一部分就是组件以及组件相关的代码，也需要在服务端运行来完成组件的 \"),s(\"code\",[e._v(\"ssr\")]),e._v(\"，所以我们也需要打包一份给服务端使用。\")]),e._v(\" \"),s(\"p\",[e._v(\"在上一节我们使用的是\"),s(\"code\",[e._v(\"babel cli\")]),e._v(\"来编译的，当然这是一个有效的方法，还有一个更好的办法就是使用\"),s(\"code\",[e._v(\"webpack\")]),e._v(\"来编译。\")]),e._v(\" \"),s(\"p\",[e._v(\"诶？也能用\"),s(\"code\",[e._v(\"webpapck\")]),e._v(\"?\")]),e._v(\" \"),s(\"p\",[e._v(\"不要以为\"),s(\"code\",[e._v(\"webpack\")]),e._v(\"只能用于前端代码的构建，一切皆模块，只要是 \"),s(\"code\",[e._v(\"js\")]),e._v(\" 代码都可以被编译，只是编译的目标平台不同而已。\")]),e._v(\" \"),s(\"p\",[e._v(\"使用 \"),s(\"code\",[e._v(\"webpack\")]),e._v(\" 编译，并且开启\"),s(\"code\",[e._v(\"watch\")]),e._v(\"监听，就能做到实时编译了。\")]),e._v(\" \"),s(\"p\",[s(\"strong\",[e._v(\"node 服务自启\")])]),e._v(\" \"),s(\"p\",[s(\"code\",[e._v(\"node\")]),e._v(\" 服务这里要分两部分来看待。\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"(1)服务的启动\")]),e._v(\" \"),s(\"li\",[e._v(\"(2)服务的自启\")])]),e._v(\" \"),s(\"p\",[e._v(\"单纯的服务启动和自启，很简单，可以使用工具\"),s(\"code\",[e._v(\"nodemon\")]),e._v(\"来完成，不过除了使用工具外是否还有其他的方法处理？\")]),e._v(\" \"),s(\"p\",[s(\"strong\",[e._v(\"我们可以使用自定义进程\")])]),e._v(\" \"),s(\"p\",[e._v(\"让一个服务运行在我们创建的进程中，然后在适当的时机杀掉进程（关闭服务），重新创建一个服务进程启动服务（重启启动）。\")]),e._v(\" \"),s(\"p\",[s(\"strong\",[e._v(\"综合分析\")])]),e._v(\" \"),s(\"p\",[e._v(\"上面我们分析了各个环节的实现思路，单纯的实现每一步应该没什么难度，但是多个操作如何才能统一为一个操作呢？\")]),e._v(\" \"),s(\"p\",[e._v(\"也就是可以通过一个命令来启动前端代码编译和监听、后端代码编译和监听、同时启动 \"),s(\"code\",[e._v(\"node\")]),e._v(\" 服务并且能够自动重启。\")]),e._v(\" \"),s(\"p\",[e._v(\"好了，问题很明确了，实现方案也有了。\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"自定义进程\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#自定义进程\"}},[e._v(\"#\")]),e._v(\" 自定义进程\")]),e._v(\" \"),s(\"p\",[e._v(\"上面的多个操作可以看做是独立的服务，可以让每个服务运行在独立的进程中，然后利用进程间通信来达到我们要的效果。\")]),e._v(\" \"),s(\"p\",[s(\"strong\",[e._v(\"启动阶段\")])]),e._v(\" \"),s(\"p\",[e._v(\"在这个阶段启动各个服务。\")]),e._v(\" \"),s(\"p\",[s(\"strong\",[e._v(\"监听阶段\")])]),e._v(\" \"),s(\"p\",[s(\"code\",[e._v(\"webpack\")]),e._v(\"开启 \"),s(\"code\",[e._v(\"watch\")]),e._v(\"选项后可以自动编译，这个不用我们来干预。\")]),e._v(\" \"),s(\"p\",[s(\"code\",[e._v(\"node\")]),e._v(\"服务的自启，可以在服务端代码构建完成的时候执行。\")]),e._v(\" \"),s(\"h1\",{attrs:{id:\"相关实现\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#相关实现\"}},[e._v(\"#\")]),e._v(\" 相关实现\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"项目目录\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#项目目录\"}},[e._v(\"#\")]),e._v(\" 项目目录\")]),e._v(\" \"),s(\"p\",[e._v(\"先来规定下本骨架的目录结构,可以大概的了解下都包含哪些资源。\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"├── dist // 生产环境打包后的资源存放目录\\n│ ├── static //打包的静态资源文件\\n│ | ├── index.js // 打包后的文件\\n│ ├── server //服务端文件目录\\n│ | ├── app.js //node server 启动入口\\n├── src // 源码目录\\n│ ├── client //前端代码\\n│ │ ├── app // 前端渲染入口\\n│ | ├── pages // 业务页面\\n│ │ | ├── index //默认首页\\n│ │ ├── router // 路由配置\\n│ │ ├── common // 存放通用组件和通用模块\\n│ ├── server // node 代码\\n│ │ ├── app // 服务入口 \\n│ │ ├── middlewares //中间件\\n│ │ | ├──  react-ssr.js //ssr 中间件\\n│ ├── share // 双端共享的代码可以放这里\\n├── webpack //构建配置\\n│ ├── scripts //构建脚本目录\\n│ │ | ├──  start.js //开发环境的所有服务启动入口\\n│ ├── webpack.dev.config.js //前端代码的开发环境编译配置\\n│ ├── webpack.server.config.js 服务端代码的编译配置\\n\\n\\n\")])])]),s(\"h2\",{attrs:{id:\"确定执行命令\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#确定执行命令\"}},[e._v(\"#\")]),e._v(\" 确定执行命令\")]),e._v(\" \"),s(\"p\",[e._v(\"开发环境的启动入口\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"npm run dev // 用来启动开发环境\\n\\n\")])])]),s(\"p\",[e._v(\"对应的\"),s(\"code\",[e._v(\"package.json\")]),e._v(\"配置\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('\"dev\": \"node webpack/scripts/start.js\",\\n\\n')])])]),s(\"p\",[s(\"strong\",[e._v(\"前端代码编译开启 watch\")])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(' \"scripts\": {\\n    //...\\n    \"fe:watch\": \"webpack --config  ./webpack/webpack.dev.config.js --watch\",\\n    //...\\n  },\\n\\n')])])]),s(\"p\",[s(\"strong\",[e._v(\"服务端代码打包配置\")])]),e._v(\" \"),s(\"p\",[e._v(\"和前端的打包配置差不多,需要配置\"),s(\"code\",[e._v(\"target=node\")]),e._v(\", 增加\"),s(\"code\",[e._v(\"externals\")]),e._v(\" 选项，使用\"),s(\"code\",[e._v(\"webpack-node-externals\")]),e._v(\"来排除不需要打包的模块，因为 \"),s(\"code\",[e._v(\"node\")]),e._v(\" 端会自动载入这些包，可以让打包的文件更小。\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"// ./webpack/webpack.server.config\\n\\n//webpack 配置文件\\nconst path = require('path')\\nconst nodeExternals = require('webpack-node-externals')\\nconst webpack = require('webpack');\\nconst resolvePath = (pathstr) => path.resolve(__dirname, pathstr);\\n\\nprocess.env.BABEL_ENV = 'node';//设置 babel 的运行的环境变量\\n\\nconst isProd=process.env.NODE_ENV==='production';\\n\\nmodule.exports = {\\n    target: 'node',\\n    entry: resolvePath('../src/server/app/index.js'),//入口文件\\n    output: {\\n        filename: 'app.js',\\n        path: resolvePath('../dist/server')\\n    },\\n    externals: [nodeExternals()],\\n    module: {\\n        rules: [{\\n            test: /\\\\.jsx?$/,\\n            loader: 'babel-loader',\\n            exclude: /node_modules/\\n        }\\n        ]\\n    }\\n}\\n\\n\\n\")])])]),s(\"p\",[s(\"strong\",[e._v(\"通过 api 方式启动服务端代码监听\")])]),e._v(\" \"),s(\"p\",[e._v(\"因为我们需要监听服务端代码的构建过程，当每次编译完成时，通知主进程重启 \"),s(\"code\",[e._v(\"node\")]),e._v(\" 服务，\"),s(\"code\",[e._v(\"cli\")]),e._v(\" 模式下无法满足需要，所以需要调用\"),s(\"code\",[e._v(\"api\")]),e._v(\" 来执行构建监听。\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"\\n// ./webpack/scripts/svr-code-watch.js\\n\\n//基于 webpack  开启对服务端代码的编译和监听 \\n//配置文件为 webpack.server.config.js\\n\\nconst webpack  = require('webpack');\\nconst config =  require('../webpack.server.config');\\nconst constantCode = require('./constant');\\nconfig.mode='development';//设置编译模式\\n\\n\\n//编译对象\\nconst compiler = webpack(config);\\n\\nconst watching = compiler.watch({\\n    aggregateTimeout: 300, // 类似节流功能,聚合多个更改一起构建\\n    ignored: /node_modules/, //排除文件\\n    poll: 2000, //轮训的方式检查变更 单位：秒  ,如果监听没生效，可以试试这个选项.\\n}, (err, stats) => {\\n   \\n    let json = stats.toJson(\\\"minimal\\\");\\n    if(json.errors){\\n        json.errors.forEach(item => {\\n            console.log(item);\\n        });\\n    }\\n    if (json.warnings) {\\n        json.warnings.forEach(item => {\\n            console.log(item);\\n        });\\n    }\\n\\n    //定一个常量，编译完成后 通知主进程来重启node 服务，主进程通过此标志来进行判断是否重启\\n    console.log(constantCode.SVRCODECOMPLETED);\\n});\\n\\ncompiler.hooks.done.tap('done',function (data) {\\n    console.log('\\\\n svr code done' ); //编译完成动作\\n});\\n\\n//收到退出信号 退出自身进程\\nprocess.stdin.on('data', function (data) {\\n    if (data.toString() === 'exit') {\\n        process.exit();\\n    }\\n});\\n\\n\")])])]),s(\"p\",[s(\"strong\",[e._v(\"ps: 文件 './constant'说明\")])]),e._v(\" \"),s(\"p\",[e._v(\"该文件用来存放开发环境构建过程中的常量\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"// ./webpack/scripts/constant.js \\n\\n//用于开发环境的构建过程中的常量\\nmodule.exports = {\\n    SVRCODECOMPLETED:'SVRCODECOMPLETED',//表示服务端代码编译完成的标志\\n}\\n\\n\")])])]),s(\"p\",[s(\"strong\",[e._v(\"配置服务端代码构建执行命令\")])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('  \"scripts\": {\\n   //...\\n    \"svr:watch\": \"node ./webpack/scripts/svr-code-watch.js\"\\n  },\\n\\n')])])]),s(\"p\",[s(\"strong\",[e._v(\"创建node 服务启动入口\")])]),e._v(\" \"),s(\"p\",[e._v(\"为了方便控制，我们单独创建一个开发环境的\"),s(\"code\",[e._v(\"node\")]),e._v(\" 服务启动入口,引入打包后的入口文件即可。\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"// ./webpack/svr-dev-server.js\\n\\n//开发环境 node 服务启动入口\\n\\n//公用配置文件，定义一些通用的数据\\nconst proConfig = require('../../src/share/pro-config');\\n\\n//node server port\\nconst nodeServerPort = proConfig.nodeServerPort;\\n\\n\\n//启动前检查端口是否占用，杀掉占用端口的进程\\nrequire('./free-port')(nodeServerPort);\\n\\n//引入打包后的入口文件,这个入口我们在 webpack 配置中已设置好\\nrequire('../../dist/server/app');\\n\\n\\n\")])])]),s(\"p\",[s(\"strong\",[e._v(\"最终编译入口处理\")])]),e._v(\" \"),s(\"p\",[e._v(\"通过创建子进程的方式，整合多个服务到统一入口。\")]),e._v(\" \"),s(\"p\",[e._v(\"使用\"),s(\"code\",[e._v(\"const {spawn} = require('child_process');//用于创建子进程\")]),e._v(\" 来创建子进程，此方式为异步执行。\")]),e._v(\" \"),s(\"p\",[e._v(\"然后通过子进程的\"),s(\"code\",[e._v(\"std\")]),e._v(\"进行通信，达到重启 \"),s(\"code\",[e._v(\"node\")]),e._v(\"服务的作用。\")]),e._v(\" \"),s(\"p\",[s(\"code\",[e._v(\"启动入口 ./webpack/scripts/start.js\")])]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"\\nconst {spawn} = require('child_process');//用于创建子进程\\nconst constantCode = require('./constant');\\nconst chalk = require('chalk');//为控制台输出的信息增加点色彩\\nconst log = console.log;\\nconst proConfig  = require('../../src/share/pro-config');//双端的配置文件，配置一些基础参数，具体说明在后面\\n\\n//node server port\\nconst nodeServerPort = proConfig.nodeServerPort;\\n\\nlog(chalk.red('servers starting....'));\\n\\n//前端代码构建 服务进程\\nconst feCodeWatchProcess = spawn('npm', ['run', 'fe:watch'],{stdio:'inherit'});\\n\\n//服务端代码监控和编译进程\\nconst svrCodeWatchProcess = spawn('npm', ['run', 'svr:watch']);\\n\\n//node 服务进程\\nlet nodeServerProcess=null;\\n//启动 node 服务\\nconst startNodeServer = () => { //重启 node 服务 \\n    nodeServerProcess && nodeServerProcess.kill();\\n    nodeServerProcess = spawn('node',['./webpack/scripts/svr-dev-server.js']);\\n    nodeServerProcess.stdout.on('data', print);\\n}\\n\\n//控制台输出信息\\nfunction print(data) {\\n    let str = data.toString();\\n    if (str.indexOf(constantCode.SVRCODECOMPLETED) > -1) { //接收到服务端代码编译完成的通知\\n        startNodeServer();//重启 node 服务\\n    } else {\\n        console.log(str);\\n    }\\n}\\n\\n//监听服务端代码构建服务的对外输出  stdout 事件\\nsvrCodeWatchProcess.stdout.on('data',print);\\n\\n//杀掉子进程\\nconst killChild=()=>{\\n    svrCodeWatchProcess && svrCodeWatchProcess.kill();\\n    nodeServerProcess && nodeServerProcess.kill();\\n    feCodeWatchProcess && feCodeWatchProcess.kill();\\n}\\n\\n//主进程关闭退出子进程\\nprocess.on('close', (code) => {\\n    console.log('main process  close', code);\\n    killChild();\\n});\\n//主进程关闭退出子进程\\nprocess.on('exit', (code) => {\\n    console.log('main process  exit', code);\\n    killChild();\\n});\\n\\n//非正常退出情况\\nprocess.on('SIGINT', function () {\\n    svrCodeWatchProcess.stdin.write('exit', (error) => {\\n        console.log('svr code watcher process exit!');\\n    });\\n    killChild();\\n});\\n\\n\\n\")])])]),s(\"p\",[s(\"strong\",[e._v(\"ps:文件（'../../src/share/pro-config'）说明\")])]),e._v(\" \"),s(\"p\",[e._v(\"该文件是服务端和客户端的公用基础配置文件，所以放在了share目录下\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"// ./src/share/pro-config.js\\n\\n//双端公用的配置文件\\nmodule.exports = {\\n    wdsPort:9002,//webpack dev server 服务的运行端口\\n    nodeServerPort:9001,//node server 的监听端口\\n}\\n\\n\\n\")])])]),s(\"p\",[s(\"code\",[e._v(\"看下最终运行效果\")])]),e._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/12/30/16f56960104bf971?w=750&h=305&f=png&s=66992\",alt:\"\"}})]),e._v(\" \"),s(\"p\",[e._v(\"服务端代码的构建日志信息已隐藏，只在有错误的时候才会输出，现在在编译完成时会通知主进程重启 \"),s(\"code\",[e._v(\"node\")]),e._v(\" 服务。\")]),e._v(\" \"),s(\"p\",[e._v(\"到这里，我们就基本上完成了一个重要的开发体验升级，为我们后续的进展提供了便利。\")]),e._v(\" \"),s(\"h1\",{attrs:{id:\"另外一种方式\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#另外一种方式\"}},[e._v(\"#\")]),e._v(\" 另外一种方式\")]),e._v(\" \"),s(\"p\",[e._v(\"下面给大家简单介绍另外一种方式\")]),e._v(\" \"),s(\"p\",[e._v(\"可以使用\"),s(\"code\",[e._v(\"npm-run-all\")]),e._v(\"工具,该工具可以同时并行多个\"),s(\"code\",[e._v(\"npm\")]),e._v(\" 命令,只需要配置下就可以了。\")]),e._v(\" \"),s(\"p\",[e._v(\"举个栗子\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"npm-run-all --parallel fe:watch svr:watch node:server\\n\\n\")])])]),s(\"p\",[e._v(\"其实本质也是通过进程来完成的。\")]),e._v(\" \"),s(\"p\",[e._v(\"不过对于我个人来说，还是喜欢能自己实现的尽量自己来实现，这样可以学以致用，学习的东西不实践的话永远只是纸上谈兵。\")]),e._v(\" \"),s(\"p\",[e._v(\"当然工具的使用也必不可少，看具体的情况，因为它确实能够帮我们大大提高效率。\")]),e._v(\" \"),s(\"h1\",{attrs:{id:\"小结\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[e._v(\"#\")]),e._v(\" 小结\")]),e._v(\" \"),s(\"p\",[e._v(\"这一节我们逐步分析并实现了一个基本的工程化的搭建和配置，让我们的项目在开发和调试的时候更加便利。\")]),e._v(\" \"),s(\"p\",[e._v(\"对于实现方式，本文算是其中一种，也可能还有其他方法，但是思想才是最重要的。只要有了思路，相信后面的实现也只是个时间问题。\")]),e._v(\" \"),s(\"p\",[e._v(\"我们应用骨架，走到这里就方便多了，但是还不够，不够彻底。\")]),e._v(\" \"),s(\"p\",[e._v(\"现在更改了代码，还需要刷新页面来查看效果，所以后面还需要加入热更新机制，这个优化我们后面再慢慢聊。\")]),e._v(\" \"),s(\"p\",[e._v(\"本节完整代码:\")]),e._v(\" \"),s(\"p\",[s(\"a\",{attrs:{href:\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr1\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr1\"),s(\"OutboundLink\")],1)]),e._v(\" \"),s(\"p\",[e._v(\"感谢你的阅读。\")]),e._v(\" \"),s(\"p\",[e._v(\"如果有问题欢迎留言，也欢迎在留言区留下你的想法和思考。\")])])}),[],!1,null,null,null);n.default=t.exports}}]);","extractedComments":[]}