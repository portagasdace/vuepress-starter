{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[250],{604:function(e,n,t){\"use strict\";t.r(n);var a=t(42),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"实战篇-4-小程序列表获取-使用-sequelize\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实战篇-4-小程序列表获取-使用-sequelize\"}},[e._v(\"#\")]),e._v(\" 实战篇 4：小程序列表获取 —— 使用 Sequelize\")]),e._v(\" \"),t(\"p\",[e._v(\"上一节，我们的店铺 shops 表与商品 goods 表都已经通过 migrate 与 seed，完成了表结构的创建与数据的填充。本小节我们把知识点聚焦在 Sequelize 插件库本身的数据模型 model 的查询能力，来实现小程序店铺的列表查询与商品列表查询。\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"sequelize-连接-mysql-数据库\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sequelize-连接-mysql-数据库\"}},[e._v(\"#\")]),e._v(\" Sequelize 连接 MySQL 数据库\")]),e._v(\" \"),t(\"p\",[e._v(\"Sequelize 连接数据库的核心代码主要就是通过 new Sequelize（database, username, password, options） 来实现，其中 options 中的配置选项，除了最基础的 host 与 port、数据库类型外，还可以设置连接池的连接参数 pool，数据模型命名规范 underscored 等等。具体可以查阅官方手册 \"),t(\"a\",{attrs:{href:\"http://docs.sequelizejs.com/manual/installation/usage.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"基础使用\"),t(\"OutboundLink\")],1),e._v(\"。\")]),e._v(\" \"),t(\"p\",[e._v(\"由于前一小节通过 sequelize-cli init 初始化了 models 的目录，sequelize-cli 已经特别友好地为我们准备了一个动态加载 models 目录中具体数据库表模型的入口模块 index.js。由于我们希望遵循 MySQL 数据库表字段的下划线命名规范，所以，需要全局开启一个 \"),t(\"code\",[e._v(\"underscore: true\")]),e._v(\" 的定义，来使系统中默认的 createdAt 与 updatedAt 能以下划线的方式，与表结构保持一致。\")]),e._v(\" \"),t(\"p\",[e._v(\"微调 models/index.js 中的代码：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// models/index.js\\n\\n// 将 const config = configs[env] 调整为如下结构\\n\\nconst config = {\\n  ...configs[env],\\n  define: {\\n    underscored: true,\\n  },\\n};\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"定义数据库业务相关的-model\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定义数据库业务相关的-model\"}},[e._v(\"#\")]),e._v(\" 定义数据库业务相关的 model\")]),e._v(\" \"),t(\"p\",[e._v(\"结合业务所需，我们在 models 目录下继续创建一系列的 model 来与数据库表结构做对应：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"├── models                       # 数据库 model\\n│   ├── index.js                 # model 入口与连接\\n│   ├── goods.js                 # 商品表\\n│   ├── shops.js                 # 店铺表\\n\\n\")])])]),t(\"h3\",{attrs:{id:\"_1-定义店铺的数据模型-shops\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-定义店铺的数据模型-shops\"}},[e._v(\"#\")]),e._v(\" 1. 定义店铺的数据模型 shops\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// models/shops.js\\n\\nmodule.exports = (sequelize, DataTypes) => sequelize.define(\\n  'shops',\\n  {\\n    id: {\\n      type: DataTypes.INTEGER,\\n      primaryKey: true,\\n      autoIncrement: true,\\n    },\\n    name: {\\n      type: DataTypes.STRING,\\n      allowNull: false,\\n    },\\n    thumb_url: DataTypes.STRING,\\n  },\\n  {\\n    tableName: 'shops',\\n  },\\n);\\n\\n\\n\")])])]),t(\"h3\",{attrs:{id:\"_2-定义商品的数据模型-goods\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-定义商品的数据模型-goods\"}},[e._v(\"#\")]),e._v(\" 2.定义商品的数据模型 goods\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"module.exports = (sequelize, DataTypes) => sequelize.define(\\n  'goods',\\n  {\\n    id: {\\n      type: DataTypes.INTEGER,\\n      primaryKey: true,\\n      autoIncrement: true,\\n    },\\n    shop_id: {\\n      type: DataTypes.INTEGER,\\n      allowNull: false,\\n    },\\n    name: {\\n      type: DataTypes.STRING,\\n      allowNull: false,\\n    },\\n    thumb_url: DataTypes.STRING,\\n  },\\n  {\\n    tableName: 'goods',\\n  },\\n);\\n\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"实现店铺列表页接口\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现店铺列表页接口\"}},[e._v(\"#\")]),e._v(\" 实现店铺列表页接口\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"_1-实现简单的店铺列表接口\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-实现简单的店铺列表接口\"}},[e._v(\"#\")]),e._v(\" 1. 实现简单的店铺列表接口\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// routes/shops.js\\n\\n// 引入 models\\nconst models = require(\\\"../models\\\");\\nmodule.exports = [\\n  {\\n    method: 'GET',\\n    path: '/shops',\\n    handler: async (request, reply) => {\\n      // 通过 await 来异步查取数据\\n      const result = await models.shops.findAll();\\n      reply(result)\\n    }\\n  }\\n]\\n\\n\")])])]),t(\"h3\",{attrs:{id:\"_2-隐藏返回列表中不需要的字段\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-隐藏返回列表中不需要的字段\"}},[e._v(\"#\")]),e._v(\" 2. 隐藏返回列表中不需要的字段\")]),e._v(\" \"),t(\"p\",[e._v(\"很多时候，我们并不希望 findAll 来将数据表中的所有数据全都暴露出来，比如在查询用户列表时，用户的密码的值，便是特别敏感的数据。 我们可以在 findAll 中加入一个 \"),t(\"code\",[e._v(\"attributes\")]),e._v(\" 的约束，可以是一个要查询的属性（字段）列表，或者是一个 key 为 \"),t(\"code\",[e._v(\"include\")]),e._v(\" 或 \"),t(\"code\",[e._v(\"exclude\")]),e._v(\" 对象的键，比如对于用户表，\"),t(\"code\",[e._v(\"findAll({ attributes: { exclude: ['password'] } })\")]),e._v(\"，就可以排除密码字段的查询露出。\")]),e._v(\" \"),t(\"p\",[e._v(\"在我们的店铺表中，我们希望有如下的字段露出：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\nconst result = await models.shops.findAll({\\n  attributes: [\\n    'id', 'name'\\n  ]\\n});\\n\\n\")])])]),t(\"h3\",{attrs:{id:\"_3-列表分页\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-列表分页\"}},[e._v(\"#\")]),e._v(\" 3. 列表分页\")]),e._v(\" \"),t(\"p\",[e._v(\"当列表的数据开始增多，每次的列表展示数据，并不需要拉取全部，这时，我们需要为系统框架引入分页插件，hapi-pagination。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\n# 安装适配 hapi v16 的 hapi-pagination\\n$ npm i hapi-pagination@1\\n\\n\")])])]),t(\"p\",[e._v(\"在 plugins 目录下新增一个 hapi-pagination 的插件。options 的具体配置参数细节说明，参见 \"),t(\"a\",{attrs:{href:\"https://github.com/fknop/hapi-pagination/tree/v1.6.5\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"hapi-pagination\"),t(\"OutboundLink\")],1),e._v(\"。\")]),e._v(\" \"),t(\"p\",[e._v(\"考虑到，并非所有的接口都需要支持分页，所以，笔者建议对需要分页的相关接口，在 routes.include 配置中，逐条添加：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// plugins/hapi-pagination.js\\nconst hapiPagination = require('hapi-pagination');\\n\\nconst options = {\\n  query: {\\n    // ... 此处篇幅考虑省略 query 入参配置代码，参看章节  github 案例\\n  },\\n  meta: {\\n    name: 'meta',\\n    // ... 此处篇幅考虑省略 meta 的相关配置代码，参看章节  github 案例\\n  },\\n  results: {\\n    name: 'results'\\n  },\\n  reply: {\\n    paginate: 'paginate'\\n  },\\n  routes: {\\n    include: [\\n      '/shops'  // 店铺列表支持分页特性\\n    ],\\n    exclude: []\\n  }\\n}\\n\\nmodule.exports = {\\n  register: hapiPagination,\\n  options: options,\\n}\\n\\n\")])])]),t(\"p\",[e._v(\"在 app.js 中注册使用 hapi-pagination:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// app.js\\nconst pluginHapiPagination = require('./plugins/hapi-pagination');\\nawait server.register([\\n  pluginHapiPagination,\\n])\\n\\n\\n\")])])]),t(\"p\",[e._v(\"为 GET /shops 的接口添加分页的入参校验，同时更新 Swagger 文档的入参契约。考虑到系统中未来会有不少接口需要做分页处理，我们在 utils/router-helper.js 中，增加一个公共的分页入参校验配置：\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// utils/router-helper.js\\nconst paginationDefine = {\\n  limit: Joi.number().integer().min(1).default(10)\\n    .description('每页的条目数'),\\n  page: Joi.number().integer().min(1).default(1)\\n    .description('页码数'),\\n  pagination: Joi.boolean().description('是否开启分页，默认为true'),\\n}\\n\\nmodule.exports = { paginationDefine }\\n\\n\")])])]),t(\"p\",[e._v(\"最终，回到 router/shops.js，实现最后的分页配置逻辑。考虑到分页的查询功能除了拉取列表外，还要获取总条目数，Sequelize 为我们提供了 \"),t(\"code\",[e._v(\"findAndCountAll\")]),e._v(\" 的 API，来为分页查询提供更高效的封装实现，返回的列表与总条数会分别存放在 \"),t(\"code\",[e._v(\"rows\")]),e._v(\" 与 \"),t(\"code\",[e._v(\"count\")]),e._v(\" 字段的对象中。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"const { paginationDefine } = require('../utils/router-helper');\\n// ...省略上下文\\n{\\n  method: 'GET',\\n  path: `/${GROUP_NAME}`,\\n  handler: async (request, reply) => {\\n    const { rows: results, count: totalCount } = await models.shops.findAndCountAll({\\n      attributes: [\\n        'id',\\n        'name',\\n      ],\\n      limit: request.query.limit,\\n      offset: (request.query.page - 1) * request.query.limit,\\n    });\\n    // 开启分页的插件，返回的数据结构里，需要带上 result 与 totalCount 两个字段\\n    reply({ results, totalCount });\\n  },\\n  config: {\\n    tags: ['api', GROUP_NAME],\\n    auth: false,\\n    description: '获取店铺列表',\\n    validate: {\\n      query: {\\n        ...paginationDefine\\n      }\\n    }\\n  }\\n}\\n// ...省略上下文\\n\\n\\n\")])])]),t(\"p\",[e._v(\"通过 Swagger 文档工具 \"),t(\"a\",{attrs:{href:\"http://localhost:3000/documentation\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"http://localhost:3000/documentation\"),t(\"OutboundLink\")],1),e._v(\" 查看店铺列表的接口调用返回数据，结果应该和下图相仿：\")]),e._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/8/19/165528f7aa0b42c3?w=1482&h=1774&f=jpeg&s=317342\",alt:\"\"}})]),e._v(\" \"),t(\"h2\",{attrs:{id:\"实现获取单个店铺的商品列表接口\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现获取单个店铺的商品列表接口\"}},[e._v(\"#\")]),e._v(\" 实现获取单个店铺的商品列表接口\")]),e._v(\" \"),t(\"p\",[e._v(\"根据传入的店铺 ID，查询特定店铺 ID 下的商品列表，此处使用到了 sequelize 的 where 条件查询。同时，我们为店铺商品列表也加入分页的特性。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"\\n// router/shops.js\\n\\nconst models = require(\\\"../models\\\");\\nmodule.exports = [\\n  // ...省略上下文\\n  {\\n    method: 'GET',\\n    path: `/${GROUP_NAME}/{shopId}/goods`,\\n    handler: async (request, reply) => {\\n      // 增加带有 where 的条件查询\\n      const { rows: results, count: totalCount } = await models.goods.findAndCountAll({\\n        // 基于 shop_id 的条件查询\\n        where: {\\n          shop_id: request.params.shopId,\\n        },\\n        attributes: [\\n          'id',\\n          'name',\\n        ],\\n        limit: request.query.limit,\\n        offset: (request.query.page - 1) * request.query.limit,\\n      });\\n    },\\n  }\\n  // ...省略上下文\\n]\\n\\n\")])])]),t(\"p\",[e._v(\"记得在 plugins/hapi-pagination.js 的 include 中加入 /shops/{shopId}/goods 的分页路由白名单。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"// plugins/hapi-pagination.js\\nconst options = {\\n  // ...\\n  routes: {\\n    include: [\\n      '/shops/goods',\\n      '/shops/{shopId}/goods',\\n    ],\\n    exclude: []\\n  }\\n  // ...\\n}\\n\\n\\n\")])])]),t(\"p\",[e._v(\"更多关于 models 的操作请查看官方手册 \"),t(\"a\",{attrs:{href:\"http://docs.sequelizejs.com/manual/tutorial/models-usage.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Model 使用\"),t(\"OutboundLink\")],1)]),e._v(\" \"),t(\"p\",[e._v(\"GitHub 参考代码 \"),t(\"a\",{attrs:{href:\"https://github.com/yeshengfei/hapi-tutorial/tree/master/chapter8/hapi-tutorial-1\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"chapter8/hapi-tutorial-1\"),t(\"OutboundLink\")],1)]),e._v(\" \"),t(\"h2\",{attrs:{id:\"小结\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[e._v(\"#\")]),e._v(\" 小结\")]),e._v(\" \"),t(\"p\",[e._v(\"关键词：Sequelize，Model定义，列表查询，分页\")]),e._v(\" \"),t(\"p\",[e._v(\"本小节，我们学习了如何使用 Sequelize 提供的数据库查询的方法，来获取列表数据。我们在大多数的使用场景下，都可以利用 Sequelize 简洁的函数式方法调用，避开直接拼写晦涩冗长的数据库查询语句，最终获取我们想要的业务数据查询结果。掌握 Sequelize 插件库，是 Node.js 下使用 MySQL 数据库的必修课。相关的使用手册文档，希望能经常温故而知新，掌握更多高级的使用技巧。\")]),e._v(\" \"),t(\"p\",[e._v(\"思考：我们发现实际的业务中，店铺的数量会很多，我们希望通过一些关键词的输入，来模糊查询匹配的店铺列表，路由该如何设计？Sequelize 该如何查询？\")]),e._v(\" \"),t(\"p\",[t(\"strong\",[e._v(\"本小节参考代码汇总\")])]),e._v(\" \"),t(\"p\",[e._v(\"Sequelize 连接 MySQL 数据库 - Sequelize 具体细节： \"),t(\"a\",{attrs:{href:\"http://docs.sequelizejs.com/manual/installation/usage.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"基础使用\"),t(\"OutboundLink\")],1)]),e._v(\" \"),t(\"p\",[e._v(\"实现店铺列表页接口 - 列表分页 - hapi-pagination 的 options 配置细节: \"),t(\"a\",{attrs:{href:\"https://github.com/fknop/hapi-pagination/tree/v1.6.5\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"hapi-pagination\"),t(\"OutboundLink\")],1)]),e._v(\" \"),t(\"p\",[e._v(\"实现获取单个店铺的商品列表接口：\"),t(\"a\",{attrs:{href:\"https://github.com/yeshengfei/hapi-tutorial/tree/master/chapter8/hapi-tutorial-1\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"chapter8/hapi-tutorial-1\"),t(\"OutboundLink\")],1)]),e._v(\" \"),t(\"p\",[e._v(\"models 更多操作：\"),t(\"a\",{attrs:{href:\"http://docs.sequelizejs.com/manual/tutorial/models-usage.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Model 使用\"),t(\"OutboundLink\")],1)])])}),[],!1,null,null,null);n.default=s.exports}}]);","extractedComments":[]}