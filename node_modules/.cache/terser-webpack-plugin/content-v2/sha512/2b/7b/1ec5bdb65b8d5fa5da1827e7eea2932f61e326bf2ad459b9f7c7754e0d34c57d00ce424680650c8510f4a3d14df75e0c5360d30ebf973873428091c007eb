{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[355],{711:function(t,e,a){\"use strict\";a.r(e);var n=a(42),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h2\",{attrs:{id:\"导读\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#导读\"}},[t._v(\"#\")]),t._v(\" 导读\")]),t._v(\" \"),a(\"p\",[t._v(\"本节标题：「建造毛坯」- 双端数据同构\")]),t._v(\" \"),a(\"p\",[t._v(\"本节主旨： 不可缺少的副作用处理，实现双端异步数据的获取，数据脱水，数据注水，重点在于如何利用同构来实现\")]),t._v(\" \"),a(\"p\",[t._v(\"本节配套代码：\")]),t._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-dataiso\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-dataiso\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"h1\",{attrs:{id:\"正文\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#正文\"}},[t._v(\"#\")]),t._v(\" 正文\")]),t._v(\" \"),a(\"p\",[t._v(\"上一节我们实现了应用骨架的路由同构，这一节我们来实现非常重要的一个环节 - \"),a(\"strong\",[t._v(\"数据同构\")]),t._v(\"。\")]),t._v(\" \"),a(\"h1\",{attrs:{id:\"什么是数据同构\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是数据同构\"}},[t._v(\"#\")]),t._v(\" 什么是数据同构\")]),t._v(\" \"),a(\"p\",[t._v(\"整体来说，组件的一些数据需要从接口异步获取后进行渲染，数据同构就是服务端和客户端能够使用同一个数据请求处理方法（一套代码），同一份数据进行组件的渲染。\")]),t._v(\" \"),a(\"p\",[t._v(\"我们前面实现的组件直出只是将组件转换为了 \"),a(\"code\",[t._v(\"html\")]),t._v(\"字符串，但是并没有具体的数据，顶多就是个静态页。\")]),t._v(\" \"),a(\"p\",[t._v(\"比如现在有这么一个需求，要从接口获取数据并且渲染到页面上。\")]),t._v(\" \"),a(\"p\",[t._v(\"以往在单页应用中，我们一般都将数据的数据的请求处理放在\"),a(\"code\",[t._v(\"compoentDidMount\")]),t._v(\"生命周期内，得到数据后更改状态，随之渲染。\")]),t._v(\" \"),a(\"p\",[t._v(\"异步获取数据\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\" \\n  componentDidMount(){\\n        ...\\n        fetchData().then(res=>{\\n            this.setState({\\n                list:res.list\\n            });\\n        })\\n    }\\n\\n\\n\")])])]),a(\"p\",[t._v(\"在 \"),a(\"code\",[t._v(\"render\")]),t._v(\" 方法内组织数据\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\" render() {\\n        ....\\n        let {list} = this.state;\\n        .....\\n        return <>\\n        {list&&list.map(item=>{\\n            return <div>{item.title}</div>\\n        })}\\n        </>\\n    }\\n\\n\")])])]),a(\"p\",[t._v(\"上面的代码我们都非常熟悉，以上代码也能在 \"),a(\"code\",[t._v(\"ssr\")]),t._v(\" 模式中执行，但是无法得到我们期望的效果，数据只能在客户端得到，达不到数据直出的效果，查看网页源代码也没有我们想要的数据。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/12/31/16f59f29ddc061e1?w=830&h=383&f=png&s=92478\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"在小册开始的时候我们介绍过一些原理，\"),a(\"code\",[t._v(\"componentDidMount\")]),t._v(\"生命周期只会在浏览器端执行，所以如果想让数据也能在服务端渲染就需要做一些特殊的处理。\")]),t._v(\" \"),a(\"p\",[t._v(\"接下来我们来实现 \"),a(\"code\",[t._v(\"react ssr\")]),t._v(\" 本应用骨架内的数据同构。\")]),t._v(\" \"),a(\"h1\",{attrs:{id:\"数据预取\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据预取\"}},[t._v(\"#\")]),t._v(\" 数据预取\")]),t._v(\" \"),a(\"p\",[t._v(\"在客户端，我们在\"),a(\"code\",[t._v(\"componentDidMount\")]),t._v(\"生命周期内执行数据请求方法从接口拿到数据。\")]),t._v(\" \"),a(\"p\",[t._v(\"在服务端渲染组件的时候要想在直出的组件内容也包含数据，那就需要提前得到数据，然后将数据作为属性传递给组件，在\"),a(\"code\",[t._v(\"constructor\")]),t._v(\"内对组件 \"),a(\"code\",[t._v(\"state\")]),t._v(\" 进行初始化。\")]),t._v(\" \"),a(\"p\",[t._v(\"当组件有了数据，服务端渲染直出的时候自然就会有数据。\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"以上这个在服务端渲染前得到数据的过程就是数据预取。\")])]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"思考两个问题：\")])]),t._v(\" \"),a(\"p\",[t._v(\"问题1：客户端和服务端组件渲染执行的声明周期不同，双端如何使用一套代码，代码如何组织呢？\")]),t._v(\" \"),a(\"p\",[t._v(\"问题2：真实开发中，浏览器的 \"),a(\"code\",[t._v(\"fetch api\")]),t._v(\" 无法在\"),a(\"code\",[t._v(\"node\")]),t._v(\" 端使用,如何统一呢？\")]),t._v(\" \"),a(\"p\",[t._v(\"以上两个问题都可以通过同构来解决。\")]),t._v(\" \"),a(\"p\",[t._v(\"先说问题2，因为比较简单，现在已经有很多同构的库来解决。\")]),t._v(\" \"),a(\"p\",[t._v(\"比如:\"),a(\"code\",[t._v(\"isomorphic-fetch\")]),t._v(\"，\"),a(\"code\",[t._v(\"axios\")]),t._v(\"，这里我推荐使用\"),a(\"code\",[t._v(\"axios\")]),t._v(\",对开发者非常友好，可以无差别使用。\")]),t._v(\" \"),a(\"p\",[t._v(\"那现在回到问题1，解决这个问题前需要回顾下以往的知识。\")]),t._v(\" \"),a(\"p\",[a(\"code\",[t._v(\"js\")]),t._v(\"里无论是函数还是类，到底都是函数，同时都是特殊的对象。\")]),t._v(\" \"),a(\"p\",[t._v(\"所以我们可以为这些函数添加属性，这个属性也可以被称作为类的静态方法。\")]),t._v(\" \"),a(\"p\",[t._v(\"静态方法有什么特点？\")]),t._v(\" \"),a(\"p\",[t._v(\"不需要实例化就可以访问,像下面这样。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"class Foo {\\n   run(){\\n       .....\\n       console.log('hello');\\n   }\\n}\\n\\nFoo.method=function(){\\n    console.log('hello method');\\n}\\n\\n\")])])]),a(\"p\",[t._v(\"这有什么作用呢？\")]),t._v(\" \"),a(\"p\",[t._v(\"上面的代码可以在浏览器端执行，当然也可在 \"),a(\"code\",[t._v(\"node\")]),t._v(\" 端执行。\")]),t._v(\" \"),a(\"p\",[t._v(\"其实以上思路就是解决问题2的办法，可以把\"),a(\"code\",[t._v(\"Foo\")]),t._v(\"想象成我们的\"),a(\"code\",[t._v(\"react\")]),t._v(\" 组件。\")]),t._v(\" \"),a(\"p\",[t._v(\"我们可以在 \"),a(\"code\",[t._v(\"node\")]),t._v(\" 端找到这个路由对应的组件，然后调用这个组件的静态方法来实现数据的预取。\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"梳理下完整的思路\")])]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"约定并为组件添加数据预取的静态方法\")]),t._v(\" \"),a(\"li\",[t._v(\"在服务端查找到当前路由对应的组件\")]),t._v(\" \"),a(\"li\",[t._v(\"调用组件的数据预取方法得到数据\")]),t._v(\" \"),a(\"li\",[t._v(\"将数据作为属性传入组件\")]),t._v(\" \"),a(\"li\",[t._v(\"组件内render做相应的处理\")]),t._v(\" \"),a(\"li\",[t._v(\"服务端直出组件\")]),t._v(\" \"),a(\"li\",[t._v(\"浏览器接管页面，完成渲染\")])]),t._v(\" \"),a(\"h1\",{attrs:{id:\"手膜手实现数据同构\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#手膜手实现数据同构\"}},[t._v(\"#\")]),t._v(\" 手膜手实现数据同构\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"约定数据预取方法\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#约定数据预取方法\"}},[t._v(\"#\")]),t._v(\" 约定数据预取方法\")]),t._v(\" \"),a(\"p\",[t._v(\"首先我们模拟一个异步获取数据的方法，返回一个列表数据。\")]),t._v(\" \"),a(\"p\",[t._v(\"我这里准备了一份从掘金采集的信息，作为假数据。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('// ./src/client/pages/list/data.js\\n\\nconst data = [{\\n    \"title\": \"深入浅出TypeScript：从基础知识到类型编程\",\\n    \"desc\": \"Vue3 源码及开发必备基础，从基础知识到类型工具设计，从理论到实战，手把手让你从零基础成为进阶使用者。\",\\n    \"img\": \"https://user-gold-cdn.xitu.io/2019/11/8/16e4ab5d6aff406a?imageView2/1/w/200/h/280/q/95/format/webp/interlace/1\"\\n}, {\\n    \"title\": \"SVG 动画开发实战手册\",\\n    \"desc\": \"从0到1，学习SVG动画开发知识，快速高效完成SVG动画效果开发。\",\\n    \"img\": \"https://user-gold-cdn.xitu.io/2019/9/26/16d6bda264ac27e4?imageView2/1/w/200/h/280/q/95/format/webp/interlace/1\"\\n}, {\\n    \"title\": \"预售JavaScript 设计模式核⼼原理与应⽤实践\",\\n    \"desc\": \"通俗易懂的编程“套路“学。带你深入看似高深实则接地气的设计模式原理，在实际场景中内化设计模式的”道“与”术“。学会驾驭代码，而非被其奴役。\",\\n    \"img\": \"https://user-gold-cdn.xitu.io/2019/9/16/16d382e623923d91?imageView2/1/w/200/h/280/q/95/format/webp/interlace/1\"\\n}\\n]\\n\\n')])])]),a(\"p\",[t._v(\"另外我们约定所有页面组件内的数据预取方法为\"),a(\"code\",[t._v(\"getInitialProps\")]),t._v(\",用于双端调用。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"//src/client/pages/list/index.js\\n//List 页面 组件\\n\\nimport React from 'react';\\nimport {Link} from 'react-router-dom';\\n//导入  - 假数据\\nimport tempData from './data';\\n//组件\\nexport default class Index extends React.Component {\\n    constructor(props) {\\n        super(props);\\n    }\\n    //静态方法  数据预取方法\\n    static async  getInitialProps() {\\n        //模拟数据请求方法\\n        const fetchData=()=>{\\n            return new Promise(resolve=>{\\n                setTimeout(() => {\\n                    resolve({\\n                        code:0,\\n                        data: tempData\\n                    })\\n                }, 100);\\n            })\\n        }\\n\\n        let res = await fetchData();\\n\\n        return res;\\n    }\\n\\n    handlerClick(){\\n        alert('一起来玩 react 服务端渲染');\\n    }\\n\\n    render() {\\n        return <div onClick={this.handlerClick}>hello world。</div>\\n    }\\n}\\n\\n\\n\")])])]),a(\"p\",[t._v(\"数据预取方法设置已完成，下一步需要在服务端调用这个方法。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"服务端数据预取实现\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#服务端数据预取实现\"}},[t._v(\"#\")]),t._v(\" 服务端数据预取实现\")]),t._v(\" \"),a(\"p\",[a(\"code\",[t._v(\"server\")]),t._v(\" 端接到客户端的请求，通过\"),a(\"code\",[t._v(\"req url path\")]),t._v(\" 来进行路由匹配，然后得到需要渲染的组件后调用数据预取方法。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"路由如何匹配\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#路由如何匹配\"}},[t._v(\"#\")]),t._v(\" 路由如何匹配?\")]),t._v(\" \"),a(\"p\",[t._v(\"到这里我们又遇到了个问题 - 路由如何匹配。\")]),t._v(\" \"),a(\"p\",[t._v(\"每个路由都有 \"),a(\"code\",[t._v(\"path\")]),t._v(\" 属性，所以完全可以根据路由的 \"),a(\"code\",[t._v(\"path\")]),t._v(\" 去匹配。\")]),t._v(\" \"),a(\"p\",[t._v(\"最简单的方式无疑就是遍历路由配置，对比 \"),a(\"code\",[t._v(\"req path\")]),t._v(\" 和路由\"),a(\"code\",[t._v(\"path\")]),t._v(\" 。\")]),t._v(\" \"),a(\"p\",[t._v(\"参考代码\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"//路由配置文件\\n\\nimport Index from '../pages/index';\\nimport List from '../pages/list';\\n\\n\\nexport default [\\n\\n    {\\n        path:'/index',\\n        component:Index\\n    },\\n    {\\n        path: '/list',\\n        component: List\\n    }\\n]\\n\\n\\n//根据请求 path 查找路由\\nconst matchRoute=(path,routeList)=>{\\n    let route;\\n    for(var item of routeList){\\n        if(item.path===path){//路由匹配\\n            route = item;\\n        }\\n        break;\\n    }\\n\\n    return route;\\n}\\n\\n\\n\")])])]),a(\"p\",[t._v(\"上面的代码看着没什么问题,但只能处理静态路由，如果是动态路由的话上面的方法就无能为力了。\")]),t._v(\" \"),a(\"p\",[t._v(\"静态路由\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(' <Route path=\"/item\"  exact={true} component={Item}></Route>\\n\\n')])])]),a(\"p\",[t._v(\"动态路由\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('<Route path=\"/item/:id\"  exact={true} component={Root}></Route>\\n\\n')])])]),a(\"p\",[t._v(\"当然我们都知道这种动态 \"),a(\"code\",[t._v(\"path\")]),t._v(\" 就需要正则来进行匹配了。\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"path-to-regexp\")])]),t._v(\" \"),a(\"p\",[t._v(\"此时我们就需要使用工具来处理了。\")]),t._v(\" \"),a(\"p\",[t._v(\"该工具库用来处理 \"),a(\"code\",[t._v(\"url\")]),t._v(\" 中地址与参数，可以将动态路径转换为所对应的正则。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"const keys = [];\\n\\nconst regexp = pathToRegexp(\\\"/foo/:bar\\\", keys);\\n\\n// regexp = /^\\\\/foo\\\\/([^\\\\/]+?)\\\\/?$/i\\n// keys = [{ name: 'bar', prefix: '/', suffix: '', pattern: '[^\\\\\\\\/#\\\\\\\\?]+?', modifier: '' }]\\n\\n\")])])]),a(\"p\",[t._v(\"还可以直接用于路径匹配\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"const regexp = pathToRegexp(\\\"/:foo/:bar\\\");\\n// keys = [{ name: 'foo', prefix: '/', ... }, { name: 'bar', prefix: '/', ... }]\\n \\nregexp.exec(\\\"/test/route\\\");\\n//=> [ '/test/route', 'test', 'route', index: 0, input: '/test/route', groups: undefined ]\\n\\n\")])])]),a(\"p\",[t._v(\"说到这里相信我们的问题已经解决了。\")]),t._v(\" \"),a(\"p\",[t._v(\"不过上面只是介绍下原理，具体的应用其实\"),a(\"code\",[t._v(\"react-router\")]),t._v(\"内已经内置了，而且内部处理机制也是利用\"),a(\"code\",[t._v(\"pathToRegexp\")]),t._v(\"这个库。\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"matchPath 方法\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('import { matchPath } from \"react-router\";\\n\\n')])])]),a(\"p\",[t._v(\"该方法主要就是用于路由的匹配。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('const match = matchPath(\"/users/123\", {\\n  path: \"/users/:id\",\\n  exact: true,\\n  strict: false\\n});\\n\\n')])])]),a(\"p\",[t._v(\"完善下组件匹配方法\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"//根据请求 path 匹配路由，结果返回该路由\\nconst matchRoute=(opt)=>{\\n    let {path} = opt;\\n    let route;\\n    for(var item of routeList){\\n       if(matchPath(path,item)){\\n        route = item;\\n        break;\\n       }\\n    }\\n    return route;\\n}\\n\\n\")])])]),a(\"p\",[a(\"strong\",[t._v(\"完成数据预取\")])]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"查找到组件后，调用组件的数据预取方法得到数据\")]),t._v(\" \"),a(\"li\",[t._v(\"得到数据后，将数据传递给组件\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"export default  async (ctx,next)=>{\\n\\n    const path = ctx.request.path;\\n\\n    //查找到的目标路由对象\\n    let targetRoute = matchRoute(path,routeList);\\n\\n    //数据预取 -> fetchResult\\n    let fetchDataFn = targetRoute.component.getInitialProps;\\n    let fetchResult = {};\\n    if(fetchDataFn){\\n        fetchResult = await fetchDataFn();\\n    }\\n\\n     //将预取数据在这里传递过去 组内通过props.staticContext获取\\n    const context = {\\n        initialData: fetchResult\\n    };\\n\\n    html = renderToString(<StaticRouter location={path} context={context}>\\n        <App routeList={routeList}></App>\\n    </StaticRouter>);\\n    //....\\n\\n    await next();\\n}\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"组件-render-逻辑处理\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#组件-render-逻辑处理\"}},[t._v(\"#\")]),t._v(\" 组件 render 逻辑处理\")]),t._v(\" \"),a(\"p\",[t._v(\"组件从\"),a(\"code\",[t._v(\"props.staticContext.initialData\")]),t._v(\"得到数据。\")]),t._v(\" \"),a(\"p\",[a(\"code\",[t._v(\"render\")]),t._v(\"方法增加渲染逻辑\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"//list 页面 组件\\nexport default class Index extends React.Component {\\n    constructor(props) {\\n        super(props);   \\n        //得到初始化数据\\n        + initialData = props.staticContext.initialData||{};\\n        \\n        + this.state=initialData;\\n    }\\n\\n    static async  getInitialProps() {\\n        //...\\n    }\\n\\n    render() {\\n        //渲染逻辑\\n        + const {code,data}=this.state;\\n        \\n        return <div>\\n        + {data && data.map((item,index)=>{\\n            return <div key={index}>\\n                <h3>{item.title}</h3>\\n                <p>{item.desc}</p>\\n            </div>\\n        })}\\n        {!data&&<div>暂无数据</div>}\\n        </div>\\n    }\\n}\\n\\n\")])])]),a(\"p\",[t._v(\"到这里，服务端的数据直出就处理完成了，查看网页源代码已经能看到直出的数据。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/2/16f66a00d7a31c23?w=699&h=454&f=png&s=337886\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"但是如果查看页面效果的话，页面内容会一闪而过，最终页面只显示一个\"),a(\"code\",[t._v(\"暂无数据\")]),t._v(\" 。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/12/31/16f57be0705b4ac8?w=1000&h=1068&f=png&s=255526\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/2/16f66ad212f41af6?w=500&h=375&f=png&s=20589\",alt:\"\"}})]),t._v(\" \"),a(\"h1\",{attrs:{id:\"数据脱水\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据脱水\"}},[t._v(\"#\")]),t._v(\" 数据脱水\")]),t._v(\" \"),a(\"p\",[t._v(\"继续分析，出现以上问题的原因。\")]),t._v(\" \"),a(\"p\",[t._v(\"导致这个问题的原因是因为在浏览器端进行渲染的时候，没有该数据。\")]),t._v(\" \"),a(\"p\",[t._v(\"结果导致双端节点对比失败，最终采用的是客户端的渲染结果。\")]),t._v(\" \"),a(\"p\",[t._v(\"所以，浏览器端也需要有相同的数据，使组件可以渲染出和服务端相同的结构，才能够通过双端节点对比。才不会被客户端的结构覆盖,从而使用服务端直出的 \"),a(\"code\",[t._v(\"html\")]),t._v(\" 结构。\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"浏览器端组件渲染前如何才能得到服务端的数据呢？\")])]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"得到了数据如何传递给组件呢？\")])]),t._v(\" \"),a(\"p\",[t._v(\"第一排除通过接口请求，那就是重复请求了,没意义。\")]),t._v(\" \"),a(\"p\",[t._v(\"服务端返回相应数据后页面就被浏览器接管了，所以只能在接管之前做一些操作。\")]),t._v(\" \"),a(\"p\",[t._v(\"我们可以直接把数据也吐给浏览器，将数据序列化后作为字符串直出到页面，这样在浏览器端就可以在组件渲染前很方便的得到数据。\")]),t._v(\" \"),a(\"p\",[t._v(\"为了防止 \"),a(\"code\",[t._v(\"xss\")]),t._v(\" 攻击，咱们这里将数据放到了\"),a(\"code\",[t._v(\"textarea\")]),t._v(\"标签内。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('//...\\n\\n    ctx.body=`<!DOCTYPE html>\\n<html lang=\"en\">\\n<head>\\n    <meta charset=\"UTF-8\">\\n    <title>my react ssr</title>\\n</head>\\n<body>\\n    <div id=\"root\">\\n       ${html}\\n    </div>\\n    + <textarea id=\"ssrTextInitData\" style=\"display:none;\">\\n    ${JSON.stringify(fetchResult)}\\n    </textarea>\\n</body>\\n</html>\\n</body>\\n\\n//.....\\n\\n')])])]),a(\"p\",[t._v(\"ok，经过我们上面的分析和实现，我们在直出组件的时候同时将数据源也输出给浏览器，而这个过程就叫做\"),a(\"code\",[t._v(\"数据脱水\")]),t._v(\"。\")]),t._v(\" \"),a(\"h1\",{attrs:{id:\"数据注水\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据注水\"}},[t._v(\"#\")]),t._v(\" 数据注水\")]),t._v(\" \"),a(\"p\",[t._v(\"现在还差最后一步，浏览器端得到了数据后，如何使用该数据呢？\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"浏览器端在组件渲染前，得到初始化数据\")]),t._v(\" \"),a(\"li\",[t._v(\"将数据作为属性传递给组件\")])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"得到初始化数据\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#得到初始化数据\"}},[t._v(\"#\")]),t._v(\" 得到初始化数据\")]),t._v(\" \"),a(\"p\",[t._v(\"这个很简单了，直接上代码\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"//初始数据\\nlet initialData =JSON.parse( document.getElementById('ssrTextInitData').value);\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"将数据作为属性传递给组件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#将数据作为属性传递给组件\"}},[t._v(\"#\")]),t._v(\" 将数据作为属性传递给组件\")]),t._v(\" \"),a(\"p\",[t._v(\"如何将数据作为属性传递给组件呢？\")]),t._v(\" \"),a(\"p\",[t._v(\"方法其实有很多种，下面算是其中一个方法。\")]),t._v(\" \"),a(\"p\",[t._v(\"可以根据当前的 \"),a(\"code\",[t._v(\"path\")]),t._v(\"匹配到目标路由，然后在路由的\"),a(\"code\",[t._v(\"render\")]),t._v(\"方法内将数据传递给组件即可。\")]),t._v(\" \"),a(\"p\",[t._v(\"ps:因为在服务端渲染的时候我们传入初始数据的属性为\"),a(\"code\",[t._v(\"initialData\")]),t._v(\",所以客户端最好使用同一个属性来传递。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// ./src/client/app/index.js\\n//浏览器端页面结构渲染入口\\n\\nimport React from 'react';\\nimport ReactDom from 'react-dom';\\nimport App from '../router/index';\\nimport { BrowserRouter} from 'react-router-dom';\\nimport routeList from '../router/route-config';\\n\\nfunction clientRender() {\\n    //初始数据\\n    let initialData =JSON.parse( document.getElementById('ssrTextInitData').value);\\n\\n    //查找路由\\n    let route = matchRoute(document.location.pathname,routeList);\\n\\n    //设置组件初始化数据 [关键点]\\n    route.initialData =initialData;\\n\\n    //渲染index\\n    ReactDom.hydrate(<BrowserRouter>\\n            <App routeList={routeList}/>\\n    </BrowserRouter>\\n        , document.getElementById('root'))\\n\\n}\\n//渲染入口\\nclientRender();\\n\\n\\n\")])])]),a(\"p\",[t._v(\"然后看下在\"),a(\"code\",[t._v(\"App\")]),t._v(\"组件内做的一些处理。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('function App({routeList}) {\\n    return (\\n            <Layout> \\n               <Switch>\\n                {\\n                    routeList.map(item=>{\\n                        //判断是否有初始数据\\n                        return item.initialData ? <Route key={item.path} exact={item.exact} path={item.path}  render={(props)=>{\\n                            props.initialData = item.initialData;\\n                            return <item.component {...props}></item.component>\\n                        }}></Route> : <Route key={item.path} {...item}></Route>\\n                    })\\n                }\\n                <Route to=\"*\" component={Page404}></Route>\\n            </Switch>\\n            </Layout>\\n    );\\n}\\n\\n')])])]),a(\"p\",[t._v(\"到这里，我们进入到\"),a(\"code\",[t._v(\"/list\")]),t._v(\"页面,它的渲染结果已经正常，数据也能够正常的显示。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/12/31/16f57cab0429996d?w=1000&h=946&f=png&s=234480\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"这个将数据和组件调和渲染的过程就是\"),a(\"code\",[t._v(\"数据注水\")]),t._v(\"。\")]),t._v(\" \"),a(\"h1\",{attrs:{id:\"彻底解决问题\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#彻底解决问题\"}},[t._v(\"#\")]),t._v(\" 彻底解决问题\")]),t._v(\" \"),a(\"p\",[t._v(\"到这里，首次访问的结果是正常了，但是仍然有问题，在这里我们彻底解决它。\")]),t._v(\" \"),a(\"p\",[t._v(\"在上图中我们页面中有两个链接，分别是首页和列表页。\")]),t._v(\" \"),a(\"p\",[t._v(\"上面访问的是\"),a(\"code\",[t._v(\"/list\")]),t._v(\"列表页，但是如果我们第一次就访问\"),a(\"code\",[t._v(\"/index\")]),t._v(\"路由，再点击列表页链接，列表页的数据竟然消失了。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/12/31/16f5a22c7535e623?w=500&h=375&f=png&s=21762\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/12/31/16f5a233370d47ab?w=500&h=375&f=png&s=26541\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"这是什么原因？\")]),t._v(\" \"),a(\"p\",[t._v(\"我们都知道首次进入页面走服务端 \"),a(\"code\",[t._v(\"ssr\")]),t._v(\"，后续访问就\"),a(\"code\",[t._v(\"spa\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"现在列表页的数据只能在\"),a(\"code\",[t._v(\"ssr\")]),t._v(\" 模式下才能拿到，如果是 \"),a(\"code\",[t._v(\"spa\")]),t._v(\" 就拿不到了。\")]),t._v(\" \"),a(\"p\",[t._v(\"如何处理？\")]),t._v(\" \"),a(\"p\",[t._v(\"这个就比较简单了，和我们平时开发\"),a(\"code\",[t._v(\"spa\")]),t._v(\"一样。\")]),t._v(\" \"),a(\"p\",[t._v(\"我们可以在\"),a(\"code\",[t._v(\"componentDidMount\")]),t._v(\"内获取数据然后更新 \"),a(\"code\",[t._v(\"state\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"ps: 实现比较简单，但是需要做个容错，判断下是否有初始化数据，以免重复请求，浪费资源。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"  componentDidMount(){\\n        if(!this.state.data){//判断是否有初始化数据\\n            //进行数据请求\\n            Index.getInitialProps().then(res=>{\\n                this.setState({\\n                    data:res.data||[]\\n                })\\n            })\\n        }\\n    }\\n\\n\")])])]),a(\"p\",[t._v(\"到这里，页面的整体数据同构渲染已经完成，效果已经达到预期。\")]),t._v(\" \"),a(\"h1\",{attrs:{id:\"公共方法\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#公共方法\"}},[t._v(\"#\")]),t._v(\" 公共方法\")]),t._v(\" \"),a(\"p\",[t._v(\"上面的实现过程中，服务端和浏览器端都用到了路由的匹配，所以我们可以将这个方法提出来，供双端调用。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"\\n// src/share/match-route.js\\n// 根据 path， 匹配路由 \\n\\nimport { matchPath} from 'react-router';\\n\\nexport default (path,routeList)=>{ \\n        let route;\\n        for (var item of routeList) {\\n            if (matchPath(path, item)) {\\n                route = item;//查找到第一个路由后停止查找\\n                break;\\n            }\\n        }\\n        return  route;\\n}\\n\\n\")])])]),a(\"h1\",{attrs:{id:\"小结\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[t._v(\"#\")]),t._v(\" 小结\")]),t._v(\" \"),a(\"p\",[t._v(\"本节主要使用一个小需求来抛砖引玉，带出来了一系列的问题，让我们逐步的分析和实现了数据同构。\")]),t._v(\" \"),a(\"p\",[t._v(\"关键步骤如下:\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"方法同构： 为组件声明\"),a(\"code\",[t._v(\"getInitialProps\")]),t._v(\"静态方法，这是一个同构方法，用于双端的数据获取\")]),t._v(\" \"),a(\"li\",[t._v(\"数据预取：在服务端通过路由匹配找到目标的组件，然后调用组件的数据预取方法得到数据\")]),t._v(\" \"),a(\"li\",[t._v(\"将初始化数据作为属性传递给组件\")]),t._v(\" \"),a(\"li\",[t._v(\"数据脱水：将数据序列化,和 \"),a(\"code\",[t._v(\"html\")]),t._v(\"字符串 一起直出返回给浏览器端\")]),t._v(\" \"),a(\"li\",[t._v(\"数据注水:浏览器端得到服务端直出的数据，也通过属性将数据传给组件\")]),t._v(\" \"),a(\"li\",[t._v(\"如果初始化数据不存在，则可以在\"),a(\"code\",[t._v(\"componentDidMount\")]),t._v(\"生命周期内请求一次数据\")])]),t._v(\" \"),a(\"p\",[t._v(\"本节内容较多，但并不复杂，重要的是理清思路。\")]),t._v(\" \"),a(\"p\",[t._v(\"本节代码已上传\")]),t._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-dataiso\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-dataiso\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"p\",[t._v(\"感谢你的阅读。\")]),t._v(\" \"),a(\"p\",[t._v(\"如果有问题欢迎留言，也欢迎在留言区留下你的想法和思考。\")])])}),[],!1,null,null,null);e.default=s.exports}}]);","extractedComments":[]}