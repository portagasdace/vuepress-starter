{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{476:function(e,t,n){\"use strict\";n.r(t);var a=n(42),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"flutter-与-native-通信-platformchannel\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#flutter-与-native-通信-platformchannel\"}},[e._v(\"#\")]),e._v(\" Flutter 与 Native 通信：PlatformChannel\")]),e._v(\" \"),n(\"p\",[e._v(\"本节介绍 PlatformChannel 的使用。\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"platformchannel-介绍\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#platformchannel-介绍\"}},[e._v(\"#\")]),e._v(\" PlatformChannel 介绍\")]),e._v(\" \"),n(\"p\",[e._v(\"PlatformChannel 用于 Flutter 与 Native(Android、iOS) 之间的消息传递。\")]),e._v(\" \"),n(\"p\",[e._v(\"不仅可以方便的将 Native 的功能拓展给 Flutter 使用，而且也能将 Flutter 的功能扩展给 Native 使用。\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"platformchannel-的架构图\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#platformchannel-的架构图\"}},[e._v(\"#\")]),e._v(\" PlatformChannel 的架构图\")]),e._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/3/11/1696b4f77f90f8f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\",alt:\"img\"}})]),e._v(\" \"),n(\"p\",[e._v(\"上图是 PlatformChannel 的架构图，Flutter 与 Native 之间采用的是消息传递的模式，一个是 Client，一个是 Host：\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"Client 通过 PlatformChannel 向 Host 发送消息。\")]),e._v(\" \"),n(\"li\",[e._v(\"Host 监听 PlatformChannel，接受消息，然后将响应结果发送给 Client。这样就完成了 Flutter 与 Native 之间的消息传递。\")]),e._v(\" \"),n(\"li\",[e._v(\"而且 Flutter 与 Native 之间的消息传递都是异步的，所以不会阻塞 UI。\")])]),e._v(\" \"),n(\"p\",[e._v(\"而且由于 PlatformChannel 是双工的，所以 Flutter 和 Native 可以互相做 Client 和 Host。\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"platformchannel-的种类\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#platformchannel-的种类\"}},[e._v(\"#\")]),e._v(\" PlatformChannel 的种类\")]),e._v(\" \"),n(\"p\",[e._v(\"有三种 PlatformChannel 种类，适用于不同的场景：\")]),e._v(\" \"),n(\"ol\",[n(\"li\",[n(\"p\",[e._v(\"MethodChannel\")]),e._v(\" \"),n(\"p\",[e._v(\"以方法的模式使用 PlatformChannel\")])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"EventChannel\")]),e._v(\" \"),n(\"p\",[e._v(\"以事件的模式使用 PlatformChannel\")])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"BasicMessageChannel\")]),e._v(\" \"),n(\"p\",[e._v(\"可以在 BasicMessageChannel 上方便的进行自定义扩展，主要用于个性化的扩展。\")])])]),e._v(\" \"),n(\"p\",[e._v(\"MethodChannel 和 EventChannel 这两个已经封装好了使用方式，是我们最常用的，我们一般很少使用 BasicMessageChannel。后面我们会着重讲一下 MethodChannel 和 EventChannel 的使用。\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"codec\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#codec\"}},[e._v(\"#\")]),e._v(\" codec\")]),e._v(\" \"),n(\"p\",[e._v(\"又因为同时要在 Flutter、Android、iOS 这三个不同的平台上传递消息，就需要可以在三个平台上都能处理的数据，所以需要对传递的消息进行编解码，而且只能支持一些基本数据类型的传递，传递过程如下：\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"首先将 Client 端平台的数据进行编码，然后通过 PlatformChannel 发送\")]),e._v(\" \"),n(\"li\",[e._v(\"Host 端接受到消息后，将消息解码成Host端平台的数据类型\")]),e._v(\" \"),n(\"li\",[e._v(\"Host 端向 Client 端发送回应的消息，同样要先进行编码后，才能发送\")]),e._v(\" \"),n(\"li\",[e._v(\"Client 端接收到消息后，将消息解码成 Client 端平台的数据类型\")])]),e._v(\" \"),n(\"p\",[e._v(\"在这个过程中，编解码的方法就叫 \"),n(\"code\",[e._v(\"codec\")]),e._v(\"。每一个 PlatformChannel 都有一个 codec。\")]),e._v(\" \"),n(\"p\",[e._v(\"下面是每种 PlatformChannel 使用的 codec：\")]),e._v(\" \"),n(\"p\",[e._v(\"MethodChannel\")]),e._v(\" \"),n(\"p\",[e._v(\"EventChannel\")]),e._v(\" \"),n(\"p\",[e._v(\"BasicMessageChannel\")]),e._v(\" \"),n(\"p\",[e._v(\"codec\")]),e._v(\" \"),n(\"p\",[e._v(\"StandartMethodCodec\")]),e._v(\" \"),n(\"p\",[e._v(\"StandartMethodCodec\")]),e._v(\" \"),n(\"p\",[e._v(\"MessageCodec 的实现类，需要自己设置，包括上面的四个和自己的实现都行\")]),e._v(\" \"),n(\"p\",[e._v(\"PlatformChannel 的 codec 主要分为两类：\")]),e._v(\" \"),n(\"ol\",[n(\"li\",[n(\"p\",[e._v(\"MethodCodec\")]),e._v(\" \"),n(\"p\",[e._v(\"MethodCodec 是一个接口，它的实现类是如下的两个：\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"StandartMethodCodec：可以编解码 PlatformChannel 支持的所有类型的数据\")]),e._v(\" \"),n(\"li\",[e._v(\"JSONMethodCodec：只可以编解码 JSON 类型的数据\")])])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"MessageCodec\")]),e._v(\" \"),n(\"p\",[e._v(\"MessageCodec 是一个接口，它的实现类是如下的四个：\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"StandardMessageCodec：可以编解码 PlatformChannel 支持的所有类型的数据\")]),e._v(\" \"),n(\"li\",[e._v(\"BinaryCodec：只可以编解码 byte 类型的数据\")]),e._v(\" \"),n(\"li\",[e._v(\"StringCodec：只可以编解码 String 类型的数据\")]),e._v(\" \"),n(\"li\",[e._v(\"JSONMessageCodec：只可以编解码 JSON 类型的数据\")])])])]),e._v(\" \"),n(\"h3\",{attrs:{id:\"platformchannel-支持的数据类型\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#platformchannel-支持的数据类型\"}},[e._v(\"#\")]),e._v(\" PlatformChannel 支持的数据类型\")]),e._v(\" \"),n(\"p\",[e._v(\"下图是PlatformChannel支持的数据类型，以及在 Flutter、Android、iOS 三个平台上转化的对应关系：\")]),e._v(\" \"),n(\"p\",[e._v(\"Flutter\")]),e._v(\" \"),n(\"p\",[e._v(\"Android\")]),e._v(\" \"),n(\"p\",[e._v(\"iOS\")]),e._v(\" \"),n(\"p\",[e._v(\"null\")]),e._v(\" \"),n(\"p\",[e._v(\"null\")]),e._v(\" \"),n(\"p\",[e._v(\"nil (NSNull when nested)\")]),e._v(\" \"),n(\"p\",[e._v(\"bool\")]),e._v(\" \"),n(\"p\",[e._v(\"java.lang.Boolean\")]),e._v(\" \"),n(\"p\",[e._v(\"NSNumber numberWithBool:\")]),e._v(\" \"),n(\"p\",[e._v(\"int\")]),e._v(\" \"),n(\"p\",[e._v(\"java.lang.Integer\")]),e._v(\" \"),n(\"p\",[e._v(\"NSNumber numberWithInt:\")]),e._v(\" \"),n(\"p\",[e._v(\"int, if 32 bits not enough\")]),e._v(\" \"),n(\"p\",[e._v(\"java.lang.Long\")]),e._v(\" \"),n(\"p\",[e._v(\"NSNumber numberWithLong:\")]),e._v(\" \"),n(\"p\",[e._v(\"double\")]),e._v(\" \"),n(\"p\",[e._v(\"java.lang.Double\")]),e._v(\" \"),n(\"p\",[e._v(\"NSNumber numberWithDouble:\")]),e._v(\" \"),n(\"p\",[e._v(\"String\")]),e._v(\" \"),n(\"p\",[e._v(\"java.lang.String\")]),e._v(\" \"),n(\"p\",[e._v(\"NSString\")]),e._v(\" \"),n(\"p\",[e._v(\"Uint8List\")]),e._v(\" \"),n(\"p\",[e._v(\"byte[]\")]),e._v(\" \"),n(\"p\",[e._v(\"FlutterStandardTypedData typedDataWithBytes:\")]),e._v(\" \"),n(\"p\",[e._v(\"Int32List\")]),e._v(\" \"),n(\"p\",[e._v(\"int[]\")]),e._v(\" \"),n(\"p\",[e._v(\"FlutterStandardTypedData typedDataWithInt32:\")]),e._v(\" \"),n(\"p\",[e._v(\"Int64List\")]),e._v(\" \"),n(\"p\",[e._v(\"long[]\")]),e._v(\" \"),n(\"p\",[e._v(\"FlutterStandardTypedData typedDataWithInt64:\")]),e._v(\" \"),n(\"p\",[e._v(\"Float64List\")]),e._v(\" \"),n(\"p\",[e._v(\"double[]\")]),e._v(\" \"),n(\"p\",[e._v(\"FlutterStandardTypedData typedDataWithFloat64:\")]),e._v(\" \"),n(\"p\",[e._v(\"List\")]),e._v(\" \"),n(\"p\",[e._v(\"java.util.ArrayList\")]),e._v(\" \"),n(\"p\",[e._v(\"NSArray\")]),e._v(\" \"),n(\"p\",[e._v(\"Map\")]),e._v(\" \"),n(\"p\",[e._v(\"java.util.HashMap\")]),e._v(\" \"),n(\"p\",[e._v(\"NSDictionary\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"platformchannel-methodchannel-的使用\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#platformchannel-methodchannel-的使用\"}},[e._v(\"#\")]),e._v(\" PlatformChannel -- MethodChannel 的使用\")]),e._v(\" \"),n(\"p\",[e._v(\"本节讲一下 MethodChannel 的使用方法。MethodChannel 既可以让 Flutter 调用 Android，也可以让 Android 调用 Flutter。\")]),e._v(\" \"),n(\"p\",[e._v(\"这里写两个例子，一个是 Flutter 调用 Android 功能的例子，另一个是 Android 调用 Flutter 功能的例子。\")]),e._v(\" \"),n(\"blockquote\",[n(\"p\",[e._v(\"PlatformChannel 涉及到编写 Native 代码，所以除了 VS Code，还需要使用 Android Studio 和 Xcode。\")])]),e._v(\" \"),n(\"h3\",{attrs:{id:\"flutter-调用-android-功能\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#flutter-调用-android-功能\"}},[e._v(\"#\")]),e._v(\" Flutter 调用 Android 功能\")]),e._v(\" \"),n(\"p\",[e._v(\"使用 Flutter 弹一个 Android 的 Toast。\")]),e._v(\" \"),n(\"p\",[e._v(\"为了实现这一样功能，需要使用 Flutter 调用 Android 的功能，那么这里 Flutter 是 Client，Android 是 Host。\")]),e._v(\" \"),n(\"p\",[e._v(\"需要在 Android端 上实现监听及功能，然后在 Flutter端 调用。\")]),e._v(\" \"),n(\"h4\",{attrs:{id:\"在-android-端添加监听及实现功能\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在-android-端添加监听及实现功能\"}},[e._v(\"#\")]),e._v(\" 在 Android 端添加监听及实现功能：\")]),e._v(\" \"),n(\"p\",[e._v(\"Android 端是 Host，在 Android 的代码里找到 \"),n(\"code\",[e._v(\"MainActivity.java\")]),e._v(\" ,然后在 \"),n(\"code\",[e._v(\"OnCreate()\")]),e._v(\" 里使用 \"),n(\"code\",[e._v(\"MethodChannel\")]),e._v(\" 添加监听：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('  @Override\\n  protected void onCreate(Bundle savedInstanceState) {\\n    super.onCreate(savedInstanceState);\\n    GeneratedPluginRegistrant.registerWith(this);\\n\\n    new MethodChannel(getFlutterView(),\"samples.flutter.io/toast\").setMethodCallHandler(new MethodChannel.MethodCallHandler() {\\n      @Override\\n      public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) {\\n        \\n      }\\n    });\\n  }    \\n\\n')])])]),n(\"p\",[e._v(\"这里 \"),n(\"code\",[e._v(\"new MethodChannel\")]),e._v(\" 的实例，需要两个参数：\")]),e._v(\" \"),n(\"ol\",[n(\"li\",[n(\"p\",[e._v(\"第一个是 BinaryMessenger\")]),e._v(\" \"),n(\"p\",[e._v(\"这里用的是 FlutterView，因为 FlutterView 实现了 BinaryMessenger 的接口，在 MainActivity 里通过 getFlutterView() 获取\")])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"第二个是 String\")]),e._v(\" \"),n(\"p\",[e._v('是 Channel Name，用于标识不同的 MethodChannel，这个值可以随便取，但每个 MethodChannel 都必须是唯一的，一般取值是：包名+\"/\"+功能，这个值在 Flutter 中也要用，Flutter 正是通过这个来区分不同的 MethodChannel 的。在 demo 里我取的值是 '),n(\"code\",[e._v(\"samples.flutter.io/toast\")]),e._v(\"。\")])])]),e._v(\" \"),n(\"p\",[e._v(\"创建完 \"),n(\"code\",[e._v(\"MethodChannel\")]),e._v(\" 的实例后，还需要添加监听，是通过 \"),n(\"code\",[e._v(\"MethodChannel\")]),e._v(\" 的 \"),n(\"code\",[e._v(\"setMethodCallHandler\")]),e._v(\" 来添加监听的。\")]),e._v(\" \"),n(\"p\",[e._v(\"监听监听完后，在看回调里的两个参数：\")]),e._v(\" \"),n(\"ol\",[n(\"li\",[n(\"p\",[e._v(\"MethodCall\")]),e._v(\" \"),n(\"p\",[e._v(\"从 Flutter 端传送来的数据。\")]),e._v(\" \"),n(\"p\",[e._v(\"MethodCall 里有如下的几个方法，用来获取从 Flutter 端传送来的数据：\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[e._v(\"methodCall.method：\")]),e._v(\" \"),n(\"p\",[e._v(\"methodCall 的属性，获取方法名，用于标识 Flutter 想调用 Android 的哪个方法，这里 method 只能是 String 类型，这就要求 Flutter 只能传 String\")])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"methodCall.arguments\")]),e._v(\" \"),n(\"p\",[e._v(\"methodCall 的属性，获取具体的参数，这里 arguments 只能是 Map 类型或者 JSONObject 类型，这就要求 Flutter 只能传这两种类型的数据\")])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"methodCall.argument(String key)\")]),e._v(\" \"),n(\"p\",[e._v(\"methodCall 的方法，获取 Key 为特定值的参数的值\")])])])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"MethodChannel.Result\")]),e._v(\" \"),n(\"p\",[e._v(\"Android 向 Flutter 端发送数据\")]),e._v(\" \"),n(\"p\",[e._v(\"Android 端处理完从 Flutter 端传来的数据后，就需要向 Flutter 端发送数据，使用如下的方法：\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[e._v(\"result.success(Object result)\")]),e._v(\" \"),n(\"p\",[e._v(\"如果运行成功，使用这个方法，同时将 result 返回给 Flutter,请注意，result 只能是 PlatformChannel 支持的数据类型\")])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"result.error(String errorCode,String errorMsg,Object errorDetails)\")]),e._v(\" \"),n(\"p\",[e._v(\"如果运行失败，使用这个方法,带入 errorCode、errorMsg 还有 errorDetails 的参数，errorDetails 只能是 PlatformChannel 支持的数据类型\")])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"result.notImplemented()\")]),e._v(\" \"),n(\"p\",[e._v(\"如果 Flutter 想调用的方法,Android 没有实现，使用这个方法。会将 notImplemented 返回给 Flutter。\")])])])])]),e._v(\" \"),n(\"p\",[e._v(\"下面是 MainActivity.java 里的代码：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('    package com.kk.flutter_app;\\n\\n    import android.os.Bundle;\\n    import android.widget.Toast;\\n    \\n    import io.flutter.app.FlutterActivity;\\n    import io.flutter.plugin.common.MethodCall;\\n    import io.flutter.plugin.common.MethodChannel;\\n    import io.flutter.plugins.GeneratedPluginRegistrant;\\n    \\n    public class MainActivity extends FlutterActivity {\\n      @Override\\n      protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        GeneratedPluginRegistrant.registerWith(this);\\n    \\n        new MethodChannel(getFlutterView(),\"samples.flutter.io/toast\").setMethodCallHandler(new MethodChannel.MethodCallHandler() {\\n          @Override\\n          public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) {\\n            if(\"toast\".equals(methodCall.method)){\\n              if(methodCall.hasArgument(\"content\")){\\n                Toast.makeText(getBaseContext(), methodCall.argument(\"content\"),Toast.LENGTH_SHORT).show();\\n                result.success(\"success\");\\n              }else {\\n                result.error(\"-1\",\"toast fail\",\"content is null\");\\n              }\\n            }else {\\n              result.notImplemented();\\n            }\\n          }\\n        });\\n      }\\n    }\\n\\n')])])]),n(\"p\",[e._v(\"使用 \"),n(\"code\",[e._v(\"methodCall.method\")]),e._v(\" 的值来区分调用哪个方法。\")]),e._v(\" \"),n(\"p\",[e._v(\"如果调用的方法名是 toast，则弹 Toast。\")]),e._v(\" \"),n(\"h4\",{attrs:{id:\"在-flutter-端发送消息\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在-flutter-端发送消息\"}},[e._v(\"#\")]),e._v(\" 在 Flutter 端发送消息：\")]),e._v(\" \"),n(\"p\",[e._v(\"Flutter 端是 Client，首先也要创建一个 MethodChannel 的实例：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"static const platformChannel = const MethodChannel('samples.flutter.io/toast');\\n\\n\")])])]),n(\"p\",[e._v(\"创建 MethodChannel 实例的时候，要传入 ChannelName，ChannelName 必须要和 Android 的 ChannelName 保持一致。ChannelName 用于区分调用哪个方法。\")]),e._v(\" \"),n(\"p\",[e._v(\"然后调用接口：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"    void showToast(String content) async {\\n        var arguments = Map();\\n        arguments['content'] = content;\\n\\n        try {\\n          String result = await platformChannel.invokeMethod('toast', arguments);\\n          //success\\n          print('showToast '+ result);\\n        } on PlatformException catch (e) {\\n          //error\\n          print('showToast ' + e.code + e.message + e.details);\\n        } on MissingPluginException catch (e){\\n          //notImplemented\\n          print('showToast ' + e.message);\\n        }\\n    }\\n\\n\")])])]),n(\"ul\",[n(\"li\",[n(\"code\",[e._v(\"platformChannel.invokeMethod('toast', arguments)\")]),e._v(\" 是调用Android的方法，\")]),e._v(\" \"),n(\"li\",[n(\"code\",[e._v(\"toast\")]),e._v(\" 是要调用的方法名，为String类型；\")]),e._v(\" \"),n(\"li\",[n(\"code\",[e._v(\"arguments\")]),e._v(\" 是参数，只能是Map或者JSON类型，这里是Map类型。\")])]),e._v(\" \"),n(\"blockquote\",[n(\"p\",[e._v(\"为了不阻塞 UI，PlatformChannel 使用 async 和 await 来修饰，而且必须要用 try catch。前面知道有三种返回结果：success、error 、notImplemented，第一个 catch 的 PlatformException 就是 error 的结果，第二个 catch 的 MissingPluginException 就是 notImplemented 的结果。\")])]),e._v(\" \"),n(\"p\",[e._v(\"Flutter 的代码是：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"    import 'package:flutter/material.dart';\\n    import 'package:flutter/services.dart';\\n    \\n    void main() => runApp(MyApp());\\n    \\n    class MyApp extends StatelessWidget {\\n      static const platformChannel =\\n          const MethodChannel('samples.flutter.io/toast');\\n    \\n      @override\\n      Widget build(BuildContext context) {\\n        return MaterialApp(\\n          title: \\\"Flutter Demo\\\",\\n          theme: ThemeData(\\n            primaryColor: Colors.blue,\\n          ),\\n          home: Scaffold(\\n              appBar: AppBar(title: Text(\\\"Platform Channel\\\")),\\n              body: RaisedButton(\\n                  child: Text(\\\"Show Toast\\\"),\\n                  onPressed: () {\\n                    showToast(\\\"Flutter Toast\\\");\\n                  })),\\n        );\\n      }\\n    \\n      void showToast(String content) async {\\n        var arguments = Map();\\n        arguments['content'] = content;\\n    \\n        try {\\n          String result = await platformChannel.invokeMethod('toast', arguments);\\n          print('showToast '+ result);\\n        } on PlatformException catch (e) {\\n          print('showToast ' + e.code + e.message + e.details);\\n        } on MissingPluginException catch (e){\\n          print('showToast ' + e.message);\\n        }\\n      }\\n    }\\n\\n\")])])]),n(\"p\",[e._v(\"下面是运行的效果：\")]),e._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/4/9/16a003a96325707f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\",alt:\"img\"}})]),e._v(\" \"),n(\"h3\",{attrs:{id:\"android-调用-flutter-功能\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#android-调用-flutter-功能\"}},[e._v(\"#\")]),e._v(\" Android 调用 Flutter 功能\")]),e._v(\" \"),n(\"p\",[e._v(\"Android 发送一段文字到 Flutter，并显示在 Flutter 的 UI 上：原本Flutter UI上显示的是\"),n(\"code\",[e._v(\"Flutter Message\")]),e._v(\"，然后将APP退后台，在切到前台，Android向Flutter发送数据，将UI的显示变为\"),n(\"code\",[e._v(\"Android Message\")]),e._v(\"。\")]),e._v(\" \"),n(\"p\",[e._v(\"为了实现这一功能，就需要 Android 调用 Flutter 的功能， 这时 Android 是 Client，而 Flutter 是 Host。\")]),e._v(\" \"),n(\"p\",[e._v(\"所以要在 Flutter 上实现监听和功能，然后在 Android 中使用。\")]),e._v(\" \"),n(\"h4\",{attrs:{id:\"在flutter端添加监听及实现功能\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在flutter端添加监听及实现功能\"}},[e._v(\"#\")]),e._v(\" 在Flutter端添加监听及实现功能：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"    class MyAppState extends State<MyApp> {\\n      static const platformChannel =\\n          const MethodChannel('samples.flutter.io/message');\\n    \\n      String textContent = 'Flutter Message';\\n    \\n      @override\\n      void initState() {\\n        // TODO: implement initState\\n        super.initState();\\n        platformChannel.setMethodCallHandler((methodCall) async {\\n          switch (methodCall.method) {\\n            case 'showText':\\n              String content = await methodCall.arguments['content'];\\n              if (content !=null && content.isNotEmpty) {\\n                setState(() {\\n                  textContent = content;\\n                });\\n                //返回成功的结果\\n                return 'success';\\n              } else {\\n                //返回失败的结果\\n                throw PlatformException(\\n                    code: '-1',\\n                    message: 'showText fail',\\n                    details: 'content is null');\\n              }\\n              break;\\n            default:\\n              //返回方法未实现的结果\\n              throw MissingPluginException();\\n          }\\n        });\\n      }\\n    \\n      @override\\n      Widget build(BuildContext context) {\\n        // TODO: implement build\\n        return ...\\n      }\\n    }\\n\\n\")])])]),n(\"p\",[e._v(\"首先创建 MethodChannel 的实例：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"static const platformChannel = const MethodChannel('samples.flutter.io/message');\\n\\n\")])])]),n(\"p\",[e._v(\"根据前面讲的 StatefulWidget 的生命周期，我们在 initState 里添加 MethodChannel 的监听，就是通过 setMethodCallHandler，为 MethodChannel 添加回调，回调的方式添加了 async，因此不会阻塞 UI：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"    platformChannel.setMethodCallHandler((methodCall) async {\\n      switch (methodCall.method) {\\n        case 'showText':\\n          String content = await methodCall.arguments['content'];\\n          if (content !=null && content.isNotEmpty) {\\n            ...\\n            return 'success';\\n          } else {\\n            throw PlatformException(\\n                code: '-1',\\n                message: 'showText fail',\\n                details: 'content is null');\\n          }\\n          break;\\n        default:\\n          throw MissingPluginException();\\n      }\\n    });\\n\\n\")])])]),n(\"p\",[e._v(\"回调里有个参数 \"),n(\"code\",[e._v(\"methodCall\")]),e._v(\"，和 Android 里的 \"),n(\"code\",[e._v(\"methodCall\")]),e._v(\" 有相同的属性：\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"methodCall.method： 获取方法名，String 类型\")]),e._v(\" \"),n(\"li\",[e._v(\"methodCall.arguments：获取具体的参数，arguments 只能是 Map 类型或者 JSONObject 类型\")])]),e._v(\" \"),n(\"p\",[e._v(\"在返回结果的时候：\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"如果运行成功，则直接 \"),n(\"code\",[e._v(\"return Object\")])]),e._v(\" \"),n(\"li\",[e._v(\"如果允许失败，则 throw 一个 PlatformException,表示运行失败\")]),e._v(\" \"),n(\"li\",[e._v(\"如果方法没有实现，则 throw 一个 MissingPluginException\")])]),e._v(\" \"),n(\"p\",[e._v(\"Flutter部分的全部代码为：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"    import 'package:flutter/material.dart';\\n    import 'package:flutter/services.dart';\\n    \\n    void main() => runApp(MyApp());\\n    \\n    class MyApp extends StatefulWidget {\\n      @override\\n      State<StatefulWidget> createState() {\\n        // TODO: implement createState\\n        return MyAppState();\\n      }\\n    }\\n    \\n    class MyAppState extends State<MyApp> {\\n      static const platformChannel =\\n          const MethodChannel('samples.flutter.io/message');\\n    \\n      String textContent = 'Flutter Message';\\n    \\n      @override\\n      void initState() {\\n        // TODO: implement initState\\n        super.initState();\\n        platformChannel.setMethodCallHandler((methodCall) async {\\n          switch (methodCall.method) {\\n            case 'showText':\\n              String content = await methodCall.arguments['content'];\\n              if (content !=null && content.isNotEmpty) {\\n                setState(() {\\n                  textContent = content;\\n                });\\n                return 'success';\\n              } else {\\n                throw PlatformException(\\n                    code: '-1',\\n                    message: 'showText fail',\\n                    details: 'content is null');\\n              }\\n              break;\\n            default:\\n              throw MissingPluginException();\\n          }\\n        });\\n      }\\n    \\n      @override\\n      Widget build(BuildContext context) {\\n        // TODO: implement build\\n        return MaterialApp(\\n          title: \\\"Flutter Demo\\\",\\n          theme: ThemeData(\\n            primaryColor: Colors.blue,\\n          ),\\n          home: Scaffold(\\n            appBar: AppBar(\\n              title: Text('Platform Channel'),\\n            ),\\n            body: Text(textContent),\\n          ),\\n        );\\n      }\\n    }\\n\\n\\n\")])])]),n(\"p\",[e._v(\"并且实现了在 Flutter 端更新 UI 的功能。\")]),e._v(\" \"),n(\"h4\",{attrs:{id:\"在-android-端发送数据\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在-android-端发送数据\"}},[e._v(\"#\")]),e._v(\" 在 Android 端发送数据\")]),e._v(\" \"),n(\"p\",[e._v(\"发送数据我写在 \"),n(\"code\",[e._v(\"onResume\")]),e._v(\" 里面，当 APP 退后台，在切到前台时就会触发。\")]),e._v(\" \"),n(\"p\",[e._v(\"Android 端的代码还是在 MainActivity.java 里：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('package com.kk.flutter_app;\\n\\nimport android.os.Bundle;\\nimport android.util.Log;\\n\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nimport io.flutter.app.FlutterActivity;\\nimport io.flutter.plugin.common.MethodChannel;\\nimport io.flutter.plugins.GeneratedPluginRegistrant;\\n\\npublic class MainActivity extends FlutterActivity {\\n\\n  MethodChannel methodChannel;\\n  @Override\\n  protected void onCreate(Bundle savedInstanceState) {\\n    super.onCreate(savedInstanceState);\\n    GeneratedPluginRegistrant.registerWith(this);\\n\\n    methodChannel = new MethodChannel(getFlutterView(),\"samples.flutter.io/message\");\\n\\n  }\\n\\n  @Override\\n  protected void onResume() {\\n    super.onResume();\\n    Map map = new HashMap();\\n    map.put(\"content\",\"Android Message\");\\n    methodChannel.invokeMethod(\"showText\", map, new MethodChannel.Result() {\\n      @Override\\n      public void success(Object o) {\\n        Log.d(\"MainActivity\",(String)o);\\n      }\\n\\n      @Override\\n      public void error(String errorCode, String errorMsg, Object errorDetail) {\\n        Log.d(\"MainActivity\",\"errorCode:\"+errorCode+\" errorMsg:\"+errorMsg+\" errorDetail:\"+(String)errorDetail);\\n      }\\n\\n      @Override\\n      public void notImplemented() {\\n        Log.d(\"MainActivity\",\"notImplemented\");\\n      }\\n    });\\n  }\\n}\\n\\n')])])]),n(\"p\",[e._v(\"首先也是先创建 MethodChannel 的实例：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('methodChannel = new MethodChannel(getFlutterView(),\"samples.flutter.io/message\");\\n\\n')])])]),n(\"p\",[e._v(\"然后向 Flutter 发送消息，告诉 Flutter 要调用哪个方法：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('methodChannel.invokeMethod(\"showText\", map, new MethodChannel.Result() {\\n      @Override\\n      public void success(Object o) {\\n        Log.d(\"MainActivity\",(String)o);\\n      }\\n\\n      @Override\\n      public void error(String errorCode, String errorMsg, Object errorDetail) {\\n        Log.d(\"MainActivity\",\"errorCode:\"+errorCode+\" errorMsg:\"+errorMsg+\" errorDetail:\"+(String)errorDetail);\\n      }\\n\\n      @Override\\n      public void notImplemented() {\\n        Log.d(\"MainActivity\",\"notImplemented\");\\n      }\\n    });\\n  }\\n\\n')])])]),n(\"p\",[e._v(\"在 \"),n(\"code\",[e._v(\"MethodChannel.Result()\")]),e._v(\" 回调里有三个方法：\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"success：表示调用成功\")]),e._v(\" \"),n(\"li\",[e._v(\"error：表示调用失败\")]),e._v(\" \"),n(\"li\",[e._v(\"notImplemented：表示没有此方法\")])]),e._v(\" \"),n(\"p\",[e._v(\"刚运行 APP 的效果：\")]),e._v(\" \"),n(\"p\",[e._v(\"![img](data:image/svg+xml;utf8,)\")]),e._v(\" \"),n(\"p\",[e._v(\"退后台，又切到前台的效果：\")]),e._v(\" \"),n(\"p\",[e._v(\"![img](data:image/svg+xml;utf8,)\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"platformchannel-eventchannel-的使用\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#platformchannel-eventchannel-的使用\"}},[e._v(\"#\")]),e._v(\" PlatformChannel -- EventChannel 的使用\")]),e._v(\" \"),n(\"p\",[e._v(\"本节讲一下 EventChannel 使用的使用方法。\")]),e._v(\" \"),n(\"p\",[e._v(\"这里使用 EventChannel 实现一个和上节相同的例子：\")]),e._v(\" \"),n(\"p\",[e._v(\"Android 发送一段文字到 Flutter，并显示在 Flutter 的 UI 上：原本Flutter UI上显示的是\"),n(\"code\",[e._v(\"Flutter Message\")]),e._v(\"，然后将APP退后台，在切到前台，Android向Flutter发送数据，将UI的显示变为\"),n(\"code\",[e._v(\"Android Message\")]),e._v(\"。\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"在-flutter-端添加监听并实现功能\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在-flutter-端添加监听并实现功能\"}},[e._v(\"#\")]),e._v(\" 在 Flutter 端添加监听并实现功能\")]),e._v(\" \"),n(\"p\",[e._v(\"首先是创建 EventChannel：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"static const eventChannel =\\n      const EventChannel('samples.flutter.io/event');\\n\\n\")])])]),n(\"p\",[e._v(\"创建方式和 MethodChannel 是一样的，都需要传入一个字符串。\")]),e._v(\" \"),n(\"p\",[e._v(\"然后在 initState() 里使用 eventChannel 的 listen 方法添加监听：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"eventChannel.receiveBroadcastStream().listen(_onListen,onError: _onError,onDone: _onDone,cancelOnError: false);\\n\\n\")])])]),n(\"p\",[e._v(\"listen 方法定义为：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"  StreamSubscription<T> listen(void onData(T event),\\n      {Function onError, void onDone(), bool cancelOnError});\\n\\n\\n\")])])]),n(\"p\",[e._v(\"可以看到 listen 方法有如下几个参数：\")]),e._v(\" \"),n(\"p\",[e._v(\"参数名字\")]),e._v(\" \"),n(\"p\",[e._v(\"参数类型\")]),e._v(\" \"),n(\"p\",[e._v(\"意义\")]),e._v(\" \"),n(\"p\",[e._v(\"必选 or 可选\")]),e._v(\" \"),n(\"p\",[e._v(\"onData\")]),e._v(\" \"),n(\"p\",[e._v(\"void onData(T event)\")]),e._v(\" \"),n(\"p\",[e._v(\"EventChannel 正常收到数据的事件\")]),e._v(\" \"),n(\"p\",[e._v(\"必选\")]),e._v(\" \"),n(\"p\",[e._v(\"onError\")]),e._v(\" \"),n(\"p\",[e._v(\"Function\")]),e._v(\" \"),n(\"p\",[e._v(\"EventChannel 收到错误的事件\")]),e._v(\" \"),n(\"p\",[e._v(\"可选\")]),e._v(\" \"),n(\"p\",[e._v(\"onDone\")]),e._v(\" \"),n(\"p\",[e._v(\"void onDone()\")]),e._v(\" \"),n(\"p\",[e._v(\"EventChannel 收到结束监听的事件\")]),e._v(\" \"),n(\"p\",[e._v(\"可选\")]),e._v(\" \"),n(\"p\",[e._v(\"cancelOnError\")]),e._v(\" \"),n(\"p\",[e._v(\"bool\")]),e._v(\" \"),n(\"p\",[e._v(\"当出错的时候是不是自动取消 默认为false\")]),e._v(\" \"),n(\"p\",[e._v(\"可选\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"import 'package:flutter/material.dart';\\nimport 'package:flutter/services.dart';\\n\\nmain() {\\n  runApp(new MyApp());\\n}\\n\\nclass MyApp extends StatefulWidget{\\n  @override\\n  State<StatefulWidget> createState() {\\n    // TODO: implement createState\\n    return MyAppState();\\n  }\\n\\n}\\n\\nclass MyAppState extends State<MyApp> {\\n  static const eventChannel =\\n      const EventChannel('samples.flutter.io/event');\\n\\n  String textContent = 'Flutter Message';\\n\\n  @override\\n  void initState() {\\n    // TODO: implement initState\\n    super.initState();\\n    eventChannel.receiveBroadcastStream().listen(_onListen,onError: _onError,onDone: _onDone,cancelOnError: false);\\n  }\\n\\n  void _onListen(dynamic data){\\n    setState(() {\\n      textContent = data;\\n    });\\n  }\\n\\n  void _onError(){\\n    setState(() {\\n      textContent = 'EventChannel error';\\n    });\\n  }\\n\\n  void _onDone(){\\n    setState(() {\\n      textContent = 'EventChannel done';\\n    });\\n  }\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    // TODO: implement build\\n    return MaterialApp(\\n      title: \\\"Flutter Demo\\\",\\n      theme: ThemeData(\\n        primaryColor: Colors.blue,\\n      ),\\n      home: Scaffold(\\n        appBar: AppBar(\\n          title: Text('Platform Channel -- EventChannel'),\\n        ),\\n        body: Text(textContent),\\n      ),\\n    );\\n  }\\n}\\n\\n\")])])]),n(\"ul\",[n(\"li\",[e._v(\"如果运行正常，就会在 _onListen 收到正常数据的事件\")]),e._v(\" \"),n(\"li\",[e._v(\"如果运行出现 error ，就会在 _onError 收到错误的事件\")]),e._v(\" \"),n(\"li\",[e._v(\"如果运行结束，就会在 _onDone 收到结束监听的事件\")])]),e._v(\" \"),n(\"h3\",{attrs:{id:\"在-android-端发送数据-2\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在-android-端发送数据-2\"}},[e._v(\"#\")]),e._v(\" 在 Android 端发送数据\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('private EventChannel.EventSink mEventSink;\\n  @Override\\n  protected void onCreate(Bundle savedInstanceState) {\\n    super.onCreate(savedInstanceState);\\n    GeneratedPluginRegistrant.registerWith(this);\\n\\n\\n    new EventChannel(getFlutterView(),\"samples.flutter.io/event\").setStreamHandler(new EventChannel.StreamHandler() {\\n      @Override\\n      public void onListen(Object o, EventChannel.EventSink eventSink) {\\n        mEventSink = eventSink;\\n      }\\n\\n      @Override\\n      public void onCancel(Object o) {\\n        mEventSink = null;\\n      }\\n    });\\n\\n  }\\n\\n  @Override\\n  protected void onResume() {\\n    super.onResume();\\n    if(mEventSink != null){\\n      mEventSink.success(\"Android Message\");\\n    }\\n  }\\n\\n')])])]),n(\"p\",[e._v(\"Android 端首先是创建 EventChannel 实例，要保证 EventChannel 的 EventName 和 Flutter 的保持一致，同时实现 setStreamHandler() 方法，让 Android 和 Flutter 建立连接，而且要保存 onListen() 方法里传过来的 EventSink 对象，需要用 EventSink 对象来发送数据\")]),e._v(\" \"),n(\"p\",[e._v(\"发送数据的代码就是：\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[e._v(\"发送正常数据的事件\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('if(mEventSink != null){\\n    mEventSink.success(\"Android Message\");\\n}\\n\\n')])])])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"发送 error 事件\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('if(mEventSink != null){\\n  mEventSink.error(\"-1\",\"EventChannel fail\",\"content is null\");\\n}\\n\\n')])])])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"发送 结束监听的事件\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"if(mEventSink != null){\\n  mEventSink.endOfStream();\\n}\\n\\n\")])])])])]),e._v(\" \"),n(\"p\",[e._v(\"Android 的 MainActivity.java 的代码：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('package com.kk.flutter_app;\\n\\nimport android.os.Bundle;\\nimport io.flutter.app.FlutterActivity;\\nimport io.flutter.plugin.common.EventChannel;\\nimport io.flutter.plugins.GeneratedPluginRegistrant;\\n\\npublic class MainActivity extends FlutterActivity {\\n\\n  private EventChannel.EventSink mEventSink;\\n  @Override\\n  protected void onCreate(Bundle savedInstanceState) {\\n    super.onCreate(savedInstanceState);\\n    GeneratedPluginRegistrant.registerWith(this);\\n\\n\\n    new EventChannel(getFlutterView(),\"samples.flutter.io/event\").setStreamHandler(new EventChannel.StreamHandler() {\\n      @Override\\n      public void onListen(Object o, EventChannel.EventSink eventSink) {\\n        mEventSink = eventSink;\\n      }\\n\\n      @Override\\n      public void onCancel(Object o) {\\n        mEventSink = null;\\n      }\\n    });\\n\\n  }\\n\\n  @Override\\n  protected void onResume() {\\n    super.onResume();\\n    if(mEventSink != null){\\n      mEventSink.success(\"Android Message\");\\n    }\\n  }\\n}\\n\\n')])])]),n(\"p\",[e._v(\"刚运行 APP 的效果：\")]),e._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/4/9/16a003fb7c771a09?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\",alt:\"img\"}})]),e._v(\" \"),n(\"p\",[e._v(\"退后台，又切到前台的效果：\")]),e._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/4/9/16a003f51bee4eb6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\",alt:\"img\"}})]),e._v(\" \"),n(\"h2\",{attrs:{id:\"总结\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总结\"}},[e._v(\"#\")]),e._v(\" 总结\")]),e._v(\" \"),n(\"p\",[e._v(\"你会发现，MethodChannel 和 EventChannel 都可以实现 Flutter 与 Native 的双向通信，所以 MethodChannel 和 EventChannel 在使用过程中是可以互相替换的。\")]),e._v(\" \"),n(\"p\",[e._v(\"在官方文档里，更多的是对 MethodChannel 的介绍，EventChannel 的几乎没有，但你可以根据自己的需要和习惯来选择使用，因为 MethodChannel 和 EventChannel 的底层实现是一样的。\")])])}),[],!1,null,null,null);t.default=r.exports}}]);","extractedComments":[]}