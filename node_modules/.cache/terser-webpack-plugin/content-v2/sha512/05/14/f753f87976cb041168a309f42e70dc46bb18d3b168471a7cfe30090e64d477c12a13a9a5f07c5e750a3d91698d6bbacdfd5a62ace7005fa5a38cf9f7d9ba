{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[336],{690:function(n,a,t){\"use strict\";t.r(a);var e=t(42),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[t(\"blockquote\",[t(\"p\",[n._v(\"本节代码对应 GitHub 分支: chapter3\")])]),n._v(\" \"),t(\"p\",[t(\"a\",{attrs:{href:\"https://github.com/sanyuan0704/react-cloud-music/tree/chapter3\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"仓库传送门\"),t(\"OutboundLink\")],1)]),n._v(\" \"),t(\"h2\",{attrs:{id:\"图片懒加载\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#图片懒加载\"}},[n._v(\"#\")]),n._v(\" 图片懒加载\")]),n._v(\" \"),t(\"p\",[n._v(\"在大量图片加载的情况下，会造成页面空白甚至卡顿，然而我们的视口就这么大，因此只需要让视口内的图片显示即可，同时图片未显示的时候给它一个默认的 src，让一张非常精简的图片占位。这就是图片懒加载的原理。当然，在本项目中，我们采取一个成熟的方案 react-lazyload 库，易上手，效果不错。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"npm install react-lazyload --save\\n\\n\")])])]),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('//components/list.js\\n// 引入\\nimport LazyLoad from \"react-lazyload\";\\n\\n//img 标签外部包裹一层 LazyLoad\\n<LazyLoad placeholder={<img width=\"100%\" height=\"100%\" src={require (\\'./music.png\\')} alt=\"music\"/>}>\\n  <img src={item.picUrl + \"?param=300x300\"} width=\"100%\" height=\"100%\" alt=\"music\"/>\\n</LazyLoad>\\n\\n')])])]),t(\"p\",[n._v(\"至于默认的占位图片，大家可以去相应分支去拿。\")]),n._v(\" \"),t(\"p\",[n._v(\"现在我们做到了视口内的图片显示真实资源，视口外则显示占位图片，那么当我们滑动的时候，如何让下面相应的图片显示呢？\")]),n._v(\" \"),t(\"p\",[n._v(\"其实也相当简单，在 Recommend/index.js 中:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"// 引入 forceCheck 方法\\nimport { forceCheck } from 'react-lazyload';\\n\\n//scroll 组件中应用这个方法\\n<Scroll className=\\\"list\\\" onScroll={forceCheck}>\\n...\\n\\n\")])])]),t(\"p\",[n._v(\"这样随着页面滑动，下面的图片会依次显示，没有任何问题。\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"进场-loading-效果\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进场-loading-效果\"}},[n._v(\"#\")]),n._v(\" 进场 loading 效果\")]),n._v(\" \"),t(\"p\",[n._v(\"Ajax 请求往往需要一定的时间，在这个时间内，页面会处于没有数据的状态，也就是空白状态，但是用户点击来的时候看见一片空白的时候心里是非常焦灼的，尤其是 Ajax 的请求时间长达几秒的时候，而 loading 效果便能减缓这种焦急的情绪，并且如果 loading 动画做的漂亮，还能够让人赏心悦目，让用户对 App 产生好感。\")]),n._v(\" \"),t(\"p\",[n._v(\"loading 的重要性不言而喻。因此，我也是这花费了不少力气，折腾出了几个版本的 loading 效果。这里先来写第一版。\")]),n._v(\" \"),t(\"p\",[n._v(\"主要是利用了 CSS3 的 animation-delay 特性，让两个圆交错变化，产生一个涟漪的效果。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"import React from 'react';\\nimport styled, { keyframes } from'styled-components';\\nimport style from '../../assets/global-style';\\n\\nconst loading = keyframes`\\n  0%, 100% {\\n    transform: scale(0.0);\\n  }\\n  50% {\\n    transform: scale(1.0);\\n  }\\n`\\nconst LoadingWrapper = styled.div`\\n  >div {\\n    position: fixed;\\n    z-index: 1000;\\n    left: 0; \\n    right: 0;  \\n    top: 0;\\n    bottom: 0;\\n    margin: auto;\\n    width: 60px;\\n    height: 60px;\\n    opacity: 0.6;\\n    border-radius: 50%;\\n    background-color: ${style [\\\"theme-color\\\"]};\\n    animation: ${loading} 1.4s infinite ease-in;\\n  }\\n  >div:nth-child (2) {\\n    animation-delay: -0.7s;\\n  }\\n`\\n\\nfunction Loading ()  {\\n  return (\\n    <LoadingWrapper>\\n      <div></div>\\n      <div></div>\\n    </LoadingWrapper>\\n  );\\n}\\n \\nexport default React.memo (Loading);\\n\\n\")])])]),t(\"p\",[n._v(\"现在在 Recommend 组件中引入\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"import Loading from '../../baseUI/loading/index';\\n\\n// 在返回的 JSX 代码中\\n<Content>\\n  ...\\n  <Loading></Loading>\\n<Content>\\n\\n\")])])]),t(\"p\",[n._v(\"现在你可以看到屏幕中间的 loading。接下来添加 Loading 的控制逻辑。\")]),n._v(\" \"),t(\"p\",[n._v(\"由于数据是异步获取，异步逻辑全在 redux-thunk 中执行，且 loading 和数据之间是一个联动的关系，因此 loading 的状态应放在 redux 管理。\")]),n._v(\" \"),t(\"ol\",[t(\"li\",[n._v(\"首先，在 Recommend/store 下的 reducer.js 中:\")])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//reducer.js\\nconst defaultState = fromJS ({\\n  ...\\n  enterLoading: true\\n});\\n\\n\")])])]),t(\"ol\",{attrs:{start:\"2\"}},[t(\"li\",[n._v(\"添加 action 的 type 值常量\")])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//constants.js\\n...\\nexport const CHANGE_ENTER_LOADING = 'recommend/CHANGE_ENTER_LOADING';\\n\\n\")])])]),t(\"ol\",{attrs:{start:\"3\"}},[t(\"li\",[n._v(\"添加 reducer 的逻辑:\")])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"export default (state = defaultState, action) => {\\n  switch (action.type) {\\n    ...\\n    case actionTypes.CHANGE_ENTER_LOADING:\\n      return state.set ('enterLoading', action.data);\\n    default:\\n      return state;\\n  }\\n}\\n\\n\")])])]),t(\"ol\",{attrs:{start:\"4\"}},[t(\"li\",[n._v(\"然后编写 action：\")])]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('//actionCreators.js\\n...\\nexport const changeEnterLoading = (data) => ({\\n  type: actionTypes.CHANGE_ENTER_LOADING,\\n  data\\n});\\n// 另外在获取推荐歌单后，应把 loading 状态改为 false\\nexport const getRecommendList = () => {\\n  return (dispatch) => {\\n    getRecommendListRequest ().then (data => {\\n      dispatch (changeRecommendList (data.result));\\n      dispatch (changeEnterLoading (false));// 改变 loading\\n    }).catch (() => {\\n      console.log (\"推荐歌单数据传输错误\");\\n    });\\n  }\\n};\\n\\n')])])]),t(\"p\",[n._v(\"接下来在组件中应用这个 enterLoading:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//recommend/index.js\\nconst mapStateToProps = (state) => ({\\n  ...\\n  enterLoading: state.getIn (['recommend', 'enterLoading'])\\n});\\n// 返回的 JSX 代码中应用它\\n<Content>\\n  ...\\n  { enterLoading ? <Loading></Loading> : null }\\n<Content>\\n\\n\")])])]),t(\"p\",[n._v(\"这样 Loading 效果就正常显示啦！\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"redux-数据缓存\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redux-数据缓存\"}},[n._v(\"#\")]),n._v(\" Redux 数据缓存\")]),n._v(\" \"),t(\"p\",[n._v(\"问题：其实还有一个细节需要我们来优化，就是你现在切换到歌手页面，然后切回到推荐页，你在浏览器的 Network 中会看到又发了两次网络请求，而这两次请求是完全没有必要的，纯属浪费性能。\")]),n._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/10/18/16dddf168d7a60bc?w=909&h=168&f=jpeg&s=29010\",alt:\"\"}})]),n._v(\" \"),t(\"p\",[n._v(\"那如何来优化呢？根据我们这个项目的特点，利用 Redux 的数据来进行页面缓存成本最低，是不二之选。\")]),n._v(\" \"),t(\"p\",[n._v(\"其实操作起来也是非常简单的，只需要做一些小小的改动：\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//Recommend/index.js\\nuseEffect (() => {\\n  // 如果页面有数据，则不发请求\\n  //immutable 数据结构中长度属性 size\\n  if (!bannerList.size){\\n    getBannerDataDispatch ();\\n  }\\n  if (!recommendList.size){\\n    getRecommendListDataDispatch ();\\n  }\\n}, []);\\n\\n\")])])]),t(\"p\",[n._v(\"这下，我切换到歌手页，再切回来，果然就不会多发请求啦！\")]),n._v(\" \"),t(\"p\",[n._v(\"恭喜你，现在已经完成了推荐模块的内容，是不是相当有成就感呢？后面还有更多有挑战的事情等着你呢，加油！\")])])}),[],!1,null,null,null);a.default=s.exports}}]);","extractedComments":[]}