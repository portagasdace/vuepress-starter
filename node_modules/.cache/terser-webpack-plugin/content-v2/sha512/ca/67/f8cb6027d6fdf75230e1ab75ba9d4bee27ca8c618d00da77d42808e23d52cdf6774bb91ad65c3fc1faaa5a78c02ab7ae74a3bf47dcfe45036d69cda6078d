{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[305],{661:function(n,l,a){\"use strict\";a.r(l);var e=a(42),t=Object(e.a)({},(function(){var n=this,l=n.$createElement,a=n._self._c||l;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[a(\"blockquote\",[a(\"p\",[n._v(\"本节代码对应 GitHub 分支: chapter4\")])]),n._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://github.com/sanyuan0704/react-cloud-music/tree/chapter4\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"仓库传送门\"),a(\"OutboundLink\")],1)]),n._v(\" \"),a(\"h2\",{attrs:{id:\"上拉-下拉加载更多实现\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#上拉-下拉加载更多实现\"}},[n._v(\"#\")]),n._v(\" 上拉 / 下拉加载更多实现\")]),n._v(\" \"),a(\"p\",[n._v(\"在这里 Scroll 基础组件的作用就展现出来了。之前我们封装了 Scroll 组件，监听上拉 / 下拉刷新的功能已编写完成，但是相应的 loading 效果并没有考虑。现在，我们就来先完善 loading 效果。\")]),n._v(\" \"),a(\"p\",[n._v(\"首先引入 loading 组件：\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"import Loading from '../loading/index';\\n\\n\")])])]),a(\"p\",[n._v(\"将 return 部分的代码修改为:\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v('const PullUpdisplayStyle = pullUpLoading ? {display: \"\"} : { display:\"none\" };\\nconst PullDowndisplayStyle = pullDownLoading ? { display: \"\"} : { display:\"none\" };\\nreturn (\\n  <ScrollContainer ref={scrollContaninerRef}>\\n    {props.children}\\n    {/* 滑到底部加载动画 */}\\n    <PullUpLoading style={ PullUpdisplayStyle }><Loading></Loading></PullUpLoading>\\n    {/* 顶部下拉刷新动画 */}\\n    <PullDownLoading style={ PullDowndisplayStyle }><LoadingV2></LoadingV2></PullDownLoading>\\n  </ScrollContainer>\\n);\\n\\n')])])]),a(\"p\",[n._v(\"注意 PullUpdisplayStyle 和 PullDowndisplayStyle 都是外部传入的，这就方便了我们控制 loading 的显示和隐藏。\")]),n._v(\" \"),a(\"p\",[n._v(\"其中 Loading 组件即之前编写的两圆交错的涟漪效果组件，但 LoadingV2 并没有编写，现在就花一点时间来开发第二个 Loading 效果。\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"//baseUI/loading-v2/index.js\\nimport React from 'react';\\nimport styled, {keyframes} from'styled-components';\\nimport style from '../../assets/global-style'\\n\\nconst dance = keyframes`\\n    0%, 40%, 100%{\\n      transform: scaleY (0.4);\\n      transform-origin: center 100%;\\n    }\\n    20%{\\n      transform: scaleY (1);\\n    }\\n`\\nconst Loading = styled.div`\\n    height: 10px;\\n    width: 100%;\\n    margin: auto;\\n    text-align: center;\\n    font-size: 10px;\\n    >div {\\n      display: inline-block;\\n      background-color: ${style [\\\"theme-color\\\"]};\\n      height: 100%;\\n      width: 1px;\\n      margin-right:2px;\\n      animation: ${dance} 1s infinite;\\n    }\\n    >div:nth-child (2) {\\n      animation-delay: -0.4s;\\n    }\\n    >div:nth-child (3) {\\n      animation-delay: -0.6s;\\n    }\\n    >div:nth-child (4) {\\n      animation-delay: -0.5s;\\n    }\\n    >div:nth-child (5) {\\n      animation-delay: -0.2s;\\n    } \\n\\n`\\n\\nfunction LoadingV2 () {\\n  return (\\n    <Loading>\\n      <div></div>\\n      <div></div>\\n      <div></div>\\n      <div></div>\\n      <div></div>\\n      <span > 拼命加载中...</span>\\n    </Loading>\\n  );\\n}\\n \\nexport default React.memo (LoadingV2);\\n\\n\")])])]),a(\"p\",[n._v(\"OK, 现在在 scroll 组件中引入。\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"//scroll/index.js\\nimport Loading2 from '../loading-v2/index';\\n\\n\")])])]),a(\"p\",[n._v(\"接下来，我们在 Singers/index.js 中，传入相应的参数即可。\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"<Scroll\\n  pullUp={ handlePullUp }\\n  pullDown = { handlePullDown }\\n  pullUpLoading = { pullUpLoading }\\n  pullDownLoading = { pullDownLoading }\\n>\\n  { renderSingerList () }\\n</Scroll>\\n\\n\")])])]),a(\"p\",[n._v(\"现在 handlePullUp 和 handlePullDown 两个方法还没有定义，添加如下:\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"const handlePullUp = () => {\\n  pullUpRefreshDispatch (category, alpha, category === '', pageCount);\\n};\\n\\nconst handlePullDown = () => {\\n  pullDownRefreshDispatch (category, alpha);\\n};\\n\\n\")])])]),a(\"p\",[n._v(\"现在试一试上拉下拉，相应的 loading 动画能够出现了，同时数据也能正常加载。 对了，现在进场的 loading 效果还没有实现，我们在 Singers/index.js 中加入:\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"import Loading from '../../baseUI/loading';\\n//...\\n//ListContainer 标签中\\n<Loading show={enterLoading}></Loading>\\n\\n\")])])]),a(\"p\",[n._v(\"这样，当你第一次打开列表页或者切换不同分类的时候，会有 loading 效果出现，和我们的预期一致。\")]),n._v(\" \"),a(\"h2\",{attrs:{id:\"相关优化\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#相关优化\"}},[n._v(\"#\")]),n._v(\" 相关优化\")]),n._v(\" \"),a(\"h3\",{attrs:{id:\"图片懒加载\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#图片懒加载\"}},[n._v(\"#\")]),n._v(\" 图片懒加载\")]),n._v(\" \"),a(\"p\",[n._v(\"同样是引入 react-lazyload, 在 Singers/index.js 作如下修改:\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v('// 首先引入\\nimport  LazyLoad, {forceCheck} from \\'react-lazyload\\';\\n\\n// 包裹 img 标签\\n<LazyLoad placeholder={<img width=\"100%\" height=\"100%\" src={require (\\'./singer.png\\')} alt=\"music\"/>}>\\n  <img src={`${item.picUrl}?param=300x300`} width=\"100%\" height=\"100%\" alt=\"music\"/>\\n</LazyLoad>\\n\\n<Scroll\\n  //...\\n  onScroll={forceCheck}\\n>\\n</Scroll>\\n\\n')])])]),a(\"p\",[n._v(\"现在懒加载的效果就完成了。\")]),n._v(\" \"),a(\"h3\",{attrs:{id:\"防抖处理\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#防抖处理\"}},[n._v(\"#\")]),n._v(\" 防抖处理\")]),n._v(\" \"),a(\"p\",[n._v(\"当你频繁地下拉时，事实上事件回调函数也会被频繁触发，导致发送很多无意义的请求。因此这里对 Scroll 基础组件做一下防抖处理。\")]),n._v(\" \"),a(\"p\",[n._v(\"防抖函数写在 api/utils.js 中，\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"\\n// 防抖函数\\nexport const debounce = (func, delay) => {\\n  let timer;\\n  return function (...args) {\\n    if (timer) {\\n      clearTimeout (timer);\\n    }\\n    timer = setTimeout (() => {\\n      func.apply (this, args);\\n      clearTimeout (timer);\\n    }, delay);\\n  }\\n}\\n\\n\")])])]),a(\"p\",[n._v(\"然后在 scroll/index.js 中:\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"import { debounce } from \\\"../../api/utils\\\";\\n\\n//...\\n\\nlet pullUpDebounce = useMemo (() => {\\n  return debounce (pullUp, 300)\\n}, [pullUp]);\\n// 千万注意，这里不能省略依赖，\\n// 不然拿到的始终是第一次 pullUp 函数的引用，相应的闭包作用域变量都是第一次的，产生闭包陷阱。下同。\\n\\nlet pullDownDebounce = useMemo (() => {\\n  return debounce (pullDown, 300)\\n}, [pullDown]);\\n//...\\n// 之后直接调用 useMemo 返回的函数\\n// 滑动到底部\\nuseEffect(() => {\\n    if(!bScroll || !pullUp) return;\\n    const handlePullUp = () => {\\n      //判断是否滑动到了底部\\n      if(bScroll.y <= bScroll.maxScrollY + 100){\\n        pullUpDebounce();\\n      }\\n    };\\n    bScroll.on('scrollEnd', handlePullUp);\\n    // 解绑\\n    return () => {\\n      bScroll.off('scrollEnd', handlePullUp);\\n    }\\n}, [pullUp, pullUpDebounce, bScroll]);\\n\\n// 判断用户的下拉动作\\nuseEffect(() => {\\n    if(!bScroll || !pullDown) return;\\n    const handlePullDown = (pos) => {\\n      //判断用户的下拉动作\\n      if(pos.y > 50) {\\n        pullDownDebounce();\\n      }\\n    };\\n    bScroll.on('touchEnd', handlePullDown);\\n    return () => {\\n      bScroll.off('touchEnd', handlePullDown);\\n    }\\n}, [pullDown, pullDownDebounce, bScroll]);\\n\\n\")])])]),a(\"p\",[n._v(\"这样当你频繁上拉下拉的时候就不会频繁触发回调了。\")]),n._v(\" \"),a(\"blockquote\",[a(\"p\",[n._v(\"思考题：当我们切换组件的时候，事实上现在的 category 和 alpha 会丢失，如果想要切换组件后仍然能够缓存 category 和 alpha 的值应该怎么做？可以自己动手试试看。\")])])])}),[],!1,null,null,null);l.default=t.exports}}]);","extractedComments":[]}