{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[318],{671:function(e,r,s){\"use strict\";s.r(r);var t=s(42),n=Object(t.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[s(\"blockquote\",[s(\"p\",[e._v(\"本节代码对应 GitHub 分支: chapter8\")])]),e._v(\" \"),s(\"p\",[s(\"a\",{attrs:{href:\"https://github.com/sanyuan0704/react-cloud-music/tree/chapter8\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"仓库传送门\"),s(\"OutboundLink\")],1)]),e._v(\" \"),s(\"p\",[e._v(\"进度条组件是播放器中至关重要的组件，我们单独抽出来讲。\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"环形进度条组件\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#环形进度条组件\"}},[e._v(\"#\")]),e._v(\" 环形进度条组件\")]),e._v(\" \"),s(\"p\",[e._v(\"环形主要用于迷你播放器上，简单地运用 svg 来进行实现。\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('//baseUI/progress-circle.js\\nimport React from \\'react\\';\\nimport styled from\\'styled-components\\';\\nimport style from \\'../../assets/global-style\\';\\n\\nconst CircleWrapper = styled.div`\\n  position: relative;\\n  circle {\\n    stroke-width: 8px;\\n    transform-origin: center;\\n    &.progress-background {\\n      transform: scale (0.9);\\n      stroke: ${style [\"theme-color-shadow\"]};\\n    }\\n    &.progress-bar {\\n      transform: scale (0.9) rotate (-90deg);\\n      stroke: ${style [\"theme-color\"]};\\n    }\\n  }\\n`\\n\\nfunction ProgressCircle (props) {\\n  const {radius, percent} = props;\\n  // 整个背景的周长\\n  const dashArray = Math.PI * 100;\\n  // 没有高亮的部分，剩下高亮的就是进度\\n  const dashOffset = (1 - percent) * dashArray;\\n\\n  return (\\n    <CircleWrapper>\\n      <svg width={radius} height={radius} viewBox=\"0 0 100 100\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\\n        <circle className=\"progress-background\" r=\"50\" cx=\"50\" cy=\"50\" fill=\"transparent\"/>\\n        <circle className=\"progress-bar\" r=\"50\" cx=\"50\" cy=\"50\" fill=\"transparent\" \\n                strokeDasharray={dashArray}\\n                strokeDashoffset={dashOffset}/>\\n      </svg>\\n      {props.children}\\n    </CircleWrapper>\\n  )\\n}\\n\\nexport default React.memo (ProgressCircle);\\n\\n')])])]),s(\"p\",[e._v(\"现在来把它应用到 mini 播放器中:\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('// 先 mock 一份 percent 数据\\nlet percent = 0.2;\\n\\n// 将原来的暂停按钮部分修改\\n<div className=\"control\">\\n  <ProgressCircle radius={32} percent={percent}>\\n    <i className=\"icon-mini iconfont icon-pause\">&#xe650;</i>\\n  </ProgressCircle>\\n</div>\\n\\n')])])]),s(\"p\",[e._v(\"现在 20% 的效果就出现了。\")]),e._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/10/26/16e07f7d1d504e62?w=377&h=52&f=jpeg&s=4476\",alt:\"\"}})]),e._v(\" \"),s(\"h2\",{attrs:{id:\"线形进度条组件\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线形进度条组件\"}},[e._v(\"#\")]),e._v(\" 线形进度条组件\")]),e._v(\" \"),s(\"p\",[e._v(\"现在我们来构建 normalPlayer 中的线性进度条，相信这也是大家会比较常用的一个组件。大家可能在平时的开发中，直接用的 UI 框架来完成，但你懂得背后是如何实现的吗？ 现在就趁这个机会来试一试吧。\")]),e._v(\" \"),s(\"p\",[e._v(\"由于涉及到比较复杂的交互，我们这里做重点来讲解。\")]),e._v(\" \"),s(\"h3\",{attrs:{id:\"ui-构建\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ui-构建\"}},[e._v(\"#\")]),e._v(\" UI 构建\")]),e._v(\" \"),s(\"p\",[e._v(\"首先构建 UI:\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('//baseUI/progressBar/index.js\\nimport React, {useEffect, useRef, useState } from \\'react\\';\\nimport styled from\\'styled-components\\';\\nimport style from \\'../../assets/global-style\\';\\nimport { prefixStyle } from \\'./../../api/utils\\';\\n\\nconst ProgressBarWrapper = styled.div`\\n  height: 30px;\\n  .bar-inner {\\n    position: relative;\\n    top: 13px;\\n    height: 4px;\\n    background: rgba (0, 0, 0, .3);\\n    .progress {\\n      position: absolute;\\n      height: 100%;\\n      background: ${style [\"theme-color\"]};\\n    }\\n    .progress-btn-wrapper {\\n      position: absolute;\\n      left: -15px;\\n      top: -13px;\\n      width: 30px;\\n      height: 30px;\\n      .progress-btn {\\n        position: relative;\\n        top: 7px;\\n        left: 7px;\\n        box-sizing: border-box;\\n        width: 16px;\\n        height: 16px;\\n        border: 3px solid ${style [\"border-color\"]};\\n        border-radius: 50%;\\n        background: ${style [\"theme-color\"]};\\n      }\\n    }\\n  }\\n`\\n\\nfunction ProgressBar (props) {\\n  return (\\n    <ProgressBarWrapper>\\n      <div className=\"bar-inner\">\\n        <div className=\"progress\"></div>\\n        <div className=\"progress-btn-wrapper\">\\n          <div className=\"progress-btn\"></div>\\n        </div>\\n      </div>\\n    </ProgressBarWrapper>\\n  )\\n}\\n\\n')])])]),s(\"p\",[e._v(\"为了能及时看到效果，我们在 normalPlayer 中来引入这个组件。\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('import ProgressBar from \"../../../baseUI/progress-bar/index\";\\n\\n<ProgressWrapper>\\n  <span className=\"time time-l\">0:00</span>\\n  <div className=\"progress-bar-wrapper\">\\n    <ProgressBar percent={0.2}></ProgressBar>\\n  </div>\\n  <div className=\"time time-r\">4:17</div>\\n</ProgressWrapper>\\n\\n')])])]),s(\"p\",[e._v(\"ProgressWrapper 样式组件已经实现，现在只需从 style.js 引入即可。\")]),e._v(\" \"),s(\"p\",[e._v(\"现在，就可以看到基本的进度条的样子了。\")]),e._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/10/26/16e07f7fe62849f4?w=393&h=111&f=jpeg&s=5415\",alt:\"\"}})]),e._v(\" \"),s(\"h2\",{attrs:{id:\"进度条交互逻辑开发\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进度条交互逻辑开发\"}},[e._v(\"#\")]),e._v(\" 进度条交互逻辑开发\")]),e._v(\" \"),s(\"p\",[e._v(\"首先，进度条组件作为播放器的一部分，我们思考一下将它被拆分出去后的功能，一方面是要响应用户的拖动或点击动作，让进度条得以长度变化，另一方面是要执行播放器组件传递过来的进度改变时需要的回调。\")]),e._v(\" \"),s(\"p\",[e._v(\"好，我们先完成第一步。\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('// 即将使用的 hooks\\nimport React, {useEffect, useRef, useState } from \\'react\\';\\n\\nconst progressBar = useRef ();\\nconst progress = useRef ();\\nconst progressBtn = useRef ();\\nconst [touch, setTouch] = useState ({});\\n\\nconst progressBtnWidth = 16;  \\n\\n//JSX 部分\\n<ProgressBarWrapper>\\n  <div className=\"bar-inner\" ref={progressBar} >\\n    <div className=\"progress\" ref={progress}></div>\\n    <div className=\"progress-btn-wrapper\" ref={progressBtn}\\n        onTouchStart={progressTouchStart}\\n        onTouchMove={progressTouchMove}\\n        onTouchEnd={progressTouchEnd}\\n    >\\n      <div className=\"progress-btn\"></div>\\n    </div>\\n  </div>\\n</ProgressBarWrapper>\\n\\n')])])]),s(\"p\",[e._v(\"现在来处理滑动事件的逻辑:\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"// 处理进度条的偏移\\nconst _offset = (offsetWidth) => {\\n  progress.current.style.width = `${offsetWidth} px`;\\n  progressBtn.current.style.transform = `translate3d (${offsetWidth} px, 0, 0)`;\\n}\\n\\nconst progressTouchStart = (e) => {\\n  const startTouch = {};\\n  startTouch.initiated = true;//initial 为 true 表示滑动动作开始了\\n  startTouch.startX = e.touches [0].pageX;// 滑动开始时横向坐标\\n  startTouch.left = progress.current.clientWidth;// 当前 progress 长度\\n  setTouch (startTouch);\\n}\\n\\nconst progressTouchMove = (e) => {\\n  if (!touch.initiated) return;\\n  // 滑动距离   \\n  const deltaX = e.touches [0].pageX - touch.startX;\\n  const barWidth = progressBar.current.clientWidth - progressBtnWidth; \\n  const offsetWidth = Math.min (Math.max (0, touch.left + deltaX), barWidth);\\n  _offset (offsetWidth);\\n}\\n\\nconst progressTouchEnd = (e) => {\\n  const endTouch = JSON.parse (JSON.stringify (touch));\\n  endTouch.initiated = false;\\n  setTouch (endTouch);\\n}\\n\\n\")])])]),s(\"p\",[e._v(\"现在进度条就可以自由地拖动啦！\")]),e._v(\" \"),s(\"p\",[e._v(\"不过还有一种情况，就是用户点击进度条的时候，进度条也应该做相应的改变。\")]),e._v(\" \"),s(\"p\",[e._v(\"其实很简单，绑定点击事件即可。\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v('<div className=\"bar-inner\" ref={progressBar} onClick={progressClick}>\\n\\n')])])]),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"const progressClick = (e) => {\\n  const rect = progressBar.current.getBoundingClientRect ();\\n  const offsetWidth = e.pageX - rect.left;\\n  _offset (offsetWidth);\\n};\\n\\n\")])])]),s(\"p\",[s(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/10/26/16e07f85d22ce04d?w=372&h=40&f=gif&s=87971\",alt:\"\"}})]),e._v(\" \"),s(\"p\",[e._v(\"现在我们就完成了第一步啦，接下来当进度改变后，我们需要执行父组件传过来的回调函数。\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"// 取出回调函数\\nconst {percentChange} = props;\\n\\nconst _changePercent = () => {\\n  const barWidth = progressBar.current.clientWidth - progressBtnWidth;\\n  const curPercent = progress.current.clientWidth/barWidth;// 新的进度计算\\n  percentChange (curPercent);// 把新的进度传给回调函数并执行\\n}\\n\\n// 滑动完成时  \\nconst progressTouchEnd = (e) => {\\n  //...\\n  _changePercent ();\\n}\\n// 点击后\\nconst progressClick = (e) => {\\n  //...\\n  _changePercent ();\\n}\\n\\n\")])])]),s(\"p\",[e._v(\"由于 percentChange 的具体逻辑在父组件完成，与目前组件无关 至此，进度条组件就开发完成了。\")])])}),[],!1,null,null,null);r.default=n.exports}}]);","extractedComments":[]}