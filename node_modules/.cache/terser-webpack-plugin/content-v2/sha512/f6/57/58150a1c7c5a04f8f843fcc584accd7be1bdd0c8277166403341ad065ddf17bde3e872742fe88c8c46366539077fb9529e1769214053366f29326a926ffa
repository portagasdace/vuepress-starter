{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[321],{679:function(t,n,e){\"use strict\";e.r(n);var r=e(42),s=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[e(\"blockquote\",[e(\"p\",[t._v(\"本节代码对应 GitHub 分支: chapter9\")])]),t._v(\" \"),e(\"p\",[e(\"a\",{attrs:{href:\"https://github.com/sanyuan0704/react-cloud-music/tree/chapter9\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"仓库传送门\"),e(\"OutboundLink\")],1)]),t._v(\" \"),e(\"h2\",{attrs:{id:\"_1-出现-mini-播放器时页面底部被遮挡\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-出现-mini-播放器时页面底部被遮挡\"}},[t._v(\"#\")]),t._v(\" 1. 出现 mini 播放器时页面底部被遮挡\")]),t._v(\" \"),e(\"p\",[t._v(\"问题如图:\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/10/26/16e0802235fe5aa9?w=368&h=173&f=gif&s=1218092\",alt:\"\"}})]),t._v(\" \"),e(\"p\",[t._v(\"当 mini 播放器不出现的时候，还能够正常看到底部，但一出现，最下面就被遮住了，每个页都是如此。为什么？因为之前布局都是用 bottom: 0，但是在 mini 播放器出现后我们需要 改变这个 bottom 值，miniPlayer 高度为 60px，我们把 bottom 设为 60px，等于把下面的 60px 高度留给播放器。\")]),t._v(\" \"),e(\"p\",[t._v(\"因此对于每个页面 Container 的 bottom 值有无播放器需要分开处理。那怎么判断有无播放器出现呢？\")]),t._v(\" \"),e(\"p\",[t._v(\"有一个很简单的方式，就是判断当前 playList 的长度，如果大于 0 则正在播放，等于 0 则没有。\")]),t._v(\" \"),e(\"p\",[t._v(\"以 Recommend 组件为例:\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"function Recommend (props){\\n  const { songsCount } = props;\\n  //...\\n\\n  <Content play={songsCount}>\\n  //...\\n}\\n\\nconst mapStateToProps = (state) => ({\\n  //...\\n  songsCount: state.getIn (['player', 'playList']).size,// 尽量减少 toJS 操作，直接取 size 属性就代表了 list 的长度\\n});\\n//...\\n\\n\")])])]),e(\"p\",[t._v(\"相应 style.js 中:\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"import styled from'styled-components';\\n\\nexport const Content = styled.div`\\n  position: fixed;\\n  top: 90px;\\n  bottom: ${props => props.play > 0?\\\"60px\\\": 0};\\n  width: 100%;\\n`\\n\\n\")])])]),e(\"p\",[t._v(\"然后在 Singer、Singers、Rank、Album 组件中也是相同的操作，这里就不浪费篇幅了。大家可以自行完成，也可以参考 chapter8 分支的代码。\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"_2-频繁切歌导致的异常\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-频繁切歌导致的异常\"}},[t._v(\"#\")]),t._v(\" 2. 频繁切歌导致的异常\")]),t._v(\" \"),e(\"p\",[t._v(\"如果频繁切换歌曲，会出现这样的异常：\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/10/26/16e08025e9568397?w=317&h=19&f=jpeg&s=3832\",alt:\"\"}})]),t._v(\" \"),e(\"p\",[t._v(\"操作过快直接报错，这是完全无法接受的。所以我们必须究根溯源，把这个问题给解了。\")]),t._v(\" \"),e(\"p\",[t._v(\"解决的原理：其实从 audio 标签拿到 src 加载到能够播放之间有一个缓冲的过程，只有当控件能够播放时才能够切到下一首。如果在这个缓冲过程中切歌就会报错。\")]),t._v(\" \"),e(\"p\",[t._v(\"现在就来具体地来解决这个问题:\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"//Player/index.js\\nconst songReady = useRef (true);\\n\\nuseEffect (() => {\\n  if (\\n    !playList.length ||\\n    currentIndex === -1 ||\\n    !playList [currentIndex] ||\\n    playList [currentIndex].id === preSong.id ||\\n    !songReady.current// 标志位为 false\\n  )\\n    return;\\n  let current = playList [currentIndex];\\n  setPreSong (current);\\n  songReady.current = false; // 把标志位置为 false, 表示现在新的资源没有缓冲完成，不能切歌\\n  changeCurrentDispatch (current);// 赋值 currentSong\\n  audioRef.current.src = getSongUrl (current.id);\\n  setTimeout (() => {\\n    // 注意，play 方法返回的是一个 promise 对象\\n    audioRef.current.play ().then (() => {\\n      songReady.current = true;\\n    });\\n  });\\n  togglePlayingDispatch (true);// 播放状态\\n  setCurrentTime (0);// 从头开始播放\\n  setDuration ((current.dt/ 1000) | 0);// 时长\\n}, [playList, currentIndex]);\\n\\n\")])])]),e(\"p\",[t._v(\"同时再做一下异常处理:\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v('const handleError = () => {\\n  songReady.current = true;\\n  alert (\"播放出错\");\\n};\\n\\n<audio\\n  //...\\n  onError={handleError}\\n></audio>\\n\\n')])])]),e(\"p\",[t._v(\"这样就能放心切歌，不会有报错啦！\")])])}),[],!1,null,null,null);n.default=s.exports}}]);","extractedComments":[]}