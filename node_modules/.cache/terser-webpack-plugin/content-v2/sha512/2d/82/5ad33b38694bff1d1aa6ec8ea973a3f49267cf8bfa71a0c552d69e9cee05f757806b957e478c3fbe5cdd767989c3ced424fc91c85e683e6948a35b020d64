{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[350],{709:function(v,_,e){\"use strict\";e.r(_);var t=e(42),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[e(\"h2\",{attrs:{id:\"导读\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#导读\"}},[v._v(\"#\")]),v._v(\" 导读\")]),v._v(\" \"),e(\"p\",[v._v(\"本节标题：「武装思想」- React SSR 根本原理\")]),v._v(\" \"),e(\"p\",[v._v(\"本节主旨：全面分析 react ssr 技术的本质，并对对虚拟 dom、同构应用具体流程、双端对比机制进行说明。\")]),v._v(\" \"),e(\"h1\",{attrs:{id:\"武装思想\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#武装思想\"}},[v._v(\"#\")]),v._v(\" 武装思想\")]),v._v(\" \"),e(\"p\",[v._v(\"在动手搭建应用骨架前我们要先了解下\"),e(\"code\",[v._v(\"react ssr\")]),v._v(\" 最根本的原理，这是整个技术架构实现的基础，也可以说是基石，可以理解为我们盖房子的地基。\")]),v._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/31/16ff99e599e198b0?w=1514&h=1038&f=png&s=270995\",alt:\"\"}})]),v._v(\" \"),e(\"p\",[v._v(\"如果你对一些多技术感觉到陌生或者看过很多次仍然会忘记时，主要原因要么是用的少，要么就是不理解其中的原理，导致印象不够深刻。\")]),v._v(\" \"),e(\"p\",[v._v(\"深入理解原理对于我们的开发和创新（自己造轮子）有很大的帮助，原理可以一步一步的带你走正确的路。\")]),v._v(\" \"),e(\"p\",[v._v(\"或许你之前觉得\"),e(\"code\",[v._v(\"react ssr\")]),v._v(\" 这个技术很高大上，学起来没有头绪，无从下手。\")]),v._v(\" \"),e(\"p\",[v._v(\"在我看来 \"),e(\"code\",[v._v(\"react ssr\")]),v._v(\"实现起来并不复杂，这个突破口就是从原理出发，一点一点的进行分析，然后通过代码校验你的分析。\")]),v._v(\" \"),e(\"p\",[e(\"code\",[v._v(\"react ssr\")]),v._v(\" 原理很容易理解，但是仅仅理解这点还不够足以搭建应用骨架，其中最有难度的内容应该是同构。\")]),v._v(\" \"),e(\"p\",[v._v(\"那么什么是同构？如何实现同构应用呢？\")]),v._v(\" \"),e(\"p\",[v._v(\"下面请听我慢慢叨叨。我叨叨的同时也会引出问题，希望大家能在看的同时也一起思考起来。\")]),v._v(\" \"),e(\"p\",[v._v(\"我们上一节说过，传统的\"),e(\"code\",[v._v(\"ssr\")]),v._v(\"和目前流行的\"),e(\"code\",[v._v(\"csr\")]),v._v(\"方案\"),e(\"code\",[v._v(\"spa\")]),v._v(\"都不够完美，所以我们需要能综合这两者优点的技术 - \"),e(\"code\",[v._v(\"react ssr (SPA+SSR)\")]),v._v(\"。\")]),v._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/26/16fdda177db75d3f?w=1534&h=726&f=png&s=121346\",alt:\"\"}})]),v._v(\" \"),e(\"p\",[v._v(\"每次刷新页面的时候数据是从服务端直出，然后后续的访问就是 \"),e(\"code\",[v._v(\"spa\")]),v._v(\" 的体验，即能解决\"),e(\"code\",[v._v(\"SEO\")]),v._v(\"问题，也能保持页面切换的效率，服务器的压力要比传统的\"),e(\"code\",[v._v(\"ssr\")]),v._v(\"也相对小。\")]),v._v(\" \"),e(\"p\",[v._v(\"我们现在既然已经知道了该技术的作用和意义，那么接下来就该分析下它的原理了。\")]),v._v(\" \"),e(\"p\",[v._v(\"为什么\"),e(\"code\",[v._v(\"react\")]),v._v(\"能够实现 \"),e(\"code\",[v._v(\"SPA+SSR\")]),v._v(\" 这种体验呢 ?\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"虚拟-dom\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#虚拟-dom\"}},[v._v(\"#\")]),v._v(\" 虚拟 dom\")]),v._v(\" \"),e(\"p\",[v._v(\"使用\"),e(\"code\",[v._v(\"react ssr\")]),v._v(\"技术开发出的最终产物其实就是\"),e(\"code\",[v._v(\"SPA+SSR\")]),v._v(\"的结合。\")]),v._v(\" \"),e(\"p\",[v._v(\"其中的\"),e(\"code\",[v._v(\"SSR\")]),v._v(\"指的是在服务端渲染组件。\")]),v._v(\" \"),e(\"p\",[v._v(\"而组件可以在服务端渲染的根本原因就是\"),e(\"code\",[v._v(\"虚拟 DOM\")]),v._v(\"。\")]),v._v(\" \"),e(\"p\",[v._v(\"平时我们都习惯使用\"),e(\"code\",[v._v(\"jsx\")]),v._v(\"来编写\"),e(\"code\",[v._v(\"react\")]),v._v(\" 的组件。但\"),e(\"code\",[v._v(\"jsx\")]),v._v(\"只是一个抽象的语法糖，看上去是写组件，其实我们写的是对象，只是这样写更方便，更符合我们前端开发者的编写习惯，看上去就像写\"),e(\"code\",[v._v(\"html\")]),v._v(\"，多爽。\")]),v._v(\" \"),e(\"p\",[v._v(\"虚拟 \"),e(\"code\",[v._v(\"DOM\")]),v._v(\" 除了在渲染时用于提高渲染性能，以最小的代价来更新视图的作用外，另一个作用就是为组件的跨平台渲染提供可能。\")]),v._v(\" \"),e(\"p\",[v._v(\"虚拟\"),e(\"code\",[v._v(\"DOM\")]),v._v(\"本身 就是一个内存中的对象，通过对象的属性来描述要渲染的具体是什么元素以及内容。\")]),v._v(\" \"),e(\"p\",[v._v(\"举个栗子\")]),v._v(\" \"),e(\"p\",[v._v(\"下面是我们一个组件的\"),e(\"code\",[v._v(\"render\")]),v._v(\"部分\")]),v._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[v._v(\"<ul id='list'>\\n  <li class='item'>1</li>\\n  <li class='item'>2</li>\\n  <li class='item'>3</li>\\n</ul>\\n\\n\")])])]),e(\"p\",[v._v(\"上面的结构可以转换为下面的对象表示（虚拟 dom）\")]),v._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[v._v(\"const tree = {\\n  tag: 'ul', // 节点标签名\\n  props: {       // DOM的属性，用一个对象存储键值对\\n    id: 'list'\\n  },\\n  children: [    // 该节点的子节点\\n    {tag: 'li', props: {class: 'item'}, children: ['1']},\\n    {tag: 'li', props: {class: 'item'}, children: ['2']},\\n    {tag: 'li', props: {class: 'item'}, children: ['3']},\\n  ]\\n}\\n\\n\")])])]),e(\"p\",[v._v(\"从上面我们可以看出这就是个普通对象。\")]),v._v(\" \"),e(\"p\",[v._v(\"既然有了这样的对象，我们就可以轻松的把这个对象转换我们想要的表现形式，比如 \"),e(\"code\",[v._v(\"html\")]),v._v(\"格式，而这个\"),e(\"code\",[v._v(\"html\")]),v._v(\"就是我们要直出的内容。\")]),v._v(\" \"),e(\"p\",[v._v(\"不过这个转换的过程不需要我们来完成，\"),e(\"code\",[v._v(\"react\")]),v._v(\"已经帮我们完成，其本身就已提供了内置方法来支持服务端渲染。\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"同构\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#同构\"}},[v._v(\"#\")]),v._v(\" 同构\")]),v._v(\" \"),e(\"p\",[e(\"code\",[v._v(\"React\")]),v._v(\" 虚拟 \"),e(\"code\",[v._v(\"DOM\")]),v._v(\" 为我们实现 \"),e(\"code\",[v._v(\"SSR\")]),v._v(\" 提供了基础条件，但是单纯的 \"),e(\"code\",[v._v(\"SSR\")]),v._v(\" 和 传统的 \"),e(\"code\",[v._v(\"SSR\")]),v._v(\" 没有什么区别，\"),e(\"code\",[v._v(\"React\")]),v._v(\"中的 组件也只能用作其他模板语言的代替品。。。\")]),v._v(\" \"),e(\"p\",[v._v(\"那么为什么还要基于\"),e(\"code\",[v._v(\"React\")]),v._v(\"来实现\"),e(\"code\",[v._v(\"SSR\")]),v._v(\"呢？\")]),v._v(\" \"),e(\"p\",[v._v(\"既然这种技术能够出现，肯定是因为有他独特的魅力和优点。\")]),v._v(\" \"),e(\"p\",[v._v(\"我们要明白一点，服务端渲染的核心作用。\")]),v._v(\" \"),e(\"p\",[e(\"code\",[v._v(\"SSR\")]),v._v(\"主要是直接表达出页面最基础和核心的内容这就够了。\")]),v._v(\" \"),e(\"p\",[v._v(\"剩下的工作就要交给浏览器了，浏览器端需要对页面的交互完成进一步的渲染、事件绑定等增强功能。\")]),v._v(\" \"),e(\"p\",[v._v(\"说到这里好像有点明白了，意思不就是服务端把首屏的内容直出，让用户更快的看到页面，然后后面的数据采用\"),e(\"code\",[v._v(\"js\")]),v._v(\"来异步请求和加载。貌似不用\"),e(\"code\",[v._v(\"react\")]),v._v(\"一样可以做到的呀。\")]),v._v(\" \"),e(\"p\",[v._v(\"诶，好像说的没啥毛病。确实方案不只一种，但是我们基于\"),e(\"code\",[v._v(\"react\")]),v._v(\"来实现可以更高效，写更少的代码。因为我们可以构造同构应用。\")]),v._v(\" \"),e(\"p\",[v._v(\"所谓同构，就是指前后端公用一套代码，比如我们的组件可以在服务端渲染也可以在客户端渲染，但都是同一个组件。这样的方式应该是可以甩传统方式好几条街了把。\")]),v._v(\" \"),e(\"p\",[v._v(\"当然打造同构应用还有另外一个得天独厚的条件，双端使用同一种语言 - javascript。\")]),v._v(\" \"),e(\"p\",[e(\"code\",[v._v(\"SSR\")]),v._v(\" 部分我们使用\"),e(\"code\",[v._v(\"node\")]),v._v(\"就能完成,所以我们才可以编写同一套代码供双端执行。\")]),v._v(\" \"),e(\"p\",[v._v(\"另外还有一个重要的特性也是同构的重要体现,浏览器接管页面后的进一步渲染（交互、事件）过程中，会判断已有的\"),e(\"code\",[v._v(\"DOM\")]),v._v(\"结构和浏览器渲染出的结构是否相同，若相同，则不重复渲染，只需要绑定事件即可。\")]),v._v(\" \"),e(\"p\",[v._v(\"当然上面的这个特性是\"),e(\"code\",[v._v(\"react\")]),v._v(\"提供的双端节点对比功能，也是为了最大限度的提高页面的渲染效率，尽可能的重用服务端给出的\"),e(\"code\",[v._v(\"html\")]),v._v(\"结构。\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"打造同构应用\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#打造同构应用\"}},[v._v(\"#\")]),v._v(\" 打造同构应用\")]),v._v(\" \"),e(\"p\",[v._v(\"说了这么多其实本质还是\"),e(\"code\",[v._v(\"react\")]),v._v(\"的能力，有了它的支持才能玩的转，这当然也得力于\"),e(\"code\",[v._v(\"node\")]),v._v(\"。\")]),v._v(\" \"),e(\"p\",[v._v(\"说到这里，可能有同学会这样认为，既然\"),e(\"code\",[v._v(\"react\")]),v._v(\"都为我们提供了，那我们实现起来就很方便了呀。和我们做\"),e(\"code\",[v._v(\"SPA\")]),v._v(\"应用的时候差不多吧，只写一套代码，然后在服务端调用下\"),e(\"code\",[v._v(\"react\")]),v._v(\"服务端渲染的相关 \"),e(\"code\",[v._v(\"api\")]),v._v(\" ，浏览器端也不需要管，\"),e(\"code\",[v._v(\"react\")]),v._v(\"也帮我们搞定了。\")]),v._v(\" \"),e(\"p\",[v._v(\"说的好像没啥毛病，但是打造同构应该不是仅仅调用几个\"),e(\"code\",[v._v(\"api\")]),v._v(\"的事儿，如果你只是打算写一个\"),e(\"code\",[v._v(\"demo\")]),v._v(\"玩玩，我觉得是可以的。\")]),v._v(\" \"),e(\"p\",[v._v(\"同构的最大优点是双端可以公用一套代码，但它是一把双刃剑，因为他还涉及到服务端，所以复杂性大大增加。\")]),v._v(\" \"),e(\"p\",[v._v(\"另外双端也不是完全能公用一套代码，还需要做很多差异化的处理。不只是代码层面的，还会涉及到架构和工程化。\")]),v._v(\" \"),e(\"p\",[v._v(\"虽然我们已经了解了\"),e(\"code\",[v._v(\"react ssr\")]),v._v(\"的最核心的原理，但是并不能保证你能迅速的开发出这样体验的应用。\")]),v._v(\" \"),e(\"p\",[v._v(\"所以我们需要一个轮子，这个轮子本身已经帮我们完备了双端的差异处理，开发者只需要关心自身业务逻辑，开发中无差异化。\")]),v._v(\" \"),e(\"p\",[v._v(\"而这个轮子就是我们接下来要一步一步实现的\"),e(\"code\",[v._v(\"React SSR\")]),v._v(\"应用开发骨架。\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"双端对比机制\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#双端对比机制\"}},[v._v(\"#\")]),v._v(\" 双端对比机制\")]),v._v(\" \"),e(\"p\",[v._v(\"上面也提到了这个概念，这里需要详细的说明一下。\")]),v._v(\" \"),e(\"p\",[v._v(\"为了实现服务端渲染，打造同构应用，\"),e(\"code\",[v._v(\"React\")]),v._v(\"内部实现了相关的\"),e(\"code\",[v._v(\"API\")]),v._v(\"，可以让我们方便的将一个组件转换为\"),e(\"code\",[v._v(\"html\")]),v._v(\"字符串。\")]),v._v(\" \"),e(\"p\",[v._v(\"下面介绍几个\"),e(\"code\",[v._v(\"API\")])]),v._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[v._v(\"import ReactDOMServer from 'react-dom/server'\\n\\n\")])])]),e(\"p\",[e(\"code\",[v._v(\"ReactDOMServer\")]),v._v(\" 类可以帮我们在服务端渲染组件 - 得到组件的 \"),e(\"code\",[v._v(\"html\")]),v._v(\" 字符串。\")]),v._v(\" \"),e(\"p\",[v._v(\"下面是介绍该模块的两个方法\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"renderToString()\")])]),v._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[v._v(\"ReactDOMServer.renderToString(element)\\n\\n\")])])]),e(\"p\",[v._v(\"把一个\"),e(\"code\",[v._v(\"React\")]),v._v(\"组件渲染为原始的\"),e(\"code\",[v._v(\"HTML\")]),v._v(\"。\")]),v._v(\" \"),e(\"p\",[v._v(\"我们可以用这个方法在服务端生成\"),e(\"code\",[v._v(\"HTML\")]),v._v(\"字符串，然后将该字符串返回给浏览器端，完成页面内容的初始化，同时让搜索引擎可以抓取你的页面来达到优化\"),e(\"code\",[v._v(\"SEO\")]),v._v(\"的目的。\")]),v._v(\" \"),e(\"p\",[v._v(\"另外在\"),e(\"code\",[v._v(\"react 16\")]),v._v(\"前该方法生成的\"),e(\"code\",[v._v(\"html\")]),v._v(\"内容的每一个\"),e(\"code\",[v._v(\"DOM\")]),v._v(\"节点都有一个\"),e(\"code\",[v._v(\"data-react-id\")]),v._v(\"属性，根节点会有一个\"),e(\"code\",[v._v(\"data-react-checksum\")]),v._v(\"属性。\")]),v._v(\" \"),e(\"p\",[v._v(\"组件在服务端渲染后，在浏览器端还会渲染一次，来完成组件的交互等逻辑。渲染时，\"),e(\"code\",[v._v(\"react\")]),v._v(\"在浏览器端会计算出组件的\"),e(\"code\",[v._v(\"data-react-checksum\")]),v._v(\"属性值，如果发现和服务端计算的值一致，则不会进行客户端渲染。所以\"),e(\"code\",[v._v(\"data-react-checksum\")]),v._v(\"属性的作用是为了完成组件的双端对比。\")]),v._v(\" \"),e(\"p\",[v._v(\"如果两个组件的\"),e(\"code\",[v._v(\"props\")]),v._v(\"和\"),e(\"code\",[v._v(\"DOM\")]),v._v(\"结构是相同的，那么计算出的该属性值就是一致的。\")]),v._v(\" \"),e(\"p\",[v._v(\"也可以换个角度来理解，当双端渲染的组件的\"),e(\"code\",[v._v(\"props\")]),v._v(\"和\"),e(\"code\",[v._v(\"DOM\")]),v._v(\"结构一致时，那么该组件只会渲染一次，客户端会采用服务端渲染的结果，仅作事件绑定等处理，这会让我们的应用有一个非常高效的初次加载体验。\")]),v._v(\" \"),e(\"p\",[v._v(\"ps:\"),e(\"code\",[v._v(\"data-react-checksum\")]),v._v(\"属性值是通过\"),e(\"code\",[v._v(\"Adler-32\")]),v._v(\"校验算法实现的。有兴趣的可以了解下此算法，这里就不详细说明了。\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"renderToStaticMarkup()\")])]),v._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[v._v(\"ReactDOMServer.renderToStaticMarkup(element)\\n\\n\")])])]),e(\"p\",[v._v(\"该方法就比较轻量了，仅仅是为了将组件渲染为\"),e(\"code\",[v._v(\"html\")]),v._v(\"字符串，不会带有\"),e(\"code\",[v._v(\"data-react-checksum\")]),v._v(\"属性。\")]),v._v(\" \"),e(\"p\",[v._v(\"和上面方法的能力不同，当然使用场景也不同，如果只是单纯服务端渲染的话可以用该方法，性能肯定要比上面的方法高，因为不需要计算嘛，还能减少直出的内容体积。\")]),v._v(\" \"),e(\"h3\",{attrs:{id:\"性能提升\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#性能提升\"}},[v._v(\"#\")]),v._v(\" 性能提升\")]),v._v(\" \"),e(\"p\",[v._v(\"咱们上面说的都是\"),e(\"code\",[v._v(\"react 16\")]),v._v(\"以前的，现在是什么样的呢？\")]),v._v(\" \"),e(\"p\",[v._v(\"从\"),e(\"code\",[v._v(\"react 16\")]),v._v(\"开始，服务端渲染\"),e(\"code\",[v._v(\"renderToString\")]),v._v(\"方法渲染的结果不再有\"),e(\"code\",[v._v(\"data-react-*\")]),v._v(\"属性，当然也相应的提供了一个客户端渲染\"),e(\"code\",[v._v(\"API\")]),v._v(\" - \"),e(\"code\",[v._v(\"ReactDOM.hydrate()\")]),v._v(\"，从使用上来说和\"),e(\"code\",[v._v(\"ReactDOM.render()\")]),v._v(\"没有差别。\")]),v._v(\" \"),e(\"p\",[v._v(\"在浏览器端渲染时，该方法会最大限度的保留服务端使用\"),e(\"code\",[v._v(\"renderToString()\")]),v._v(\"渲染的内容，同时添加事件绑定等交互。\")]),v._v(\" \"),e(\"ul\",[e(\"li\",[v._v(\"renderToNodeStream 和 renderToStaticNodeStream\")])]),v._v(\" \"),e(\"p\",[v._v(\"另外 \"),e(\"code\",[v._v(\"react 16\")]),v._v(\" 在性能上还做了改进，提供了可以将组件转换为字节流的\"),e(\"code\",[v._v(\"renderToNodeStream\")]),v._v(\"方法。\")]),v._v(\" \"),e(\"p\",[v._v(\"其实使用\"),e(\"code\",[v._v(\"renderToNodeStream\")]),v._v(\"或者\"),e(\"code\",[v._v(\"renderToString\")]),v._v(\"对最终的渲染结果没有影响。不过\"),e(\"code\",[v._v(\"renderToNodeStream\")]),v._v(\"的性能要好的多，可以有效缩短\"),e(\"code\",[v._v(\"TTFB\")]),v._v(\"时间。\")]),v._v(\" \"),e(\"p\",[v._v(\"因为组件渲染为字符串，是一次性处理完后才开始向浏览器端返回结果。而采用流的话，可以边读边输出，可以要让页面更快的展现，缩短首屏展现时间。\")]),v._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/30/16ff2883d6d95e82?w=397&h=398&f=png&s=20288\",alt:\"\"}})]),v._v(\" \"),e(\"p\",[v._v(\"那么\"),e(\"code\",[v._v(\"renderToStaticNodeStream\")]),v._v(\"可以结合 \"),e(\"code\",[v._v(\"renderToStaticMarkup\")]),v._v(\"理解下，作用应该很明了了。\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"同构应用流程图\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#同构应用流程图\"}},[v._v(\"#\")]),v._v(\" 同构应用流程图\")]),v._v(\" \"),e(\"p\",[v._v(\"上面我们介绍了很多理论性的知识，可能不够具象。\")]),v._v(\" \"),e(\"p\",[v._v(\"为了加强理解我准备了一张同构应用的流程图。\")]),v._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/28/16fe82eb96f4a852?w=795&h=2029&f=png&s=204615\",alt:\"\"}})]),v._v(\" \"),e(\"h1\",{attrs:{id:\"小结\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[v._v(\"#\")]),v._v(\" 小结\")]),v._v(\" \"),e(\"p\",[v._v(\"本节我们主要从原理来了解下\"),e(\"code\",[v._v(\"react ssr\")]),v._v(\"技术，目的是希望能对该技术有更深的理解和认识。\")]),v._v(\" \"),e(\"p\",[v._v(\"另外可以根据同构应用流程图来对我们的应用骨架有个宏观的认识，后面我们就要进入实践阶段，一步一步的来打造我们的应用骨架了。\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"造轮子，所需要的工具\")])]),v._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[v._v(\"node10.14  其实支持async await的版本就可以\\nreact16.8 \\nreact-router5 \\nredux\\nredux-thunk\\nwebpack4 \\nbabel7 \\nkoa2 ，小册里使用 koa2，当然用 express 也可以\\n...其他的一些插件和库，细节在后面说明\\n\\n\")])])]),e(\"p\",[v._v(\"let's go！一起去造轮子啦!\")])])}),[],!1,null,null,null);_.default=a.exports}}]);","extractedComments":[]}