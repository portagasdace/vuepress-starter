{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[310],{668:function(n,e,a){\"use strict\";a.r(e);var s=a(42),t=Object(s.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[a(\"blockquote\",[a(\"p\",[n._v(\"本节代码对应 GitHub 分支: chapter6\")])]),n._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://github.com/sanyuan0704/react-cloud-music/tree/chapter6\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"仓库传送门\"),a(\"OutboundLink\")],1)]),n._v(\" \"),a(\"h2\",{attrs:{id:\"封装-ui-代码\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#封装-ui-代码\"}},[n._v(\"#\")]),n._v(\" 封装 UI 代码\")]),n._v(\" \"),a(\"p\",[n._v(\"现在 Album 里面的 JSX 过于庞大，影响可读性，可以做一下封装。\")]),n._v(\" \"),a(\"p\",[n._v(\"将复杂渲染的代码拆解如下:\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v('const renderTopDesc = () => {\\n  return (\\n    <TopDesc background={currentAlbum.coverImgUrl}>\\n      <div className=\"background\">\\n        <div className=\"filter\"></div>\\n      </div>\\n      <div className=\"img_wrapper\">\\n        <div className=\"decorate\"></div>\\n        <img src={currentAlbum.coverImgUrl} alt=\"\" />\\n        <div className=\"play_count\">\\n          <i className=\"iconfont play\">&#xe885;</i>\\n          <span className=\"count\">{getCount (currentAlbum.subscribedCount)}</span>\\n        </div>\\n      </div>\\n      <div className=\"desc_wrapper\">\\n        <div className=\"title\">{currentAlbum.name}</div>\\n        <div className=\"person\">\\n          <div className=\"avatar\">\\n            <img src={currentAlbum.creator.avatarUrl} alt=\"\" />\\n          </div>\\n          <div className=\"name\">{currentAlbum.creator.nickname}</div>\\n        </div>\\n      </div>\\n    </TopDesc>\\n  )\\n}\\n\\nconst renderMenu = () => {\\n  return (\\n    <Menu>\\n      <div>\\n        <i className=\"iconfont\">&#xe6ad;</i>\\n        评论\\n      </div>\\n      <div>\\n        <i className=\"iconfont\">&#xe86f;</i>\\n        点赞\\n      </div>\\n      <div>\\n        <i className=\"iconfont\">&#xe62d;</i>\\n        收藏\\n      </div>\\n      <div>\\n        <i className=\"iconfont\">&#xe606;</i>\\n        更多\\n      </div>\\n    </Menu>\\n  )\\n};\\n\\nconst renderSongList = () => {\\n  return (\\n    <SongList>\\n      <div className=\"first_line\">\\n        <div className=\"play_all\">\\n          <i className=\"iconfont\">&#xe6e3;</i>\\n          <span > 播放全部 <span className=\"sum\">(共 {currentAlbum.tracks.length} 首)</span></span>\\n        </div>\\n        <div className=\"add_list\">\\n          <i className=\"iconfont\">&#xe62d;</i>\\n          <span > 收藏 ({getCount (currentAlbum.subscribedCount)})</span>\\n        </div>\\n      </div>\\n      <SongItem>\\n        {\\n          currentAlbum.tracks.map ((item, index) => {\\n            return (\\n              <li key={index}>\\n                <span className=\"index\">{index + 1}</span>\\n                <div className=\"info\">\\n                  <span>{item.name}</span>\\n                  <span>\\n                    {getName (item.ar)} - {item.al.name}\\n                  </span>\\n                </div>\\n              </li>\\n            )\\n          })\\n        }\\n      </SongItem>\\n    </SongList>\\n  )\\n}\\n\\nreturn (\\n  <CSSTransition\\n    in={showStatus}\\n    timeout={300}\\n    classNames=\"fly\"\\n    appear={true}\\n    unmountOnExit\\n    onExited={props.history.goBack}\\n  >\\n    <Container>\\n      <Header ref={headerEl} title={title} handleClick={handleBack} isMarquee={isMarquee}></Header>\\n      {!isEmptyObject (currentAlbum) ?\\n        (\\n          <Scroll\\n            bounceTop={false}\\n            onScroll={handleScroll}\\n          >\\n            <div>\\n              { renderTopDesc () }\\n              { renderMenu () }\\n              { renderSongList () }\\n            </div>\\n          </Scroll>\\n        )\\n        : null\\n      }\\n      { enterLoading ? <Loading></Loading> : null}\\n    </Container>\\n  </CSSTransition>\\n)\\n\\n')])])]),a(\"p\",[n._v(\"这样整个返回的 JSX 代码就清爽了不少，给人一目了然的感觉。\")]),n._v(\" \"),a(\"h2\",{attrs:{id:\"usecallback-优化-function-props\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#usecallback-优化-function-props\"}},[n._v(\"#\")]),n._v(\" useCallback 优化 function props\")]),n._v(\" \"),a(\"p\",[n._v(\"将传给子组件的函数用 useCallback 包裹，这也是 useCallback 的常用场景。\")]),n._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[n._v(\"const handleBack = useCallback (() => {\\n  setShowStatus (false);\\n}, []);\\n\\nconst handleScroll = useCallback ((pos) => {\\n  //xxx\\n}, [currentAlbum]);\\n\\n\")])])]),a(\"p\",[n._v(\"以此为例，如果不用 useCallback 包裹，父组件每次执行时会生成不一样的 handleBack 和 handleScroll 函数引用，那么子组件每一次 memo 的结果都会不一样，导致不必要的重新渲染，也就浪费了 memo 的价值。\")]),n._v(\" \"),a(\"p\",[n._v(\"因此 useCallback 能够帮我们在依赖不变的情况保持一样的函数引用，最大程度地节约浏览器渲染性能。\")]),n._v(\" \"),a(\"p\",[n._v(\"OK，歌单详情模块现在开发基本完成。\")])])}),[],!1,null,null,null);e.default=t.exports}}]);","extractedComments":[]}