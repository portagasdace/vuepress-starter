{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[330],{684:function(e,t,n){\"use strict\";n.r(t);var r=n(42),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"redux-及中间件原理解析\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redux-及中间件原理解析\"}},[e._v(\"#\")]),e._v(\" Redux 及中间件原理解析\")]),e._v(\" \"),n(\"p\",[e._v(\"在做这个项目的过程中，hooks 的 api 相当简洁，代码也容易理解，但 Redux 就不一样了，大量的样板代码，以及各种纯函数的限制，让刚刚上手的新人总会 感觉有些不适应。React 的开发，很大一部分的门槛在于 Redux。可能有人会说了，都 9012 年了，还用什么 Redux 管理数据啊，直接 hooks 一把撸。对于这些人的观点， 我已经小册中间的彩蛋部分给予了回应，我认为 Redux 由于出色的调试机制和完整的模块管理功能，是一个短时间不可被替代的状态管理方案。\")]),e._v(\" \"),n(\"p\",[e._v(\"因此我觉得我们在熟练使用 Redux 的同时，也有必要去研究它内部的原理，体会它的设计思想，这样不仅仅能够加深我们对于 Redux 本身的理解，也能够巩固原生 JS 的 功底，锤炼我们的编程思想。\")]),e._v(\" \"),n(\"p\",[e._v(\"还记得这些熟悉的代码吗？\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('import {createStore, compose, applyMiddleware} from \"redux\";\\n\\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\\nconst store = createStore (reducer, composeEnhancers (applyMiddleware (thunk)));\\n\\n')])])]),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('import { combineReducers } from \"redux-immutable\";\\nimport { reducer as recommendReducer } from \"../application/Recommend/store/index\";\\n//...\\n\\nexport default combineReducers ({\\n  recommend: recommendReducer,\\n  //...\\n});\\n\\n\\n')])])]),n(\"p\",[e._v(\"你知道 createStore 发生了什么？dispatch 执行后在内部怎么运作的？compose 函数做了什么事情？combineReducers 是如何合并不同的 reducer 的？applyMiddleware 是如何组织中间件的？\")]),e._v(\" \"),n(\"p\",[e._v(\"接下来我们就来一一拆解 Redux 在背后为我们做的这些事情。\")]),e._v(\" \"),n(\"p\",[e._v(\"首先要声明的是，为了把原理讲清楚，不可避免地会涉及到源码，但是源码有大量的类型判断和边界检查，如果一一列举，其一对我们理解 Redux 本身的原理没有帮助，其二分散我们的注意力、 浪费大量时间。因此凡是对我们理解 Redux 原理没有帮助的源码部分，我们不予考虑，如果真的很感兴趣可以 \"),n(\"a\",{attrs:{href:\"https://github.com/reduxjs/redux\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"GitHub 仓库\"),n(\"OutboundLink\")],1),e._v(\" 下载它的源码自己去看。\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"createstore-揭秘\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#createstore-揭秘\"}},[e._v(\"#\")]),e._v(\" createStore 揭秘\")]),e._v(\" \"),n(\"p\",[e._v(\"createStore，顾名思义，是要创建一个仓库，是 redux 的核心所在， 它最后要返回四个非常重要的属性，分别是 getState,subscribe,dispatch,replaceReducer。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"export default function createStore (reducer, preloadedState, enhancer) {\\n  //...\\n  return {\\n    getState,// 获取到 state\\n    subscribe,// 采用发布订阅模式，这个方法进行观察者的订阅\\n    dispatch,// 派发 action\\n    replaceReducer// 用新的 reducer 替换现在的\\n  }\\n}\\n\\n\")])])]),n(\"p\",[e._v(\"进入 createStore，第一步是检查参数，一共可以接收三个参数，reducer 表示改变 store 数据的纯函数，preloadedState 表示初始状态，第三个参数暂且不管，后面讲到中间件机制你就 明白它的用意了。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"export default function createStore (reducer, preloadedState, enhancer) {\\n  //reducer 必须是函数\\n  // 当前 reducer\\n  let currentReducer = reducer\\n  //state 数据，redux 的根本\\n  let currentState = preloadedState\\n  // 订阅者集合\\n  let currentListeners = []\\n  // 虽然不起眼，但是是一个关键的设计\\n  let nextListeners = currentListeners\\n  // 是否正在有 dispatch 在运行\\n  let isDispatching = false\\n\\n  //...\\n  //return 代码\\n}\\n\\n\")])])]),n(\"p\",[e._v(\"首先看看它的 getState 方法:\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('function getState () {\\n  // 如果有 dispatch 正在执行则报错\\n  if (isDispatching) throw new Error (\"xxxx 具体信息省略\")\\n  return currentState\\n}\\n\\n')])])]),n(\"p\",[e._v(\"它的 subscribe 方法其实是基于发布订阅模式的，我们想一想只有一个数组来存放订阅者的时候可能会出现什么问题。\")]),e._v(\" \"),n(\"p\",[e._v(\"假若有十个订阅者订阅了 store, 然后一旦条件触发 store 会依次执行所有的订阅者 (注意这里的订阅者 listener 都是方法，下面代码中的类型判断里面有提)。\")]),e._v(\" \"),n(\"p\",[e._v('这个时候第一个方法中干了一件特别 \"孙子\" 的事情，它把其他 9 个人全部退订了。那这个时候数组里面只剩下 1 个订阅者，但是循环还在继续啊，从数组后面的索引拿订阅者来执行，会报错，因为 已经不存在了。')]),e._v(\" \"),n(\"p\",[e._v(\"当然还有更加复杂的情况，这些情况本质上是订阅者 (可以认为函数) 拥有订阅和退订的权利，也就是说，它可以改变订阅者数组。但是我们遍历订阅者的时候是基于最开始的那个订阅者数组。\")]),e._v(\" \"),n(\"p\",[e._v(\"因此我们需要缓存最开始的数组，在调用订阅者的时候，一切关于 currentListeners 的改变都不允许，但是可以拷贝一份同样的数组，让它来承担订阅者对数组的改变，那这个数组就是 nextListeners。\")]),e._v(\" \"),n(\"p\",[e._v(\"subscribe 方法如下定义:\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"function ensureCanMutateNextListeners () {\\n  // 如果 next 和 current 数组是一个引用，那这种情况是危险的，原因上面已经谈到，我们需要 next 和 current 保持各自独立\\n  if (nextListeners === currentListeners) {\\n    nextListeners = currentListeners.slice ()\\n  }\\n}\\n\\nfunction subscribe (listener) {\\n  if (typeof listener !== 'function') {\\n    throw new Error ('Expected the listener to be a function.')\\n  }\\n  // 如果正在有 dispatch 执行则报错\\n  if (isDispatching) {\\n    throw new Error (\\\"xxx\\\")\\n  }\\n  let isSubscribed = true\\n  ensureCanMutateNextListeners ()\\n  nextListeners.push (listener)\\n  // 返回的是一个退订的方法，将特定的 listener 从订阅者集合中删除\\n  return function unsubscribe () {\\n    // 已经退订了就不管了\\n    if (!isSubscribed) return;\\n    if (isDispatching) throw new Error (\\\"xxx 具体信息省略\\\")\\n\\n    isSubscribed = false\\n    ensureCanMutateNextListeners ()\\n    const index = nextListeners.indexOf (listener)\\n    nextListeners.splice (index, 1)\\n  }\\n}\\n\\n\")])])]),n(\"p\",[e._v(\"值得注意的是每次调用这个函数的时候，都会产生一个闭包，里面存储着 isSubscribed 的值，调用 n 次就会产生 n 个这样的闭包，用来存储 n 个不同的订阅情况。 仔细想想还是比较巧妙的做法。\")]),e._v(\" \"),n(\"p\",[e._v(\"接下来是 dispatch 函数:\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"function dispatch (action) {\\n  //action 必须是一个对象\\n  //action.type 不能为 undefined\\n\\n  if (isDispatching) {\\n    throw new Error ('Reducers may not dispatch actions.')\\n  }\\n\\n  try {\\n    isDispatching = true\\n    // 看到没有？执行 reducer 后返回的状态直接成为 currentState 了\\n    currentState = currentReducer (currentState, action)\\n  } finally {\\n    isDispatching = false\\n  }\\n\\n  const listeners = (currentListeners = nextListeners)\\n  for (let i = 0; i < listeners.length; i++) {\\n    const listener = listeners [i]\\n    listener ()\\n  }\\n\\n  return action\\n}\\n\\n\")])])]),n(\"p\",[e._v(\"接下来是 replaceReducer：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"function replaceReducer (nextReducer) {\\n  if (typeof nextReducer !== 'function') {\\n    throw new Error ('Expected the nextReducer to be a function.')\\n  }\\n\\n  currentReducer = nextReducer\\n  // 此时无法匹配任何的 action，但是返回的状态可以将 currentState 给更新\\n  // 也就是更新当前的 state，因为 reducer 更新了，老的 state 该换了！\\n  dispatch ({ type: ActionTypes.REPLACE })\\n}\\n\\n\")])])]),n(\"h2\",{attrs:{id:\"combinereducer-做了些什么\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#combinereducer-做了些什么\"}},[e._v(\"#\")]),e._v(\" combineReducer 做了些什么？\")]),e._v(\" \"),n(\"p\",[e._v(\"还记得我们怎么使用 combineReducer 的吗？\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('import { combineReducers } from \"redux-immutable\";\\nimport { reducer as recommendReducer } from \"../application/Recommend/store/index\";\\nimport { reducer as singersReducer } from \"../application/Singers/store/index\";\\n\\nexport default combineReducers ({\\n  recommend: recommendReducer,\\n  singers: singersReducer,\\n});\\n\\n\\n')])])]),n(\"p\",[e._v(\"combineReducer 用来组织不同模块的 reducer，那背后是怎么组织起来的呢？除去容错性的代码，我们看看 combineReducer 的核心源代码:\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"export default function combineReducers (reducers) {\\n  // 以项目中的例子来讲，reducerKeys 就是 ['recommend', 'singers']\\n  const reducerKeys = Object.keys (reducers)\\n  //finalReducers 是 reducers 过滤后的结果\\n  // 确保 finalReducers 里面每一个键对应的值都是函数\\n  const finalReducers = {}\\n  for (let i = 0; i < reducerKeys.length; i++) {\\n    const key = reducerKeys [i]\\n\\n    if (typeof reducers [key] === 'function') {\\n      finalReducers [key] = reducers [key]\\n    }\\n  }\\n  const finalReducerKeys = Object.keys (finalReducers)\\n\\n  // 最后依然返回一个纯函数\\n  return function combination (state = {}, action) {\\n    // 这个标志位记录初始的 state 是否和经过 reducer 后是一个引用，如果不是则 state 被改变了\\n    let hasChanged = false\\n    const nextState = {}\\n    for (let i = 0; i < finalReducerKeys.length; i++) {\\n      const key = finalReducerKeys [i]\\n      const reducer = finalReducers [key]\\n      // 原来的状态树中 key 对应的值\\n      const previousStateForKey = state [key]\\n      // 调用 reducer 函数，获得该 key 值对应的新状态\\n      const nextStateForKey = reducer (previousStateForKey, action)\\n      nextState [key] = nextStateForKey\\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\\n    }\\n    // 这个很简单理解吧？如果没改变直接把原始的 state 返回即可\\n    return hasChanged ? nextState : state\\n  }\\n}\\n\\n\\n\")])])]),n(\"p\",[e._v(\"很简单理解吧？好，我们现在进入最硬核的部分！\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"compose-函数解读\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#compose-函数解读\"}},[e._v(\"#\")]),e._v(\" compose 函数解读\")]),e._v(\" \"),n(\"p\",[e._v(\"compose 其实是一个工具，充分体现了高阶函数的技巧。源码如下:\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"export default function compose (...funcs) {\\n  if (funcs.length === 0) {\\n    return arg => arg\\n  }\\n\\n  if (funcs.length === 1) {\\n    return funcs [0]\\n  }\\n\\n  return funcs.reduce ((a, b) => (...args) => a (b (...args)))\\n}\\n\\n\")])])]),n(\"p\",[e._v(\"举个例子:\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"const f0 = (x) => { console.log (x) }\\nconst f1 = () => { console.log (1) }\\nconst f2 = () => { console.log (2) }\\nlet fArr = [f2, f1, f0];\\nconsole.log (compose (...fArr)(100)) // 执行 f2 (f1 (f0 (100))) 输出 100 1 2\\n\\n\")])])]),n(\"p\",[e._v(\"现在先埋下伏笔。之后在 applyMiddleware 中如何大显身手。\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"applymiddleware-完全解析\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#applymiddleware-完全解析\"}},[e._v(\"#\")]),e._v(\" applyMiddleware 完全解析\")]),e._v(\" \"),n(\"p\",[e._v(\"这个方法与中间件息息相关，一上来就干讲是很不容易理解的，现在我们以项目中用到的 redux-thunk 中间件为例来演示，先放出 redux-thunk 的源码 (你没看错，就这么一点儿):\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"function createThunkMiddleware (extraArgument) {\\n  // 这里将 middlewareAPI 给解构成了 { dispatch, getState }\\n  return ({ dispatch, getState }) => next => action => {\\n    if (typeof action === 'function') {\\n      return action (dispatch, getState, extraArgument)\\n    }\\n\\n    return next (action)\\n  }\\n}\\n\\nconst thunk = createThunkMiddleware ();\\nthunk.withExtraArgument = createThunkMiddleware;\\n\\nexport default thunk;\\n\\n\")])])]),n(\"p\",[e._v(\"现在我们来打开 applyMiddleware 的源代码:\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"export default function applyMiddleware (...middlewares) {\\n  return createStore => (...args) => {\\n    const store = createStore (...args)\\n    let dispatch = () => {\\n      throw new Error (\\n        'Dispatching while constructing your middleware is not allowed. ' +\\n          'Other middleware would not be applied to this dispatch.'\\n      )\\n    }\\n    //middlewareAPI 其实就是拿到 store 的信息\\n    const middlewareAPI = {\\n      getState: store.getState,\\n      dispatch: (...args) => dispatch (...args)\\n    }\\n    // 参考上面的 thunk，其实就是传入 store 参数，剩下的部分为 next => action => { ... };\\n    // 传入这个参数是必须的，因为需要拿到 store 的相关属性，如 thunk 拿了 getState\\n    // 这里的意思就是每个中间件都能拿到 store 的数据\\n    const chain = middlewares.map (middleware => middleware (middlewareAPI))\\n    dispatch = compose (...chain)(store.dispatch)\\n\\n    return {\\n      ...store,\\n      dispatch\\n    }\\n  }\\n}\\n\\n\")])])]),n(\"p\",[e._v(\"加入现在还有一个 redux-logger 的中间件，调用 applyMiddleware (logger, thunk), 那么走到 compose 逻辑的时候，相当于 调用 logger (thunk (store.dispatch))。这样就完成了中间件的机制。仔细体会一下这中间的执行顺序，其实并不难。\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"探究-createstore-留下来的问题\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#探究-createstore-留下来的问题\"}},[e._v(\"#\")]),e._v(\" 探究 createStore 留下来的问题\")]),e._v(\" \"),n(\"p\",[e._v(\"刚刚在 createStore 那一段提了下参数类型判断，但是第三个参数没有展开讲，那这里面究竟是如何来判断的呢？现在我觉得时机成熟了。\")]),e._v(\" \"),n(\"p\",[e._v(\"给出这一部分源代码:\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"export default function createStore (reducer, preloadedState, enhancer) {\\n  // 第二个参数为函数，但是第三个参数没传\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\\n    enhancer = preloadedState  // 将第二个参数当做 enhancer \\n    preloadedState = undefined\\n  }\\n  // 确保 enhancer 为函数\\n  if (typeof enhancer !== 'undefined') {\\n    if (typeof enhancer !== 'function') {\\n      throw new Error ('Expected the enhancer to be a function.')\\n    }\\n\\n    return enhancer (createStore)(reducer, preloadedState)\\n  }\\n  //...\\n}\\n\\n\")])])]),n(\"p\",[e._v(\"判断类型后返回 enhancer (...) 是针对什么样的场景的呢？\")]),e._v(\" \"),n(\"p\",[e._v(\"如果要用 thunk 中间件，那么 redux 官方文档是这么写的:\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"const store = createStore (reducer, applyMiddleware (thunk));\\n\\n\")])])]),n(\"p\",[e._v(\"看到没？这个时候其实 redux 内部的 enhancer 就变成了 applyMiddleware (thunk) 的结果。\")]),e._v(\" \"),n(\"p\",[e._v(\"运行流程其实变成了 applyMiddleware (thunk)(createStore)(reducer, preloadedState);\")]),e._v(\" \"),n(\"p\",[e._v(\"而返回的结果赋给了 store, 当前 store 中的 dispatch 属性已经成功被更改，一旦走入 dispatch，必然经过中间件。中间件成功地集成！\")]),e._v(\" \"),n(\"p\",[e._v(\"知道了原理后，相信你再写一个自己的 Redux 中间件也易如反掌了。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('function createMyMiddleware (...arg) {\\n  return ({ dispatch, getState }) => next => action => {\\n    console.log (\"我开发的 Redux 中间件\")\\n    return next (action);\\n  }\\n}\\n\\nconst myMiddleware = createMyMiddleware ()\\n\\nexport default myMiddleware;\\n\\n')])])]),n(\"p\",[e._v(\"然后在 createStore 的时候应用:\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"import thunk from 'react-thunk';\\nimport myMiddleware from 'my-middleware';\\nconst store = createStore (reducer, applyMiddleware (thunk, myMiddleware));\\n\\n\")])])]),n(\"p\",[e._v(\"中间件里面具体编写什么内容，应该由业务场景来决定，这里就不展开了。\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"redux-源码中一些有意思的工具函数\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redux-源码中一些有意思的工具函数\"}},[e._v(\"#\")]),e._v(\" Redux 源码中一些有意思的工具函数\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"_1-判断是否为普通的对象\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-判断是否为普通的对象\"}},[e._v(\"#\")]),e._v(\" 1. 判断是否为普通的对象\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"export default function isPlainObject (obj) {\\n  if (typeof obj !== 'object' || obj === null) return false\\n\\n  let proto = obj\\n  while (Object.getPrototypeOf (proto) !== null) {\\n    proto = Object.getPrototypeOf (proto)\\n  }\\n\\n  return Object.getPrototypeOf (obj) === proto\\n}\\n\\n\")])])]),n(\"h3\",{attrs:{id:\"_2-生成随机字符串\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-生成随机字符串\"}},[e._v(\"#\")]),e._v(\" 2. 生成随机字符串\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"const randomString = () =>\\n  Math.random ()\\n    .toString (36)\\n    .substring (7)\\n    .split ('')\\n    .join ('.')\\n\\n\")])])]),n(\"p\",[e._v(\"Redux 原理的解读就到这里了，其实理解它的源码也并没有那些难，但我觉得最重要还是将它的原理和使用结合起来，体会整个设计的思想，研究这些对个人的成长还有是很有帮助的，也希望这篇文章能够起到抛砖引玉的作用，让大家带着更多的好奇和兴趣去研究其他工具的原理，提升自己的思维层次和工程能力。大家加油！\")])])}),[],!1,null,null,null);t.default=a.exports}}]);","extractedComments":[]}