{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{485:function(t,e,n){\"use strict\";n.r(e);var a=n(42),o=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"使用-bloc-对豆瓣电影app-进行重构\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-bloc-对豆瓣电影app-进行重构\"}},[t._v(\"#\")]),t._v(\" 使用 BLoC 对豆瓣电影App 进行重构\")]),t._v(\" \"),n(\"p\",[t._v(\"本节使用 BLoc 对豆瓣电影 App 进行重构。\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"重构后的工程路径\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#重构后的工程路径\"}},[t._v(\"#\")]),t._v(\" 重构后的工程路径\")]),t._v(\" \"),n(\"p\",[t._v(\"StateManager/flutter_doubanmovie_bloc\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"bloc-模式\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bloc-模式\"}},[t._v(\"#\")]),t._v(\" BLoC 模式\")]),t._v(\" \"),n(\"p\",[t._v(\"BLoC 模式指的是一种开发模式，使用这种模式可以使代码的 UI 逻辑和业务逻辑完全分离，从而可以在多个平台（mobile、web、后台等）上重用代码，这里的代码重用指的是业务逻辑代码的重用。BLoC 模式第一次发表是在 2018 年的 DartConf 大会上，由 Google 的 Paolo Soares 和 Cong Hui 设计和提出。\")]),t._v(\" \"),n(\"p\",[t._v(\"BLoC 的全称是 \"),n(\"strong\",[t._v(\"B\")]),t._v(\"usiness \"),n(\"strong\",[t._v(\"Lo\")]),t._v(\"gic \"),n(\"strong\",[t._v(\"C\")]),t._v(\"omponent，这个单词可以拆成两部分来看，第一部分是 Business Logic，就是业务逻辑，第二部分是 Component，就是组件，连起来就是业务逻辑组件，这里也可以看出 BLoC 其实指的就是业务逻辑组件，而且这里的业务逻辑组件是完全独立的，可以和 UI 逻辑进行完全分离。\")]),t._v(\" \"),n(\"p\",[t._v(\"BLoC 模式的核心思想是将 UI 逻辑和业务逻辑分开。在为了达到这一目的，BLoC 模式里使用了 \"),n(\"code\",[t._v(\"响应式编程\")]),t._v(\"（Reactive Programming），先来介绍一下 \"),n(\"code\",[t._v(\"响应式编程\")]),t._v(\"，看 \"),n(\"code\",[t._v(\"响应式编程\")]),t._v(\" 是如何实现 UI 逻辑和业务逻辑分离的。\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"响应式编程\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#响应式编程\"}},[t._v(\"#\")]),t._v(\" 响应式编程\")]),t._v(\" \"),n(\"p\",[n(\"code\",[t._v(\"响应式编程\")]),t._v(\" 使用异步数据流进行编程。在响应式编程里，所有的变化，不管是被动的还是主动的，比如 UI 的点击、变量的变化、数据请求等，都会向异步数据流管道里发送消息，同时，在其他地方会监听数据流，将会收到消息并产生适当的响应。\")]),t._v(\" \"),n(\"p\",[t._v(\"从这段描述里就可以看到，\"),n(\"code\",[t._v(\"响应式编程\")]),t._v(\" 里的数据不是通过参数传递来实现的，而是通过数据流管道来传送，因此数据的发送方和接收方就不需要有依赖关系，实现了解耦，这也是 UI 逻辑和业务逻辑分离的基础。\")]),t._v(\" \"),n(\"h4\",{attrs:{id:\"代码所在位置\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#代码所在位置\"}},[t._v(\"#\")]),t._v(\" 代码所在位置\")]),t._v(\" \"),n(\"p\",[t._v(\"flutter_widget_demo/lib/reactive/CounterWidget.dart\")]),t._v(\" \"),n(\"h4\",{attrs:{id:\"使用响应式编程开发\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用响应式编程开发\"}},[t._v(\"#\")]),t._v(\" 使用响应式编程开发\")]),t._v(\" \"),n(\"p\",[t._v(\"Flutter 响应式编程的三元素是：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"StreamController：数据流管道\")]),t._v(\" \"),n(\"li\",[t._v(\"StreamSink：发出消息\")]),t._v(\" \"),n(\"li\",[t._v(\"Stream：收到消息\")])]),t._v(\" \"),n(\"p\",[t._v(\"为了便于理解，这里写一个简单的例子：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"import 'dart:async';\\n\\nimport 'package:flutter/material.dart';\\n\\nvoid main() => runApp(CounterWidget());\\n\\nclass CounterWidget extends StatefulWidget {\\n  @override\\n  State<StatefulWidget> createState() {\\n    // TODO: implement createState\\n    return CounterState();\\n  }\\n}\\n\\nclass CounterState extends State<CounterWidget> {\\n  @override\\n  Widget build(BuildContext context) {\\n    // TODO: implement build\\n    return MaterialApp(\\n      title: \\\"Flutter Demo\\\",\\n      theme: ThemeData(\\n        primaryColor: Colors.blue,\\n      ),\\n      home: Scaffold(\\n        appBar: AppBar(title: Text(\\\"Flutter 响应式编程\\\")),\\n        body: Center(\\n          child: Text('0'),\\n        ),\\n        floatingActionButton: FloatingActionButton(\\n          child: Icon(Icons.add),\\n        ),\\n      ),\\n    );\\n  }\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"这里写了一个页面，中间是 Text，右下角还有一个 floatingActionButton，运行后的效果为：\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/5/25/16aec36cd216e906?w=428&h=796&f=jpeg&s=29232\",alt:\"\"}})]),t._v(\" \"),n(\"p\",[t._v(\"我们要在这个页面上使用响应式编程实现一个功能：点击 floatingActionButton，Text 里的值就会不断自增。我们需要实现响应式编程的三元素，首先在 StreamControlState 里实现 StreamController：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"class CounterState extends State<CounterWidget> {\\n\\n  static final StreamController<int> _streamController =\\n      StreamController<int>();\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    // TODO: implement build\\n    ...\\n  }\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"StreamSink 通过 \"),n(\"code\",[t._v(\"_streamController.sink\")]),t._v(\" 获取，Stream 通过 \"),n(\"code\",[t._v(\"_streamController.stream\")]),t._v(\" 获取：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"class CounterState extends State<CounterWidget> {\\n\\n  static final StreamController<int> _streamController =\\n      StreamController<int>();\\n  static final StreamSink<int> _sink = _streamController.sink;\\n  static final Stream<int> _stream = _streamController.stream;\\n  \\n  ...\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"然后就可以通过 \"),n(\"code\",[t._v(\"_sink\")]),t._v(\" 发送消息，在 \"),n(\"code\",[t._v(\"_stream\")]),t._v(\" 处接受消息，这里你肯定会比较迷惑，发送一个消息，为什么搞的这么麻烦？这正是响应式编程的魅力所在，如果直接发送，那么就是同步的，如果要实现异步发送，按照正常的实现，就必须要写很多监听和回调，很容易陷入回调陷阱，而在响应式编程里，我们只需关心 \"),n(\"code\",[t._v(\"_sink\")]),t._v(\" 和 \"),n(\"code\",[t._v(\"_stream\")]),t._v(\"，在 \"),n(\"code\",[t._v(\"_sink\")]),t._v(\" 里发送消息，在 \"),n(\"code\",[t._v(\"_stream\")]),t._v(\" 处接受消息，不需要写额外的监听和回调，StreamController 会帮我们处理，而且在 StreamController 里也可以对接受到的数据处理后在发送。\")]),t._v(\" \"),n(\"p\",[t._v(\"因为要写一个自增的功能，需要定义一个变量 \"),n(\"code\",[t._v(\"_count\")]),t._v(\"，默认值为 0：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"class CounterState extends State<CounterWidget> {\\n  int _count = 0;\\n\\n  static final StreamController<int> _streamController =\\n      StreamController<int>();\\n  ...\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"在 floatingActionButton 点击的时候发送数据：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"floatingActionButton: FloatingActionButton(\\n  child: Icon(Icons.add),\\n  onPressed: () {\\n    _sink.add(++_count);\\n  },\\n)\\n\\n\")])])]),n(\"p\",[t._v(\"Text 处接受信息，因为 Text 是 Widget，所以要使用 StreamBuilder：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"StreamBuilder(\\n  stream: _stream,\\n  initialData: 0,\\n  builder: (context, snapShot) {\\n    return Center(\\n      child: Text('${snapShot.data}'),\\n    );\\n  },\\n)\\n\\n\")])])]),n(\"p\",[t._v(\"StreamBuilder 里的 stream 赋值为 _stream，意思是接受 _stream 里的数据，initialData 为 0，表示默认的数据为 0，builder 里返回 Text，snapShot.data 表示的是接受到的数据。然后一个响应式编程的自增功能就实现了，点击 floatingActionButton，Text 里的数据就不断自增。\")]),t._v(\" \"),n(\"p\",[t._v(\"但是在这段代码里，floatingActionButton 里面还涉及到了具体的业务的逻辑：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"_sink.add(++_count);\\n\\n\")])])]),n(\"p\",[t._v(\"正确的做法应该是，floatingActionButton 不应该关心到底是自增还是自减这种具体的业务逻辑，它只要发送我被点击了这个通知，具体的业务逻辑在外面进行处理，所以这里可以这么改：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"class CounterState extends State<CounterWidget> {\\n  ...\\n\\n  @override\\n  Widget build(BuildContext context) {\\n\\n    return MaterialApp(\\n      ...\\n        floatingActionButton: FloatingActionButton(\\n          child: Icon(Icons.add),\\n          onPressed: () {\\n            _calculate();\\n          },\\n        ),\\n      ...\\n    );\\n  }\\n\\n  void _calculate(){\\n    _sink.add(++_count);\\n  }\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"新增一个 \"),n(\"code\",[t._v(\"_calculate()\")]),t._v(\" 方法，在 floatingActionButton 里调用 \"),n(\"code\",[t._v(\"_calculate()\")]),t._v(\" 而不是直接使用 \"),n(\"code\",[t._v(\"_sink.add(++_count)\")]),t._v(\"。这时候可能也有人有疑问，这不是闲着蛋疼吗，多写了一个方法，结果最后调用的代码都是一样的，不是变复杂了吗？\")]),t._v(\" \"),n(\"p\",[t._v(\"虽然确实多了几行代码，但是这几行代码对框架来说非常有意义，首先，floatingActionButton 就不用关心具体的业务，只负责发送事件；再者，假设功能由自增变为自减，在原来的代码里，你就得在 floatingActionButton 里把 ++ 改为 --，这里功能比较简单还好说，如果功能一旦复杂，这里修改就会比较麻烦，不仅破坏了原来的代码，使得功能不容易扩展，但是如果把 \"),n(\"code\",[t._v(\"_sink.add(++_count);\")]),t._v(\" 封装在 \"),n(\"code\",[t._v(\"_calculate()\")]),t._v(\" 方法里，这样如果功能有修改，只要在 \"),n(\"code\",[t._v(\"_calculate()\")]),t._v(\" 方法里写就好了，floatingActionButton 和 Text 都不会受影响。就因为多了这几行代码，floatingActionButton 和 Text 就不用关心业务，只需要做好 UI 展示就行，在保证了代码健壮性的同时也保证了代码的扩展性。\")]),t._v(\" \"),n(\"p\",[t._v(\"现在对这段代码画一个流程图：\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/5/27/16af805991a8b007?w=1230&h=306&f=png&s=16229\",alt:\"\"}})]),t._v(\" \"),n(\"p\",[t._v(\"在这个流程图里，floatingActionButton 被点击后，发送事件，触发 _calculate() 方法，_calculate() 方法负责业务逻辑，_count 自增，使用 sink 将数据发送出去， stream 收到数据 data，使 Text 用最新的 data 数据重建。\")]),t._v(\" \"),n(\"p\",[t._v(\"在这个流程里不仅用到了 \"),n(\"code\",[t._v(\"响应式编程\")]),t._v(\"，为了将 floatingActionButton 和 Text 这两个 Widget 彻底和业务隔离，还抽象出了 _calculate() 方法和 data 数据，这两个进一步抽象，_calculate() 可以抽象成 event 事件，data 抽象成 state 状态。\")]),t._v(\" \"),n(\"p\",[t._v(\"接下来讲 BLoC 模式里的事件和状态流向图。\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"bloc-模式里的事件和状态流向图\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bloc-模式里的事件和状态流向图\"}},[t._v(\"#\")]),t._v(\" BLoC 模式里的事件和状态流向图\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/5/27/16af80bd2cbe3a04?w=1230&h=306&f=png&s=14084\",alt:\"\"}})]),t._v(\" \"),n(\"p\",[t._v(\"上图是 BLoC 模式里的事件和状态流向图：\")]),t._v(\" \"),n(\"ol\",[n(\"li\",[t._v(\"Widget 向 BLoC 发送事件\")]),t._v(\" \"),n(\"li\",[t._v(\"事件会触发 BLoC 里的 sink\")]),t._v(\" \"),n(\"li\",[t._v(\"然后 Stream 会把 State 通知给 Widget\")])]),t._v(\" \"),n(\"p\",[t._v(\"这里的 Event 是为了把 Widget 和具体的业务逻辑分离抽象出来的东西，State 就是 Widget 显示需要用到的数据，也是和业务逻辑分离的。\")]),t._v(\" \"),n(\"p\",[t._v(\"最终，由 BLoC 实现的业务逻辑层，具有以下的特点：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"BLoC 依赖响应式编程\")]),t._v(\" \"),n(\"li\",[t._v(\"有 Event 和 State\")])]),t._v(\" \"),n(\"p\",[t._v(\"由此，BLoC 实现了业务逻辑层和 UI 逻辑的分离，为此带来了巨大的好处：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"可以用对 App 影响最小的方式修改业务逻辑\")]),t._v(\" \"),n(\"li\",[t._v(\"可以修改 UI，而不用担心影响业务逻辑\")]),t._v(\" \"),n(\"li\",[t._v(\"更加方便单元测试\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"bloc-模式的架构图\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bloc-模式的架构图\"}},[t._v(\"#\")]),t._v(\" BLoC 模式的架构图\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/5/27/16af81b6c86b3191?w=316&h=672&f=png&s=17893\",alt:\"\"}})]),t._v(\" \"),n(\"p\",[t._v(\"上图是 BLoC 模式的架构图，看到这里你觉得和某个模式很像，没错就是 MVVM：\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/5/27/16af820d7ce78716?w=700&h=676&f=png&s=31575\",alt:\"\"}})]),t._v(\" \"),n(\"p\",[t._v(\"总共有四层，从上到下分别是：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"UI Screen\")]),t._v(\" \"),n(\"li\",[t._v(\"BLoC\")]),t._v(\" \"),n(\"li\",[t._v(\"Repository\")]),t._v(\" \"),n(\"li\",[t._v(\"Network Provider\")])]),t._v(\" \"),n(\"p\",[t._v(\"Widget 对应的是 MVVM 里的 View，BLoC 对应的是 MVVM 里的 ViewModel，Repository 和 Network Provider 对应的是 MVVM 里的 Model。\")]),t._v(\" \"),n(\"p\",[t._v(\"从这里也可以看出，BLoC 其实指的是一种开发模式，BLoC 也有很多种实现，这里介绍一个第三方库 \"),n(\"code\",[t._v(\"flutter_bloc\")]),t._v(\"，一个实现 BLoC 模式的 Flutter 库。\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"flutter-bloc-的使用\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#flutter-bloc-的使用\"}},[t._v(\"#\")]),t._v(\" flutter_bloc 的使用\")]),t._v(\" \"),n(\"p\",[n(\"code\",[t._v(\"flutter_bloc\")]),t._v(\" 实现了 BLoC 模式，暴露出几个类，我们只要使用这几个类变可以轻松实现 BLoC 模式，这几个类分别是：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"Bloc\")]),t._v(\" \"),n(\"li\",[t._v(\"BlocBuilder\")]),t._v(\" \"),n(\"li\",[t._v(\"BlocProvider\")]),t._v(\" \"),n(\"li\",[t._v(\"BlocProviderTree\")]),t._v(\" \"),n(\"li\",[t._v(\"BlocListener\")]),t._v(\" \"),n(\"li\",[t._v(\"BlocListenerTree\")])]),t._v(\" \"),n(\"h4\",{attrs:{id:\"bloc\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bloc\"}},[t._v(\"#\")]),t._v(\" Bloc\")]),t._v(\" \"),n(\"p\",[t._v(\"Bloc 类是用来实现如下模块的：\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/5/27/16af827edee178ee?w=316&h=256&f=png&s=5306\",alt:\"\"}})]),t._v(\" \"),n(\"blockquote\",[n(\"p\",[t._v(\"在这里，请大家注意一下 BLoC 和 Bloc，BLoC 是大写，Bloc 是小写，BLoC 指的是 BLoC 开发模式，Bloc 指的是 BLoC 开发模式实现里的一个类。\")])]),t._v(\" \"),n(\"p\",[t._v(\"可以看到 Bloc 类里包含了 Event、State，也有 sink、stream 响应式编程，不过 sink、stream 响应式编程已经被 \"),n(\"code\",[t._v(\"flutter_bloc\")]),t._v(\" 框架实现，我们只要关心 Event 和 State 就行，这个在 Bloc 类的定义里也能体现出来，Bloc 类的定义为：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"abstract class Bloc<Event, State> {\\n   ...\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"Bloc 类里有两个泛型：Event 和 State，Event 是从外部接受到的事件，State 是输出 Widget 关心的状态。\")]),t._v(\" \"),n(\"p\",[t._v(\"比如，要实现一个加减功能的 Bloc，那么我们可以这么实现：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"enum CounterEvent { increment, decrement }\\n\\nclass CounterBloc extends Bloc<CounterEvent, int> {\\n  @override\\n  int get initialState => 0;\\n\\n  @override\\n  Stream<int> mapEventToState(CounterEvent event) async* {\\n    switch (event) {\\n      case CounterEvent.decrement:\\n        yield currentState - 1;\\n        break;\\n      case CounterEvent.increment:\\n        yield currentState + 1;\\n        break;\\n    }\\n  }\\n}\\n\\n\")])])]),n(\"h4\",{attrs:{id:\"blocbuilder\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#blocbuilder\"}},[t._v(\"#\")]),t._v(\" BlocBuilder\")]),t._v(\" \"),n(\"p\",[t._v(\"BlocBuilder 是一个 Widget，它的功能类似于前面讲的 StreamBuilder，但是使用起来更简单，BlocBuiler 监听 Bloc 的状态，当状态发生变化时，就重建 Widget，因此 BlocBuiler 有两个参数：Bloc 和 BlocWidgetBuilder，我们可以看一下 BlocBuiler 的构造函数：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"const BlocBuilder({\\n    Key key,\\n    @required this.bloc,\\n    @required this.builder,\\n  })\\n\\n\")])])]),n(\"p\",[t._v(\"参数名字\")]),t._v(\" \"),n(\"p\",[t._v(\"参数类型\")]),t._v(\" \"),n(\"p\",[t._v(\"意义\")]),t._v(\" \"),n(\"p\",[t._v(\"必选 or 可选\")]),t._v(\" \"),n(\"p\",[t._v(\"key\")]),t._v(\" \"),n(\"p\",[t._v(\"Key\")]),t._v(\" \"),n(\"p\",[t._v(\"Widget 的标识\")]),t._v(\" \"),n(\"p\",[t._v(\"可选\")]),t._v(\" \"),n(\"p\",[t._v(\"bloc\")]),t._v(\" \"),n(\"p\",[t._v(\"Bloc<E, S>\")]),t._v(\" \"),n(\"p\",[t._v(\"监听已经实现的 Bloc 类\")]),t._v(\" \"),n(\"p\",[t._v(\"必选\")]),t._v(\" \"),n(\"p\",[t._v(\"builder\")]),t._v(\" \"),n(\"p\",[t._v(\"BlocWidgetBuilder\")]),t._v(\" \"),n(\"p\",[t._v(\"监听 Bloc 类里状态的变化，重建 Widget\")]),t._v(\" \"),n(\"p\",[t._v(\"必选\")]),t._v(\" \"),n(\"p\",[t._v(\"BlocWidgetBuilder 需要返回一个 Widget。\")]),t._v(\" \"),n(\"p\",[t._v(\"使用方法如下：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"BlocBuilder(\\n  bloc: BlocA(),\\n  builder: (context, state) {\\n    // return widget here based on BlocA's state\\n    return WidgetA();\\n  }\\n)\\n\\n\")])])]),n(\"h4\",{attrs:{id:\"blocprovider\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#blocprovider\"}},[t._v(\"#\")]),t._v(\" BlocProvider\")]),t._v(\" \"),n(\"p\",[t._v(\"BlocProvider 是一个 Widget，可以将 Bloc 类提供给它的子 Widget。BlocProvider 经常用来作为依赖注入的部件，以便将单个 Bloc 类的实例，在多个 Widget 里共享。\")]),t._v(\" \"),n(\"p\",[t._v(\"使用方法如下：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"BlocA blocA = BlocA();\\n\\nBlocProvider(\\n  bloc: blocA,\\n  child: ChildA(),\\n)\\n\\n\\nBlocProvider(\\n  bloc: blocA,\\n  child: ChildB(),\\n)\\n\\n\")])])]),n(\"p\",[t._v(\"上面的使用方法，就将一个实例 blocA，分享到了 ChildA 和 ChildB 里。\")]),t._v(\" \"),n(\"p\",[t._v(\"然后如果想在 ChildA 或 ChildB 里拿到 BlocA 的实例，可以这么做：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"BlocProvider.of<BlocA>(context)\\n\\n\")])])]),n(\"h4\",{attrs:{id:\"blocprovidertree\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#blocprovidertree\"}},[t._v(\"#\")]),t._v(\" BlocProviderTree\")]),t._v(\" \"),n(\"p\",[t._v(\"BlocProviderTree 也是一个 Widget，前面讲的 BlocProvider 是把一个 Bloc 实例共享到多个 Widget 里，有时候一个 Widget 也需要用到多个 Bloc。\")]),t._v(\" \"),n(\"p\",[t._v(\"假设 ChildA 需要用到 BlocA、BlocB、BlocC，如果用 BlocProvider 实现的话，就是：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"BlocProvider<BlocA>(\\n  bloc: BlocA(),\\n  child: BlocProvider<BlocB>(\\n    bloc: BlocB(),\\n    child: BlocProvider<BlocC>(\\n      value: BlocC(),\\n      child: ChildA(),\\n    )\\n  )\\n)\\n\\n\")])])]),n(\"p\",[t._v(\"使用 BlocProviderTree 可以把多个 BlocProvider 合成一个：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"BlocProviderTree(\\n  blocProviders: [\\n    BlocProvider<BlocA>(bloc: BlocA()),\\n    BlocProvider<BlocB>(bloc: BlocB()),\\n    BlocProvider<BlocC>(bloc: BlocC()),\\n  ],\\n  child: ChildA(),\\n)\\n\\n\")])])]),n(\"h4\",{attrs:{id:\"bloclistener\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bloclistener\"}},[t._v(\"#\")]),t._v(\" BlocListener\")]),t._v(\" \"),n(\"p\",[t._v(\"BlocListener 是一个 Widget，有两个参数：Bloc 和 BlocWidgetListener，类似于 BlocBuilder，需要接收一个 Bloc 类作为参数，但也有不同的地方， BlocBuilder 里的 BlocWidgetBuilder 需要返回 Widget，而 BlocWidgetListener 不用返回 Widget，它的返回类型是 void，所以用来做一些其他操作，例如：弹对话框、弹 SnackBar、跳转到新的页面等。\")]),t._v(\" \"),n(\"p\",[t._v(\"使用方法如下：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"BlocListener(\\n  bloc: _bloc,\\n  listener: (context, state) {\\n    if (state is Success) {\\n      Navigator.of(context).pushNamed('/details');\\n    }\\n  }\\n}\\n\\n\")])])]),n(\"h4\",{attrs:{id:\"bloclistenertree\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bloclistenertree\"}},[t._v(\"#\")]),t._v(\" BlocListenerTree\")]),t._v(\" \"),n(\"p\",[t._v(\"BlocListenerTree 是一个 Widget，用于将多个 BlockListener 合成一个 Widget。\")]),t._v(\" \"),n(\"p\",[t._v(\"例如：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"BlocListener<BlocAEvent, BlocAState>(\\n  bloc: BlocA(),\\n  listener: (BuildContext context, BlocAState state) {},\\n  child: BlocListener<BlocBEvent, BlocBState>(\\n    bloc: BlocB(),\\n    listener: (BuildContext context, BlocBState state) {},\\n    child: BlocListener<BlocCEvent, BlocCState>(\\n      bloc: BlocC(),\\n      listener: (BuildContext context, BlocCState state) {},\\n      child: ChildA(),\\n    ),\\n  ),\\n)\\n\\n\")])])]),n(\"p\",[t._v(\"就可以用 BlocListenerTree 实现为：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"BlocListenerTree(\\n  blocListeners: [\\n    BlocListener<BlocAEvent, BlocAState>(\\n      bloc: BlocA(),\\n      listener: (BuildContext context, BlocAState state) {},\\n    ),\\n    BlocListener<BlocBEvent, BlocBState>(\\n      bloc: BlocB(),\\n      listener: (BuildContext context, BlocBState state) {},\\n    ),\\n    BlocListener<BlocCEvent, BlocCState>(\\n      bloc: BlocC(),\\n      listener: (BuildContext context, BlocCState state) {},\\n    ),\\n  ],\\n  child: ChildA(),\\n)\\n\\n\")])])]),n(\"h2\",{attrs:{id:\"使用-flutter-bloc-重构\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-flutter-bloc-重构\"}},[t._v(\"#\")]),t._v(\" 使用 flutter_bloc 重构\")]),t._v(\" \"),n(\"p\",[t._v(\"接下来使用 \"),n(\"code\",[t._v(\"flutter_bloc\")]),t._v(\" 这个库对豆瓣电影App 进行重构。\")]),t._v(\" \"),n(\"h4\",{attrs:{id:\"添加依赖\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#添加依赖\"}},[t._v(\"#\")]),t._v(\" 添加依赖\")]),t._v(\" \"),n(\"p\",[t._v(\"首先，在 pubspec.yaml 里添加 \"),n(\"code\",[t._v(\"flutter_bloc\")]),t._v(\" 库的依赖：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"dependencies:\\n  ...\\n  flutter_bloc: ^0.14.0\\n\\n\")])])]),n(\"p\",[t._v(\"在 VS Code 里使用快捷键保存后，会自动下载依赖库。\")]),t._v(\" \"),n(\"h4\",{attrs:{id:\"目录调整\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#目录调整\"}},[t._v(\"#\")]),t._v(\" 目录调整\")]),t._v(\" \"),n(\"p\",[t._v(\"然后开始重构，在 lib 根目录下新建一个 bloc 的文件夹和一个 ui 的文件夹，然后把除了 main.dart 的文件都移到 ui 的文件夹下，如图：\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/5/27/16af8eba18eebe74?w=566&h=348&f=jpeg&s=19768\",alt:\"\"}})]),t._v(\" \"),n(\"p\",[t._v(\"这样做的目的是把 bloc 和 ui 分开。\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"bloc-的核心模块\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bloc-的核心模块\"}},[t._v(\"#\")]),t._v(\" BLoC 的核心模块\")]),t._v(\" \"),n(\"p\",[t._v(\"现在开始写 BLoC 的核心模块，包括：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"State\")]),t._v(\" \"),n(\"li\",[t._v(\"Event\")]),t._v(\" \"),n(\"li\",[t._v(\"Bloc\")])]),t._v(\" \"),n(\"p\",[t._v(\"在 bloc 文件夹下，新建一个文件 CityBloc.dart，BLoC 的核心模块都写到这个文件夹下。\")]),t._v(\" \"),n(\"h4\",{attrs:{id:\"定义-state\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定义-state\"}},[t._v(\"#\")]),t._v(\" 定义 State\")]),t._v(\" \"),n(\"p\",[t._v(\"首先，要把共享的状态定义出来。因为有了前面两节重构的经验，这次我们直接对全局状态 \"),n(\"code\",[t._v(\"_curCity\")]),t._v(\" 进行重构，在 CityBloc.dart 里定义一个 CityState，代码为：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"class CityState{\\n  String _curCity;\\n\\n  get curCity => _curCity;\\n\\n  CityState(this._curCity);\\n\\n}\\n\\n\")])])]),n(\"h4\",{attrs:{id:\"定义-evnet\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定义-evnet\"}},[t._v(\"#\")]),t._v(\" 定义 Evnet\")]),t._v(\" \"),n(\"p\",[t._v(\"在 CityBloc.dart 里定义一个 CityEvent，代码为：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"\\nclass CityState{\\n  ...\\n}\\n\\nclass CityEvent {\\n  String _city;\\n\\n  get city => _city;\\n\\n  CityEvent(this._city);\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"CityEvent 用来更新当前选中的城市。\")]),t._v(\" \"),n(\"h4\",{attrs:{id:\"写-bloc\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#写-bloc\"}},[t._v(\"#\")]),t._v(\" 写 Bloc\")]),t._v(\" \"),n(\"p\",[t._v(\"然后在 CityBloc.dart 里开始写 Bloc 类，这里定义为 CityBloc，CityBloc 继承自 Bloc，代码为：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"import 'package:bloc/bloc.dart';\\nimport 'package:shared_preferences/shared_preferences.dart';\\n\\n\\nclass CityState{\\n   ...\\n}\\n\\nclass CityEvent {\\n   ...\\n}\\n\\nclass CityBloc extends Bloc<CityEvent, CityState> {\\n\\n  CityBloc() {\\n    initData();\\n  }\\n\\n  void initData() async {\\n    final prefs = await SharedPreferences.getInstance(); //获取 prefs\\n\\n    String city = prefs.getString('curCity'); //获取 key 为 curCity 的值\\n\\n    dispatch(CityEvent(city));\\n  }\\n\\n  @override\\n  // TODO: implement initialState\\n  get initialState => CityState(null); //默认值为空\\n\\n  @override\\n  Stream<CityState> mapEventToState(CityEvent event) async*{\\n    // TODO: implement mapEventToState\\n    yield new CityState(event.city);\\n  }\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"注意 CityBloc 实现里的泛型：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"class CityBloc extends Bloc<CityEvent, CityState>\\n\\n\")])])]),n(\"p\",[t._v(\"代表的是接受的参数是 CityEvent，抛出的参数是 CityState，这里的 CityState 就是要共享的状态。\")]),t._v(\" \"),n(\"p\",[t._v(\"在 CityBloc 的默认构造函数里去读取本地的数据。initialState 里 CityState 的值默认为 null。\")]),t._v(\" \"),n(\"p\",[n(\"code\",[t._v(\"mapEventToState\")]),t._v(\" 方法，是接受 Event，然后返回最新的状态。\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"注入-bloc\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#注入-bloc\"}},[t._v(\"#\")]),t._v(\" 注入 Bloc\")]),t._v(\" \"),n(\"p\",[t._v(\"然后在 main.dart 里，给子 Widget 注入 CityBloc：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"class _MyHomePageState extends State<MyHomePage> {\\n  ...\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    return Scaffold(\\n      body: BlocProvider<CityBloc>(\\n        bloc: CityBloc(),\\n        child: _widgetItems[_selectedIndex], //选中不同的选项显示不同的界面\\n      ),\\n      ...\\n    );\\n  }\\n  ...\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"在 HotWidget 里使用 BlocBuilder 监听 CityBloc：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"class HotWidgetState extends State<HotWidget> {\\n  ...\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    // TODO: implement build\\n    print('HotWidgetState build');\\n\\n    return BlocBuilder(\\n      bloc: BlocProvider.of<CityBloc>(context),\\n      builder: (context, String curCity) {\\n        if (curCity != null && curCity.isNotEmpty) {\\n          //如果 curCity 不为空\\n          ...\\n        } else {\\n          //如果 curCity 为空\\n          ...\\n        }\\n      },\\n    );\\n  }\\n\\n  void _jumpToCitysWidget() async {\\n    var selectCity =\\n        await Navigator.pushNamed(context, '/Citys', arguments: BlocProvider.of<CityBloc>(context)..currentState.curCity);\\n    if (selectCity == null) return;\\n\\n    final prefs = await SharedPreferences.getInstance();\\n    prefs.setString('curCity', selectCity); //存取数据\\n\\n    //城市变化时，使用 CityBloc dispatch CityEvent\\n    BlocProvider.of<CityBloc>(context).dispatch(CityEvent(selectCity));\\n  }\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"当 CityBloc 状态发生变化时，就会创建 HotWidgetState 里的 Widget。这里在看一下 \"),n(\"code\",[t._v(\"_jumpToCitysWidget()\")]),t._v(\" 里的改动，在子 Widget 里通过 \"),n(\"code\",[t._v(\"BlocProvider.of<CityBloc>(context)\")]),t._v(\" 获取 CityBloc 实例，从而获取当前的城市：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"BlocProvider.of<CityBloc>(context).currentState.curCity\\n\\n\")])])]),n(\"p\",[t._v(\"如果要改变城市，就是用 CityBloc 的 dispatch 方法：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"BlocProvider.of<CityBloc>(context).dispatch(CityEvent(selectCity));\\n\\n\")])])]),n(\"p\",[t._v(\"CitysWidget 就不用重构了，因为 CitysWidget 采用参数传递的方法就没问题。至此，一个完整的 BLoC 模式的开发方式就展现在你的眼前。当然，我们的重构还没有结束，现在继续。\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"hotmovieslistwidget-的-bloc-模式重构\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hotmovieslistwidget-的-bloc-模式重构\"}},[t._v(\"#\")]),t._v(\" HotMoviesListWidget 的 BLoC 模式重构\")]),t._v(\" \"),n(\"p\",[t._v(\"接下来对 HotMoviesListWidget 重构，这个是重点，因为 HotMoviesListWidget 里的状态是本地状态，而且前面两种方式对这里的重构，都不太好。\")]),t._v(\" \"),n(\"p\",[t._v(\"所以我们这里也要着重观察一下，BLoC 模式对本地状态的处理。\")]),t._v(\" \"),n(\"p\",[t._v(\"在 bloc 文件夹下新建文件 \"),n(\"code\",[t._v(\"HotMoviesListBloc\")]),t._v(\"，代码为：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"import 'package:bloc/bloc.dart';\\nimport 'package:flutter_doubanmovie/bloc/HotMovieData.dart';\\nimport 'package:flutter_doubanmovie/bloc/MoviesRepository.dart';\\n\\nclass HotMoviesListState{\\n  List<HotMovieData> _list;\\n\\n  get list => _list;\\n\\n  HotMoviesListState(this._list);\\n}\\n\\n\\nclass HotMoviesEvent{\\n  String _curCity;\\n\\n  get curCity => _curCity;\\n\\n  HotMoviesEvent(this._curCity);\\n}\\n\\nclass HotMoviesListBloc extends Bloc<HotMoviesEvent,HotMoviesListState>{\\n\\n  final _movieRepository = MoviesRepository();\\n\\n  @override\\n  // TODO: implement initialState\\n  HotMoviesListState get initialState => HotMoviesListState(null);\\n\\n  @override\\n  Stream<HotMoviesListState> mapEventToState(HotMoviesEvent event) async *{\\n    // TODO: implement mapEventToState\\n    List<HotMovieData> movies = await _movieRepository.fetchMoviesList(event.curCity);\\n    yield HotMoviesListState(movies);\\n  }\\n\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"HotMoviesListBloc 和 CityBloc 类似，同样包含了：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"State\")]),t._v(\" \"),n(\"li\",[t._v(\"Event\")]),t._v(\" \"),n(\"li\",[t._v(\"Bloc\")])]),t._v(\" \"),n(\"p\",[t._v(\"HotMoviesListBloc 接受的参数是 HotMoviesEvent，抛出的状态是 HotMoviesListState。\")]),t._v(\" \"),n(\"p\",[t._v(\"然后实现 MoviesRepository，同样在 bloc 文件夹下新建文件 MoviesRepository.dart，代码为：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"import 'package:flutter_doubanmovie/bloc/HotMovieData.dart';\\nimport 'package:flutter_doubanmovie/bloc/MoviesApiProvider.dart';\\n\\nclass MoviesRepository{\\n  final _movieApiProvider = MoviesApiProvider();\\n\\n  Future<List<HotMovieData>> fetchMoviesList(String city) async {\\n    return _movieApiProvider.fetchMoviesList(city);\\n  }\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"在实现 MoviesApiProvider，同样在 bloc 文件夹下新建文件 MoviesApiProvider.dart，代码为：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"import 'dart:convert';\\n\\nimport 'package:flutter_doubanmovie/bloc/HotMovieData.dart';\\nimport 'package:http/http.dart' as http;\\n\\nclass MoviesApiProvider {\\n  \\n  Future<List<HotMovieData>> fetchMoviesList(String city) async {\\n    List<HotMovieData> serverDataList = new List();\\n    var response = await http.get(\\n        'https://api.douban.com/v2/movie/in_theaters?apikey=0b2bdeda43b5688921839c8ecb20399b&city=' +\\n            city +\\n            '&start=0&count=10');\\n    //成功获取数据\\n    if (response.statusCode == 200) {\\n      var responseJson = json.decode(response.body);\\n      for (dynamic data in responseJson['subjects']) {\\n        HotMovieData hotMovieData = HotMovieData.fromJson(data);\\n        serverDataList.add(hotMovieData);\\n      }\\n    }\\n\\n    return serverDataList;\\n  }\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"写完 HotMoviesListBloc 后，因为要给子 Widet 提供两个 bloc，所以在 main.dart 里改造为：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"class _MyHomePageState extends State<MyHomePage> {\\n  ...\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    return Scaffold(\\n      body: BlocProviderTree(\\n        blocProviders: [\\n          BlocProvider<CityBloc>(bloc: CityBloc()),\\n          BlocProvider<HotMoviesListBloc>(bloc: HotMoviesListBloc())\\n        ],\\n        child: _widgetItems[_selectedIndex], //选中不同的选项显示不同的界面\\n      ),\\n      ...\\n    );\\n  }\\n  ...\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"HotMoviesListWidget 改为：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"import 'package:flutter/material.dart';\\nimport 'package:flutter_bloc/flutter_bloc.dart';\\nimport 'package:flutter_doubanmovie/bloc/HotMoviesListBloc.dart';\\nimport 'package:flutter_doubanmovie/ui/hot/hotlist/ui/item/HotMovieItemWidget.dart';\\n\\nclass HotMoviesListWidget extends StatefulWidget {\\n\\n  HotMoviesListWidget() {\\n  }\\n\\n  @override\\n  State<StatefulWidget> createState() {\\n    // TODO: implement createState\\n    return HotMoviesListWidgetState();\\n  }\\n}\\n\\nclass HotMoviesListWidgetState extends State<HotMoviesListWidget>\\n    with AutomaticKeepAliveClientMixin {\\n  @override\\n  void initState() {\\n    // TODO: implement initState\\n    super.initState();\\n  }\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    // TODO: implement build\\n\\n    return BlocBuilder(\\n      bloc: BlocProvider.of<HotMoviesListBloc>(context),\\n      builder: (context,HotMoviesListState moviesListState) {\\n        if (moviesListState == null || moviesListState.list == null || moviesListState.list.length == 0) {\\n          return Center(\\n            child: CircularProgressIndicator(),\\n          );\\n        } else {\\n          return MediaQuery.removePadding(\\n            removeTop: true,\\n            context: context,\\n            child: ListView.separated(\\n              itemCount: moviesListState.list.length,\\n              itemBuilder: (context, index) {\\n                return HotMovieItemWidget(moviesListState.list[index]);\\n              },\\n              separatorBuilder: (context, index) {\\n                return Divider(\\n                  height: 1,\\n                  color: Colors.black26,\\n                );\\n              },\\n            ),\\n          );\\n        }\\n      },\\n    );\\n  }\\n\\n  @override\\n  // TODO: implement wantKeepAlive\\n  bool get wantKeepAlive => true; //返回 true，表示不会被回收\\n}\\n\\n\\n\")])])]),n(\"p\",[t._v(\"这里首先把 HotMoviesListWidget 原来有参数的构造函数删掉了，这样 HotMoviesListWidget 彻底和业务隔开，它不需要知道现在是哪个城市，只需要显示就行，然后 HotMoviesListWidgetState 里的 build 改成了 BlocBuilder：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"return BlocBuilder(\\n    bloc: BlocProvider.of<HotMoviesListBloc>(context),\\n    builder: (context, HotMoviesListState moviesListState) {\\n       ...\\n    },\\n);\\n\\n\")])])]),n(\"p\",[t._v(\"BlocBuilder 的 bloc 为 HotMoviesListBloc，builder 里的 moviesListState 就是 HotMoviesListWidget 的本地状态，里面有要展示的电影列表数据。\")]),t._v(\" \"),n(\"p\",[t._v(\"还有一个很关键的点，就是 HotMoviesListBloc 也需要一个地方，来发出事件，触发 HotMoviesListWidget 的重建，这里发出事件的地方选择在 HotWidget 里：\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"class HotWidgetState extends State<HotWidget> {\\n  ...\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    // TODO: implement build\\n    print('HotWidgetState build');\\n\\n    return BlocBuilder(\\n      bloc: BlocProvider.of<CityBloc>(context),\\n      builder: (context, String curCity) {\\n        if (curCity != null && curCity.isNotEmpty) {\\n          //如果 curCity 不为空\\n          BlocProvider.of<HotMoviesListBloc>(context)\\n              .dispatch(HotMoviesEvent(curCity));\\n          ...\\n        \\n        }\\n        else {\\n           ...\\n        }\\n      }\\n    );\\n }\\n ...\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"至此，就重构完了，重构完后的目录结构为：\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/5/27/16af925740de2fb9?w=802&h=908&f=jpeg&s=82743\",alt:\"\"}})])])}),[],!1,null,null,null);e.default=o.exports}}]);","extractedComments":[]}