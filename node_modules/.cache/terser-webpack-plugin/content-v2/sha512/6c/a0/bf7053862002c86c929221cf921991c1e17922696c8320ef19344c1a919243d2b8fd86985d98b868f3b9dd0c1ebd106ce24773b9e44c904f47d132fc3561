{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[319],{676:function(n,e,t){\"use strict\";t.r(e);var a=t(42),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[t(\"p\",[n._v(\"现在，我们终于进入到了逻辑层的开发，之前我们已经准备好了相关的数据并且已经让组件连接，这里会省不少事情。但是整个交互的逻辑还是比较复杂的，希望大家能够提前做好心理准备，迎接这个挑战吧。\")]),n._v(\" \"),t(\"p\",[n._v(\"首先把问题拆分一下，对播放器而言，进行交互的部分无非就是两个部分：mini版和全屏版。我们先从简单一些的mini版开始入手吧。\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"mini播放器\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mini播放器\"}},[n._v(\"#\")]),n._v(\" mini播放器\")]),n._v(\" \"),t(\"p\",[n._v(\"mini播放器目前依赖的数据是播放状态和播放进度数据。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"const { song, fullScreen, playing, percent } = props;\\n\\nconst { clickPlaying, setFullScreen } = props;\\n\\n\")])])]),t(\"p\",[n._v(\"进度条这里的JSX代码也需要修改一下:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('// 暂停的时候唱片也停止旋转\\n<img className={`play ${playing ? \"\": \"pause\"}`} src={song.al.picUrl} width=\"40\" height=\"40\" alt=\"img\"/>\\n\\n')])])]),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('<ProgressCircle radius={32} percent={percent}>\\n  { playing ? \\n    <i className=\"icon-mini iconfont icon-pause\" onClick={e => clickPlaying(e, false)}>&#xe650;</i>\\n    :\\n    <i className=\"icon-mini iconfont icon-play\" onClick={e => clickPlaying(e, true)}>&#xe61e;</i> \\n  }\\n</ProgressCircle>\\n\\n')])])]),t(\"p\",[n._v(\"当然在父组件中也要做相应修改:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"const clickPlaying = (e, state) => {\\n  e.stopPropagation();\\n  togglePlayingDispatch(state);\\n};\\nreturn (\\n  <div>\\n    <MiniPlayer\\n      song={currentSong}\\n      fullScreen={fullScreen}\\n      playing={playing}\\n      toggleFullScreen={toggleFullScreenDispatch}\\n      clickPlaying={clickPlaying}\\n    />\\n    <NormalPlayer \\n      song={currentSong}\\n      fullScreen={fullScreen}\\n      playing={playing}\\n      toggleFullScreen={toggleFullScreenDispatch}\\n      clickPlaying={clickPlaying}\\n    />\\n  </div>\\n)\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"初次完成播放\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#初次完成播放\"}},[n._v(\"#\")]),n._v(\" 初次完成播放\")]),n._v(\" \"),t(\"p\",[n._v(\"Ok, 现在我们来处理更复杂的全屏播放器部分。\")]),n._v(\" \"),t(\"p\",[n._v(\"首先定义必要的播放器属性:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//Player/index.js\\n\\n//目前播放时间\\nconst [currentTime, setCurrentTime] = useState(0);\\n//歌曲总时长\\nconst [duration, setDuration] = useState(0);\\n//歌曲播放进度\\nlet percent = isNaN(currentTime / duration) ? 0 : currentTime / duration;\\n\\n\")])])]),t(\"p\",[n._v(\"同时需要接受redux中的currentIndex:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"  const { fullScreen, playing, currentIndex, currentSong: immutableCurrentSong } = props;\\n  const { toggleFullScreenDispatch, togglePlayingDispatch, changeCurrentIndexDispatch, changeCurrentDispatch } = props;\\n\\n  let currentSong = immutableCurrentSong.toJS();\\n\\n\")])])]),t(\"p\",[n._v(\"我们现在的当务之急是让播放器能够播放, 所以现在我们需要放上我们的核心元素————audio标签:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//绑定ref\\nconst audioRef = useRef();\\n\\nreturn (\\n  <div>\\n    //...\\n    <audio ref={audioRef}></audio>\\n  </div>\\n)\\n\\n\")])])]),t(\"p\",[n._v(\"现在先写一些逻辑:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//mock一份playList，后面直接从 redux 拿，现在只是为了调试播放效果。\\nconst playList = [\\n    {\\n      ftype: 0,\\n      djId: 0,\\n      a: null,\\n      cd: '01',\\n      crbt: null,\\n      no: 1,\\n      st: 0,\\n      rt: '',\\n      cf: '',\\n      alia: [\\n        '手游《梦幻花园》苏州园林版推广曲'\\n      ],\\n      rtUrls: [],\\n      fee: 0,\\n      s_id: 0,\\n      copyright: 0,\\n      h: {\\n        br: 320000,\\n        fid: 0,\\n        size: 9400365,\\n        vd: -45814\\n      },\\n      mv: 0,\\n      al: {\\n        id: 84991301,\\n        name: '拾梦纪',\\n        picUrl: 'http://p1.music.126.net/M19SOoRMkcHmJvmGflXjXQ==/109951164627180052.jpg',\\n        tns: [],\\n        pic_str: '109951164627180052',\\n        pic: 109951164627180050\\n      },\\n      name: '拾梦纪',\\n      l: {\\n        br: 128000,\\n        fid: 0,\\n        size: 3760173,\\n        vd: -41672\\n      },\\n      rtype: 0,\\n      m: {\\n        br: 192000,\\n        fid: 0,\\n        size: 5640237,\\n        vd: -43277\\n      },\\n      cp: 1416668,\\n      mark: 0,\\n      rtUrl: null,\\n      mst: 9,\\n      dt: 234947,\\n      ar: [\\n        {\\n          id: 12084589,\\n          name: '妖扬',\\n          tns: [],\\n          alias: []\\n        },\\n        {\\n          id: 12578371,\\n          name: '金天',\\n          tns: [],\\n          alias: []\\n        }\\n      ],\\n      pop: 5,\\n      pst: 0,\\n      t: 0,\\n      v: 3,\\n      id: 1416767593,\\n      publishTime: 0,\\n      rurl: null\\n    }\\n];\\nuseEffect(() => {\\n  if(!currentSong) return;\\n  changeCurrentIndexDispatch(0);//currentIndex默认为-1，临时改成0\\n  let current = playList[0];\\n  changeCurrentDispatch(current);//赋值currentSong\\n  audioRef.current.src = getSongUrl(current.id);\\n  setTimeout(() => {\\n    audioRef.current.play();\\n  });\\n  togglePlayingDispatch(true);//播放状态\\n  setCurrentTime(0);//从头开始播放\\n  setDuration((current.dt / 1000) | 0);//时长\\n}, []);\\n\\n\")])])]),t(\"p\",[n._v(\"其中，getSongUrl为一个封装在api/utils.js中的方法:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//拼接出歌曲的url链接\\nexport const getSongUrl = id => {\\n  return `https://music.163.com/song/media/outer/url?id=${id}.mp3`;\\n};\\n\\n\")])])]),t(\"p\",[n._v(\"引入:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('import { getSongUrl } from \"../../api/utils\";\\n\\n')])])]),t(\"p\",[n._v(\"但是你现在会看到这样的报错信息:\")]),n._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/16/16fac32579302b6b?w=473&h=23&f=jpeg&s=6902\",alt:\"\"}})]),n._v(\" \"),t(\"p\",[n._v(\"这是因为初始化store数据的时候，currentSong是一个空对象，song.al为undefined, 因此song.al.picUrl就会报错。\")]),n._v(\" \"),t(\"p\",[n._v(\"那怎么来规避这个问题呢？\")]),n._v(\" \"),t(\"p\",[n._v(\"很简单，我们在渲染播放器的时候判断一下currentSong是否对空对象就可以了。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('import { isEmptyObject } from \"../../api/utils\";\\n\\n//JSX\\nreturn (\\n  <div>\\n    { isEmptyObject(currentSong) ? null : \\n      <MiniPlayer\\n        song={currentSong}\\n        fullScreen={fullScreen}\\n        playing={playing}\\n        toggleFullScreen={toggleFullScreenDispatch}\\n        clickPlaying={clickPlaying}\\n      /> \\n    }\\n    { isEmptyObject(currentSong) ? null : \\n      <NormalPlayer\\n        song={currentSong}\\n        fullScreen={fullScreen}\\n        playing={playing}\\n        toggleFullScreen={toggleFullScreenDispatch}\\n        clickPlaying={clickPlaying}\\n      />\\n    }\\n    <audio ref={audioRef}></audio>\\n  </div>\\n)\\n\\n')])])]),t(\"p\",[n._v(\"好，现在你打开项目应该可以听到背景音乐了，现在我们迈出了第一步。接下来就是一步步不断地完善播放的逻辑。\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"播放和暂停\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#播放和暂停\"}},[n._v(\"#\")]),n._v(\" 播放和暂停\")]),n._v(\" \"),t(\"p\",[n._v(\"首先是播放和暂停的逻辑。\")]),n._v(\" \"),t(\"p\",[n._v(\"其实之前已经完成，只不过没有和audio元素对接。现在通过监听playing变量来实现:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"useEffect(() => {\\n  playing ? audioRef.current.play() : audioRef.current.pause();\\n}, [playing]);\\n\\n\")])])]),t(\"p\",[n._v(\"现在在mini播放器可以看到效果，但是normalPlayer里面却没反应，现在补充上里面的逻辑。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('//normalPlayer/index.js\\nconst { song, fullScreen, playing } =  props;\\nconst { toggleFullScreen, clickPlaying } = props;\\n\\n//JSX中的修改\\n//CdWrapper下唱片图片\\n<div className=\"cd\">\\n  <img\\n    className={`image play ${playing ? \"\" : \"pause\"}`}\\n    src={song.al.picUrl + \"?param=400x400\"}\\n    alt=\"\"\\n  />\\n</div>\\n//中间暂停按钮\\n<div className=\"icon i-center\">\\n  <i\\n    className=\"iconfont\"\\n    onClick={e => clickPlaying(e, !playing)}\\n    dangerouslySetInnerHTML={{\\n      __html: playing ? \"&#xe723;\" : \"&#xe731;\"\\n    }}\\n  ></i>\\n</div>\\n\\n')])])]),t(\"h2\",{attrs:{id:\"进度控制\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进度控制\"}},[n._v(\"#\")]),n._v(\" 进度控制\")]),n._v(\" \"),t(\"p\",[n._v(\"之前写的播放时间都是mock数据, 现在填充成动态数据。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//父组件传值\\n<NormalPlayer\\n  song={currentSong}\\n  fullScreen={fullScreen}\\n  playing={playing}\\n  duration={duration}//总时长\\n  currentTime={currentTime}//播放时间\\n  percent={percent}//进度\\n  toggleFullScreen={toggleFullScreenDispatch}\\n  clickPlaying={clickPlaying}\\n/>\\n\\n\")])])]),t(\"p\",[n._v(\"同时有一点需要注意，就是audio标签在播放的过程中会不断地触发onTimeUpdate事件，在此需要更新currentTime变量。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"const updateTime = e => {\\n  setCurrentTime(e.target.currentTime);\\n};\\n//JSX\\n<audio\\n  ref={audioRef}\\n  onTimeUpdate={updateTime}\\n></audio>\\n\\n\")])])]),t(\"p\",[n._v(\"现在在normalPlayer中：\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('const { song, fullScreen, playing, percent, duration, currentTime } =  props;\\nconst { toggleFullScreen, clickPlaying, onProgressChange } = props;\\n\\n//相应属性传给进度条\\n<ProgressWrapper>\\n  <span className=\"time time-l\">{formatPlayTime(currentTime)}</span>\\n  <div className=\"progress-bar-wrapper\">\\n    <ProgressBar\\n      percent={percent}\\n      percentChange={onProgressChange}\\n    ></ProgressBar>\\n  </div>\\n  <div className=\"time time-r\">{formatPlayTime(duration)}</div>\\n</ProgressWrapper>\\n\\n')])])]),t(\"p\",[n._v(\"ps: 其中，formatPlayTime为api/utils.js中的一个工具函数：\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('//转换歌曲播放时间\\nexport const formatPlayTime = interval => {\\n  interval = interval | 0;// |0表示向下取整\\n  const minute = (interval / 60) | 0;\\n  const second = (interval % 60).toString().padStart(2, \"0\");\\n  return `${minute}:${second}`;\\n};\\n\\n')])])]),t(\"p\",[n._v(\"我要强调的重点是传给ProgressBar的两个参数，一个是percent，用来控制进度条的显示长度，另一个是onProgressChange，这个其实是一个进度条被滑动或点击时用来改变percent的回调函数。我们在父组件来定义它：\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"const onProgressChange = curPercent => {\\n  const newTime = curPercent * duration;\\n  setCurrentTime(newTime);\\n  audioRef.current.currentTime = newTime;\\n  if (!playing) {\\n    togglePlayingDispatch(true);\\n  }\\n};\\n\\n//父组件传值\\n<NormalPlayer\\n  //...\\n  onProgressChange={onProgressChange}\\n/>\\n\\n\")])])]),t(\"p\",[n._v(\"那么之前封装的进度条组件并没有处理percent相关的逻辑，现在在进度条组件中来增加。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"const transform = prefixStyle('transform');\\n\\nconst { percent } = props;\\n\\nconst { percentChange } = props;\\n\\n//监听percent\\nuseEffect(() => {\\n  if(percent >= 0 && percent <= 1 && !touch.initiated) {\\n    const barWidth = progressBar.current.clientWidth - progressBtnWidth;\\n    const offsetWidth = percent * barWidth;\\n    progress.current.style.width = `${offsetWidth}px`;\\n    progressBtn.current.style[transform] = `translate3d(${offsetWidth}px, 0, 0)`;\\n  }\\n  // eslint-disable-next-line\\n}, [percent]);\\n\\nconst _changePercent = () => {\\n  const barWidth = progressBar.current.clientWidth - progressBtnWidth;\\n  const curPercent = progress.current.clientWidth / barWidth;\\n  percentChange(curPercent);\\n}\\n\\n//点击和滑动结束事件改变percent\\nconst progressClick = (e) => {\\n  //...\\n  _changePercent();\\n}\\n\\nconst progressTouchEnd = (e) => {\\n  //...\\n  _changePercent();\\n}\\n\\n\")])])]),t(\"p\",[n._v(\"OK, 进度条被我们改了差不多了，现在就能够对接我们的播放器进度啦！\")]),n._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/16/16fac32f825fb728?w=372&h=60&f=gif&s=88277\",alt:\"\"}})]),n._v(\" \"),t(\"p\",[n._v(\"在最后，我们也把mini播放器的进度对接一下:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//父组件传值\\n<MiniPlayer\\n  //...\\n  percent={percent}\\n></MiniPlayer>\\n\\n\")])])]),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//miniPlayer/index.js\\nconst { full, song, playing, percent } = props;\\n\\n//JSX\\n<ProgressCircle radius={32} percent={percent}>\\n//...\\n\\n\")])])]),t(\"p\",[n._v(\"做到这里大家可以完完整整地听一首歌了，实在不容易，接下来还有上一曲和下一曲的功能，我们慢慢来。\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"上下曲切换逻辑\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#上下曲切换逻辑\"}},[n._v(\"#\")]),n._v(\" 上下曲切换逻辑\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//一首歌循环\\nconst handleLoop = () => {\\n  audioRef.current.currentTime = 0;\\n  changePlayingState(true);\\n  audioRef.current.play();\\n};\\n\\nconst handlePrev = () => {\\n  //播放列表只有一首歌时单曲循环\\n  if (playList.length === 1) {\\n    handleLoop();\\n    return;\\n  }\\n  let index = currentIndex - 1;\\n  if (index < 0) index = playList.length - 1;\\n  if (!playing) togglePlayingDispatch(true);\\n  changeCurrentIndexDispatch(index);\\n};\\n\\nconst handleNext = () => {\\n  //播放列表只有一首歌时单曲循环\\n  if (playList.length === 1) {\\n    handleLoop();\\n    return;\\n  }\\n  let index = currentIndex + 1;\\n  if (index === playList.length) index = 0;\\n  if (!playing) togglePlayingDispatch(true);\\n  changeCurrentIndexDispatch(index);\\n};\\n\\n\")])])]),t(\"p\",[n._v(\"这部分逻辑传给normalPlayer:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//传递给normalPlayer\\nhandlePrev={handlePrev}\\nhandleNext={handleNext}\\n\\n\")])])]),t(\"p\",[n._v(\"在normalPlayer中绑定按钮点击事件:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('const { toggleFullScreen, clickPlaying, onProgressChange, handlePrev, handleNext } = props;\\n\\n//JSX\\n<div className=\"icon i-left\" onClick={handlePrev}>\\n  <i className=\"iconfont\">&#xe6e1;</i>\\n</div>\\n//...\\n<div className=\"icon i-right\" onClick={handleNext}>\\n  <i className=\"iconfont\">&#xe718;</i>\\n</div>\\n\\n')])])]),t(\"p\",[n._v(\"现在我们把父组件中控制歌曲播放的的逻辑完善一下:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//记录当前的歌曲，以便于下次重渲染时比对是否是一首歌\\nconst [preSong, setPreSong] = useState({});\\n\\n//先mock一份currentIndex\\nuseEffect(() => {\\n  changeCurrentIndexDispatch(0);\\n}, [])\\n\\nuseEffect(() => {\\n  if (\\n    !playList.length ||\\n    currentIndex === -1 ||\\n    !playList[currentIndex] ||\\n    playList[currentIndex].id === preSong.id \\n  )\\n    return;\\n  let current = playList[currentIndex];\\n  changeCurrentDispatch(current);//赋值currentSong\\n  setPreSong(current);\\n  audioRef.current.src = getSongUrl(current.id);\\n  setTimeout(() => {\\n    audioRef.current.play();\\n  });\\n  togglePlayingDispatch(true);//播放状态\\n  setCurrentTime(0);//从头开始播放\\n  setDuration((current.dt / 1000) | 0);//时长\\n}, [playList, currentIndex]);\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"播放模式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#播放模式\"}},[n._v(\"#\")]),n._v(\" 播放模式\")]),n._v(\" \"),t(\"p\",[n._v(\"分三种: 单曲循环、顺序循环和随机播放\")]),n._v(\" \"),t(\"p\",[n._v(\"我们先在Player/index.js，也就是父组件中写相应逻辑：\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//从props中取redux数据和dispatch方法\\nconst {\\n  playing,\\n  currentSong:immutableCurrentSong,\\n  currentIndex,\\n  playList:immutablePlayList,\\n  mode,//播放模式\\n  sequencePlayList:immutableSequencePlayList,//顺序列表\\n  fullScreen\\n} = props;\\n\\nconst {\\n  togglePlayingDispatch,\\n  changeCurrentIndexDispatch,\\n  changeCurrentDispatch,\\n  changePlayListDispatch,//改变playList\\n  changeModeDispatch,//改变mode\\n  toggleFullScreenDispatch\\n} = props;\\n\\nconst playList = immutablePlayList.toJS();\\nconst sequencePlayList = immutableSequencePlayList.toJS();\\nconst currentSong = immutableCurrentSong.toJS();\\n\\n\")])])]),t(\"p\",[n._v(\"现在的需求是点击normalPlayer最左边的按钮，能够切换播放模式，我们现在在父组件写相应的逻辑。\")]),n._v(\" \"),t(\"p\",[n._v(\"顺便说一句。不知道你发现没有: 关于业务逻辑的部分都是在父组件完成然后直接传给子组件，而子组件虽然也有自己的状态，但大部分是控制UI层面的，逻辑都是从props中接受， 这也是在潜移默化中给大家展示了UI和逻辑分离的组件设计模式。通过分离关注点，解耦不同的模块，能够大量节省开发和维护成本。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//Player/index\\nconst changeMode = () => {\\n  let newMode = (mode + 1) % 3;\\n  if (newMode === 0) {\\n    //顺序模式\\n    changePlayListDispatch(sequencePlayList);\\n    let index = findIndex(currentSong, sequencePlayList);\\n    changeCurrentIndexDispatch(index);\\n  } else if (newMode === 1) {\\n    //单曲循环\\n    changePlayListDispatch(sequencePlayList);\\n  } else if (newMode === 2) {\\n    //随机播放\\n    let newList = shuffle(sequencePlayList);\\n    let index = findIndex(currentSong, newList);\\n    changePlayListDispatch(newList);\\n    changeCurrentIndexDispatch(index);\\n  }\\n  changeModeDispatch(newMode);\\n};\\n\\n\")])])]),t(\"p\",[n._v(\"目前的播放列表是在组件内mock的，现在已经不太合适，我们把mock列表移动到reducer中的defaultState中，这里就不展示了，要注意playList和sequenceList都要mock并且mock一样的数据。\")]),n._v(\" \"),t(\"p\",[n._v(\"接下来我们来解释一下changeMode中的内容,findIndex方法用来找出歌曲在对应列表中的索引，shuffle方法用来打乱一个列表，达成随机列表的效果，这两个函数都定义在api/utils.js中。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"function getRandomInt(min, max) {\\n  return Math.floor(Math.random() * (max - min + 1) + min);\\n}\\n// 随机算法\\nexport function shuffle(arr) {\\n  let new_arr = [];\\n  arr.forEach(item => {\\n    new_arr.push(item);\\n  });\\n  for (let i = 0; i < new_arr.length; i++) {\\n    let j = getRandomInt(0, i);\\n    let t = new_arr[i];\\n    new_arr[i] = new_arr[j];\\n    new_arr[j] = t;\\n  }\\n  return new_arr;\\n}\\n\\n// 找到当前的歌曲索引\\nexport const findIndex = (song, list) => {\\n  return list.findIndex(item => {\\n    return song.id === item.id;\\n  });\\n};\\n\\n\")])])]),t(\"p\",[n._v(\"引入到父组件:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('import { getSongUrl, isEmptyObject, shuffle, findIndex } from \"../../api/utils\";\\n\\n')])])]),t(\"p\",[n._v(\"接下来我们给normalPlayer传入:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"<NormalPlayer\\n  //...\\n  mode={mode}\\n  changeMode={changeMode}\\n/>\\n\\n\")])])]),t(\"p\",[n._v(\"现在就需要对normalPlayer做一些事情了：\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('//Operator标签下\\n<div className=\"icon i-left\" onClick={changeMode}>\\n  <i\\n    className=\"iconfont\"\\n    dangerouslySetInnerHTML={{ __html: getPlayMode() }}\\n  ></i>\\n</div>\\n\\n')])])]),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('//getPlayMode方法\\nconst getPlayMode = () => {\\n  let content;\\n  if (mode === playMode.sequence) {\\n    content = \"&#xe625;\";\\n  } else if (mode === playMode.loop) {\\n    content = \"&#xe653;\";\\n  } else {\\n    content = \"&#xe61b;\";\\n  }\\n  return content;\\n};\\n\\n\\n')])])]),t(\"p\",[n._v(\"其中playMode常量我们已经定义过，直接引入:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"import { playMode } from '../../../api/config';\\n\\n\")])])]),t(\"p\",[n._v(\"现在大家打开redux-devtools可以看到数据的变化，下面是随机模式\")]),n._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/16/16fac33621418e87?w=590&h=522&f=jpeg&s=65672\",alt:\"\"}})]),n._v(\" \"),t(\"p\",[n._v(\"可以看到playList现在已经乱序了。\")]),n._v(\" \"),t(\"p\",[n._v(\"功能是实现了，但是只有一个图标放在这里，可能很多用户不知道是什么意思，如果能够文字提示一下，体验会更好一些。废话不多说，直接开始封装崭新的Toast组件，这里只是由于是侧重项目， 不可能将Toast的功能面面俱到，只是让大家体会一下封装的过程，以此来提升自己的内功，这也是我不用UI框架的原因。\")]),n._v(\" \"),t(\"p\",[n._v(\"在baseUI目录下新建Toast文件夹:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//Toast/index.js\\nimport React, {useState, useImperativeHandle, forwardRef} from 'react';\\nimport styled from 'styled-components';\\nimport { CSSTransition } from 'react-transition-group';\\nimport style from '../../assets/global-style';\\n\\nconst ToastWrapper = styled.div`\\n  position: fixed;\\n  bottom: 0;\\n  z-index: 1000;\\n  width: 100%;\\n  height: 50px;\\n  /* background: ${style[\\\"highlight-background-color\\\"]}; */\\n  &.drop-enter{\\n    opacity: 0;\\n    transform: translate3d(0, 100%, 0);\\n  }\\n  &.drop-enter-active{\\n    opacity: 1;\\n    transition: all 0.3s;\\n    transform: translate3d(0, 0, 0);\\n  }\\n  &.drop-exit-active{\\n    opacity: 0;\\n    transition: all 0.3s;\\n    transform: translate3d(0, 100%, 0);\\n  }\\n  .text{\\n    line-height: 50px;\\n    text-align: center;\\n    color: #fff;\\n    font-size: ${style[\\\"font-size-l\\\"]};\\n  }\\n`\\n//外面组件需要拿到这个函数组件的ref，因此用forwardRef\\nconst Toast = forwardRef((props, ref) => {\\n  const [show, setShow] = useState(false);\\n  const [timer, setTimer] = useState('');\\n  const {text} = props;\\n  //外面组件拿函数组件ref的方法，用useImperativeHandle这个hook\\n  useImperativeHandle(ref, () => ({\\n    show() {\\n      // 做了防抖处理\\n      if(timer) clearTimeout(timer);\\n      setShow(true);\\n      setTimer(setTimeout(() => {\\n        setShow(false)\\n      }, 3000));\\n    }\\n  }))\\n  return (\\n    <CSSTransition in={show} timeout={300} classNames=\\\"drop\\\" unmountOnExit>\\n      <ToastWrapper>\\n        <div className=\\\"text\\\">{text}</div>\\n      </ToastWrapper>\\n    </CSSTransition>\\n  )\\n});\\n\\nexport default React.memo(Toast);\\n\\n\")])])]),t(\"p\",[n._v(\"现在放到Player/index.js中使用:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('import Toast from \"./../../baseUI/toast/index\";\\n\\n//...\\nconst [modeText, setModeText] = useState(\"\");\\n\\nconst toastRef = useRef();\\n\\n//...\\nconst changeMode = () => {\\n  let newMode = (mode + 1) % 3;\\n  if (newMode === 0) {\\n    //...\\n    setModeText(\"顺序循环\");\\n  } else if (newMode === 1) {\\n    //...\\n    setModeText(\"单曲循环\");\\n  } else if (newMode === 2) {\\n    //...\\n    setModeText(\"随机播放\");\\n  }\\n  changeModeDispatch(newMode);\\n  toastRef.current.show();\\n};\\n\\n//JSX\\nreturn (\\n  <div>\\n    //...\\n    <Toast text={modeText} ref={toastRef}></Toast>  \\n  </div>\\n)\\n\\n')])])]),t(\"p\",[n._v(\"效果:\")]),n._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/16/16fac3421b9d1c07?w=372&h=133&f=gif&s=185323\",alt:\"\"}})]),n._v(\" \"),t(\"p\",[n._v(\"那现在还有最后一个问题需要处理，就是歌曲播放完了之后，紧接着需要怎么处理。\")]),n._v(\" \"),t(\"p\",[n._v(\"我们回到父组件，把这个处理逻辑写在audio标签的onEnded事件回调中:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"<audio\\n  ref={audioRef}\\n  onTimeUpdate={updateTime}\\n  onEnded={handleEnd}\\n></audio>\\n\\n\")])])]),t(\"p\",[n._v(\"由于之前封装了下一曲和单曲循环的逻辑，这里就非常简单了。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"import { playMode } from '../../api/config';\\n//...\\nconst handleEnd = () => {\\n  if (mode === playMode.loop) {\\n    handleLoop();\\n  } else {\\n    handleNext();\\n  }\\n};\\n\\n\")])])]),t(\"p\",[n._v(\"OK，到这里，mini/全屏播放器基本的功能都完成了！\")])])}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}