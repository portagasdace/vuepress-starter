{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[314],{667:function(e,t,n){\"use strict\";n.r(t);var a=n(42),l=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[n(\"blockquote\",[n(\"p\",[e._v(\"本节代码对应 GitHub 分支: chapter7\")])]),e._v(\" \"),n(\"p\",[n(\"a\",{attrs:{href:\"https://github.com/sanyuan0704/react-cloud-music/tree/chapter7\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"仓库传送门\"),n(\"OutboundLink\")],1)]),e._v(\" \"),n(\"h1\",{attrs:{id:\"交互逻辑实现\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#交互逻辑实现\"}},[e._v(\"#\")]),e._v(\" 交互逻辑实现\")]),e._v(\" \"),n(\"p\",[e._v(\"JS 交互主要是滑动屏幕时的逻辑，现在有了 scroll 基础组件，我们可以直接写在 onScroll 的回调中。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"<Scroll onScroll={handleScroll} ref={songScroll}>\\n//...\\n\\n\")])])]),n(\"p\",[e._v(\"这里面需要一些 DOM 操作，我们先把 DOM 对象取出来。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('import { HEADER_HEIGHT } from \"./../../api/config\";\\nconst handleScroll = pos => {\\n    let height = initialHeight.current;\\n    const newY = pos.y;\\n    const imageDOM = imageWrapper.current;\\n    const buttonDOM = collectButton.current;\\n    const headerDOM = header.current;\\n    const layerDOM = layer.current;\\n    const minScrollY = -(height - OFFSET) + HEADER_HEIGHT;\\n\\n    // 指的是滑动距离占图片高度的百分比\\n    const percent = Math.abs (newY /height);\\n\\n}\\n\\n')])])]),n(\"p\",[e._v(\"说明：在歌手页的布局中，歌单列表其实是没有自己的背景的，layerDOM 其实是起一个遮罩的作用，给歌单内容提供白色背景 因此在处理的过程中，随着内容的滚动，遮罩也跟着移动。\")]),e._v(\" \"),n(\"p\",[e._v(\"滑动主要分三种情况:\")]),e._v(\" \"),n(\"ol\",[n(\"li\",[e._v(\"处理往下拉的情况，效果：图片放大，按钮跟着偏移\")])]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('if (newY > 0) {\\n  imageDOM.style [\"transform\"] = `scale (${1 + percent})`;\\n  buttonDOM.style [\"transform\"] = `translate3d (0, ${newY}px, 0)`;\\n  layerDOM.style.top = `${height - OFFSET + newY}px`;\\n} \\n\\n')])])]),n(\"ol\",{attrs:{start:\"2\"}},[n(\"li\",[e._v(\"往上滑动，但是遮罩还没超过 Header 部分\")])]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('else if (newY >= minScrollY) {\\n  layerDOM.style.top = `${height - OFFSET - Math.abs (newY)}px`;\\n  // 这时候保证遮罩的层叠优先级比图片高，不至于被图片挡住\\n  layerDOM.style.zIndex = 1;\\n  imageDOM.style.paddingTop = \"75%\";\\n  imageDOM.style.height = 0;\\n  imageDOM.style.zIndex = -1;\\n  // 按钮跟着移动且渐渐变透明\\n  buttonDOM.style [\"transform\"] = `translate3d (0, ${newY}px, 0)`;\\n  buttonDOM.style [\"opacity\"] = `${1 - percent * 2}`;\\n} \\n\\n')])])]),n(\"ol\",{attrs:{start:\"3\"}},[n(\"li\",[e._v(\"往上滑动，但是遮罩超过 Header 部分\")])]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"else if (newY < minScrollY) {\\n  // 往上滑动，但是超过 Header 部分\\n  layerDOM.style.top = `${HEADER_HEIGHT - OFFSET}px`;\\n  layerDOM.style.zIndex = 1;\\n  // 防止溢出的歌单内容遮住 Header\\n  headerDOM.style.zIndex = 100;\\n  // 此时图片高度与 Header 一致\\n  imageDOM.style.height = `${HEADER_HEIGHT}px`;\\n  imageDOM.style.paddingTop = 0;\\n  imageDOM.style.zIndex = 99;\\n}\\n\\n\")])])]),n(\"p\",[e._v(\"现在终于可以达到一个比较好的交互效果了。但是别忘了，handleScroll 作为一个传给子组件的方法，我们需要用 useCallback 进行包裹，防止不必要的重渲染。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"const handleScroll = useCallback (pos => {\\n  // 具体代码\\n}, []);\\n\\n\")])])])])}),[],!1,null,null,null);t.default=l.exports}}]);","extractedComments":[]}