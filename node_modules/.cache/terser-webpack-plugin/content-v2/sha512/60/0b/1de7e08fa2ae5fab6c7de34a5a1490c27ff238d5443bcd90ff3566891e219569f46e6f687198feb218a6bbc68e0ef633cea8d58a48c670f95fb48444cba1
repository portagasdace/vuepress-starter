{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{593:function(e,t,a){\"use strict\";a.r(t);var s=a(42),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"实战篇-6-身份验证实现-使用-hapi-auth-jwt2\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实战篇-6-身份验证实现-使用-hapi-auth-jwt2\"}},[e._v(\"#\")]),e._v(\" 实战篇 6：身份验证实现 —— 使用 hapi-auth-jwt2\")]),e._v(\" \"),a(\"p\",[e._v(\"前一节，我们基本了解了 JWT 的技术特点、内容构成与安全校验等理论。这一节，我们先抛开小程序的场景使用特殊性，学习一种更为基础通用的 JWT 用户身份验证实现。小程序登录、微信微博第三方授权登录、短信验证码登录等，都是在该基础之上的二次开发。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"基于-jwt-的通用身份验证流程\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基于-jwt-的通用身份验证流程\"}},[e._v(\"#\")]),e._v(\" 基于 JWT 的通用身份验证流程\")]),e._v(\" \"),a(\"p\",[e._v(\"在实际的项目应用场景中，JWT 的身份验证流程大致如下：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"用户使用用户名密码、或第三方授权登录后，请求应用服务器；\")]),e._v(\" \"),a(\"li\",[e._v(\"服务器验证用户信息是否合法；\")]),e._v(\" \"),a(\"li\",[e._v(\"对通过验证的用户，签发一个包涵用户 ID、其他少量用户信息（比如用户角色）以及失效时间的 JWT token；\")]),e._v(\" \"),a(\"li\",[e._v(\"客户端存储 JWT token，并在调用需要身份验证的接口服务时，带上这个 JWT token 值；\")]),e._v(\" \"),a(\"li\",[e._v(\"服务器验证 JWT token 的签发合法性，时效性，验证通过后，返回业务数据。\")])]),e._v(\" \"),a(\"h2\",{attrs:{id:\"使用-jsonwebtoken-签发-jwt\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-jsonwebtoken-签发-jwt\"}},[e._v(\"#\")]),e._v(\" 使用 jsonwebtoken 签发 JWT\")]),e._v(\" \"),a(\"p\",[e._v(\"jsonwebtoken 是 Node.js 生态里用于签发与校验 JWT 的流行插件，本章节我们借助该插件来完成 JWT 字符串的生成签发。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"npm i jsonwebtoken\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"jwt-sign-签发\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jwt-sign-签发\"}},[e._v(\"#\")]),e._v(\" jwt.sign 签发\")]),e._v(\" \"),a(\"p\",[e._v(\"JWT 的签发语法是 \"),a(\"code\",[e._v(\"jwt.sign(payload, secretOrPrivateKey, [options, callback])\")]),e._v(\"。默认的签发算法基于 HS256 (HMAC SHA256)，可以在 options 参数的 \"),a(\"code\",[e._v(\"algorithm\")]),e._v(\" 另行修改。JWT 签发规范中的一些标准保留字段比如 \"),a(\"code\",[e._v(\"exp\")]),e._v(\"，\"),a(\"code\",[e._v(\"nbf\")]),e._v(\"，\"),a(\"code\",[e._v(\"aud\")]),e._v(\"，\"),a(\"code\",[e._v(\"sub\")]),e._v(\"，\"),a(\"code\",[e._v(\"iss\")]),e._v(\" 等都没有默认值，可以一并在 payload 参数中按需声明使用，亦可以在第三个参数 options 中，通过 \"),a(\"code\",[e._v(\"expiresIn\")]),e._v(\"，\"),a(\"code\",[e._v(\"notBefore\")]),e._v(\"，\"),a(\"code\",[e._v(\"audience\")]),e._v(\"，\"),a(\"code\",[e._v(\"subject\")]),e._v(\"，\"),a(\"code\",[e._v(\"issuer\")]),e._v(\" 来分别赋值，但是不允许在两处同时声明。\")]),e._v(\" \"),a(\"p\",[e._v(\"下面是一个最简单的默认签发，1 小时后失效。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"const jwt = require('jsonwebtoken');\\n// 签发一条 1 小时后失效的 JWT\\nconst token = jwt.sign(\\n  {\\n    foo: 'bar',\\n    exp: Math.floor(Date.now() / 1000) + (60 * 60),\\n  },\\n  'your-secret'\\n);\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"实现接口-post-users-createjwt\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现接口-post-users-createjwt\"}},[e._v(\"#\")]),e._v(\" 实现接口 POST /users/createJWT\")]),e._v(\" \"),a(\"p\",[e._v(\"继续完善我们的项目案例，实际应用中的 JWT 签发，我们会把便于识别用户的 userId 的信息，签发在 payload 中，并同时给予一个失效时间。\")]),e._v(\" \"),a(\"p\",[e._v(\"在 routes 目录下，新增一个 users.js 的路由，并增加一个 JWT 测试性质的签发接口定义 POST /users/createJWT。app.js 中记得将 users 路由模块注册引入。\")]),e._v(\" \"),a(\"p\",[e._v(\"注意: \"),a(\"em\",[e._v(\"jwt.sign 的第二个参数 secret 是一个重要的敏感信息，可以通过 .env 的配置 JWT_SECRET 来分离。\")])]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// routes/users.js\\n\\nconst JWT = require('jsonwebtoken');\\n\\nconst GROUP_NAME = 'users';\\n\\nmodule.exports = [{\\n  method: 'POST',\\n  path: `/${GROUP_NAME}/createJWT`,\\n  handler: async (request, reply) => {\\n    const generateJWT = (jwtInfo) => {\\n      const payload = {\\n        userId: jwtInfo.userId,\\n        exp: Math.floor(new Date().getTime() / 1000) + 7 * 24 * 60 * 60,\\n      };\\n      return JWT.sign(payload, process.env.JWT_SECRET);\\n    };\\n    reply(generateJWT({\\n      userId: 1,\\n    }));\\n  },\\n  config: {\\n    tags: ['api', GROUP_NAME],\\n    description: '用于测试的用户 JWT 签发',\\n    auth: false, // 约定此接口不参与 JWT 的用户验证，会结合下面的 hapi-auth-jwt 来使用\\n  },\\n}];\\n\\n\\n\")])])]),a(\"p\",[e._v(\"访问 swagger-ui 测试 JWT 签发，可以得到 JWT 的测试签发结果。\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsImV4cCI6MTUzNTMyMjc0NSwiaWF0IjoxNTM0NzE3OTQ1fQ.6tOdn2R82bxJbXjAnwU5g4g9EKqGNe-qo4qCo6UZnQ4\")])]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/8/20/1655452f9bba8239?w=1476&h=840&f=jpeg&s=155119\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"我们可以通过 \"),a(\"a\",{attrs:{href:\"https://jwt.io\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://jwt.io\"),a(\"OutboundLink\")],1),e._v(\" 来 decode JWT 中的 payload 信息，看能否拿到 userId。\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/8/20/1655454c39e1d022?w=1720&h=878&f=jpeg&s=142959\",alt:\"\"}})]),e._v(\" \"),a(\"h2\",{attrs:{id:\"hapi-auth-jwt2-接口用户验证\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hapi-auth-jwt2-接口用户验证\"}},[e._v(\"#\")]),e._v(\" hapi-auth-jwt2 接口用户验证\")]),e._v(\" \"),a(\"p\",[e._v(\"接下来我们通过 hapi-auth-jwt2 插件，来赋予系统中的部分接口，需要用户登录授权后才能访问的能力。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_1-安装-hapi-auth-jwt2-插件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-安装-hapi-auth-jwt2-插件\"}},[e._v(\"#\")]),e._v(\" 1. 安装 hapi-auth-jwt2 插件\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"npm i hapi-auth-jwt2@7\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_2-引入-hapi-auth-jwt2-配置\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-引入-hapi-auth-jwt2-配置\"}},[e._v(\"#\")]),e._v(\" 2. 引入 hapi-auth-jwt2 配置\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"├── plugins                       # hapi 插件配置\\n│ ├── hapi-auth-jwt2.js           # jwt 配置插件\\n\\n\")])])]),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"const config = require('../config');\\n\\nconst validate = (decoded, request, callback) => {\\n  let error;\\n  /*\\n    接口 POST /users/createJWT 中的 jwt 签发规则\\n\\n    const payload = {\\n      userId: jwtInfo.userId,\\n      exp: Math.floor(new Date().getTime() / 1000) + 7 * 24 * 60 * 60,\\n    };\\n    return JWT.sign(payload, process.env.JWT_SECRET);\\n  */\\n\\n  // decoded 为 JWT payload 被解码后的数据\\n  const { userId } = decoded;\\n\\n  if (!userId) {\\n    return callback(error, false, userId);\\n  }\\n  const credentials = {\\n    userId,\\n  };\\n  // 在路由接口的 handler 通过 request.auth.credentials 获取 jwt decoded 的值\\n  return callback(error, true, credentials);\\n};\\n\\nmodule.exports = (server) => {\\n  server.auth.strategy('jwt', 'jwt', {\\n    // 需要自行在 config/index.js 中添加 jwtSecret 的配置，并且通过 process.env.JWT_SECRET 来进行 .git 版本库外的管理。\\n    key: config.jwtSecret,\\n    validateFunc: validate,\\n  });\\n  server.auth.default('jwt');\\n};\\n\\n\\n\")])])]),a(\"p\",[e._v(\"在 app.js 中注册 hapi-auth-jwt2 插件。\")]),e._v(\" \"),a(\"p\",[e._v(\"hapi-auth-jwt2 的注册使用方式与其他插件略有不同，是在插件完成 register 注册之后，通过获取 server 实例后才完成最终的配置，所以，在代码书写上，存在一个先后顺序问题。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"  const hapiAuthJWT2 = require('hapi-auth-jwt2');\\n  const pluginHapiAuthJWT2 = require('./plugins/hapi-auth-jwt2');\\n\\n  const init = async () => {\\n    // ... 省略上下文\\n    await server.register([\\n      hapiAuthJWT2\\n    ])\\n    pluginHapiAuthJWT2(server);\\n    // ... 省略上下文\\n  }\\n\\n\")])])]),a(\"p\",[e._v(\"一旦在 app.js 中，引入 hapi-auth-jwt 插件后，所有的接口都默认开启 JWT 认证，需要我们在接口调用的过程中，在 header 中添加带有 JWT 的 authorization 的字段。此时通过 Swagger 文档访问我们先前的 shops 任意接口，由于没有传输 JWT ，接口都会返回 \"),a(\"code\",[e._v(\"401\")]),e._v(\" 的错误。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('{\\n  \"statusCode\": 401,\\n  \"error\": \"Unauthorized\",\\n  \"message\": \"Missing authentication\"\\n}\\n\\n')])])]),a(\"p\",[e._v(\"如果希望一些特定接口不通过 JWT 验证，比如店铺和商品列表并不希望用户登录后才能访问。可以在 router 中的 config 定义 auth=false 的配置，再通过 Swagger 文档试试对应配置的接口\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"  config: {\\n    auth: false,\\n  }\\n\\n\")])])]),a(\"p\",[e._v(\"同步更新 validate 中针对 authorization 的 header 入参校验，在 Swagger 文档中也会同步自动更新。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"config: {\\n  validate: {\\n    headers: Joi.object({\\n      authorization: Joi.string().required(),\\n    }).unknown(),\\n  }\\n}\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_3-迅速重构整理公共的-header-定义\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-迅速重构整理公共的-header-定义\"}},[e._v(\"#\")]),e._v(\" 3. 迅速重构整理公共的 header 定义\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"├── utils                       # hapi 插件配置\\n│ ├── router-helper.js          # 一个 helper 的工具类来实现公共代码\\n\\n\")])])]),a(\"p\",[e._v(\"utils/router-helper.js\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"const Joi = require('joi')\\n\\nconst jwtHeaderDefine = {\\n  headers: Joi.object({\\n    authorization: Joi.string().required(),\\n  }).unknown(),\\n}\\n\\nmodule.exports = { jwtHeaderDefine }\\n\\n\")])])]),a(\"p\",[e._v(\"在需要使用到 authorization 的 header 配置处只需要使用如下语法即可：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"config: {\\n  validate: {\\n    ...jwtHeaderDefine\\n  }\\n}\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_4-handler-中使用-jwt-的获取-userid\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-handler-中使用-jwt-的获取-userid\"}},[e._v(\"#\")]),e._v(\" 4. handler 中使用 JWT 的获取 userId\")]),e._v(\" \"),a(\"p\",[e._v(\"上文 3.2 中所提到的 plugins/hapi-auth-jwt2.js， 会通过 callback(error, true, credentials) 的第三个参数，将 JWT 解码过所需要露出的数据字段与值追加到 \"),a(\"code\",[e._v(\"request.auth\")]),e._v(\" 中，然后在路由 handler 的生命周期中，通过 \"),a(\"code\",[e._v(\"request.auth.credentials\")]),e._v(\" 来获取对应的信息。\")]),e._v(\" \"),a(\"p\",[e._v(\"我们使用 POST /users/createJWT 来生成一段 JWT。 再通过 tests/hello-hapi.js 的接口 tests/ 做一个实验性验证。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"const { jwtHeaderDefine } = require('../utils/router-helper');\\n\\nmodule.exports = [\\n  {\\n    method: 'GET',\\n    path: '/',\\n    handler: (request, reply) => {\\n      /*\\n      plugins/hapi-auth-jwt2.js 中的 credentials 定义\\n\\n      const credentials = {\\n        userId,\\n      };\\n      */\\n      console.log(request.auth.credentials); // 控制台输出 { userId: 1}\\n      reply('hello hapi');\\n    },\\n    config: {\\n      tags: ['api', 'tests'],\\n      description: '测试hello-hapi',\\n      validate: {\\n        ...jwtHeaderDefine, // 增加需要 jwt auth 认证的接口 header 校验\\n      },\\n    },\\n  },\\n];\\n\\n\")])])]),a(\"p\",[e._v(\"获取到其中的 userId 数据，后续就可以继续完成我们的业务逻辑流程了。\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[a(\"strong\",[e._v(\"GitHub 参考代码\")]),e._v(\" \"),a(\"a\",{attrs:{href:\"https://github.com/yeshengfei/hapi-tutorial/tree/master/chapter10/hapi-tutorial-1\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"chapter10/hapi-tutorial-1\"),a(\"OutboundLink\")],1)])]),e._v(\" \"),a(\"h2\",{attrs:{id:\"小结\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[e._v(\"#\")]),e._v(\" 小结\")]),e._v(\" \"),a(\"p\",[e._v(\"关键词：hapi-auth-jwt2，JWT 签发，JWT handler 解码\")]),e._v(\" \"),a(\"p\",[e._v(\"本小节，我们通过实现 POST /users/createJWT 的方法，来掌握 JWT 的签发实现。并且利用 hapi-auth-jwt2 插件，在不对路由配置做任何修改的前提下，来对系统中的所有接口统一赋能 JWT 用户验证。不需要验证的接口则通过 config.auth = false 的方式来标记放行。利用插件统一的用户验证机制，能够帮助我们更好地聚焦业务实现的本身。\")]),e._v(\" \"),a(\"p\",[e._v(\"思考：我们利用 swagger-ui 的调试功能，以几秒的时间间隔，从 /users/createJWT，先后获取两个不同的 JWT。最早获取的第一个 JWT，在当下的系统实现中，会否因为第二个 JWT 的签发而失效？背后的原因本质又是什么？\")]),e._v(\" \"),a(\"p\",[a(\"strong\",[e._v(\"本小节参考代码汇总\")])]),e._v(\" \"),a(\"p\",[e._v(\"hapi-auth-jwt2 实现 JWT 用户身份验证： \"),a(\"a\",{attrs:{href:\"https://github.com/yeshengfei/hapi-tutorial/tree/master/chapter10/hapi-tutorial-1\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"chapter10/hapi-tutorial-1\"),a(\"OutboundLink\")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);","extractedComments":[]}