{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[354],{711:function(t,e,r){\"use strict\";r.r(e);var n=r(42),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[r(\"h2\",{attrs:{id:\"导读\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#导读\"}},[t._v(\"#\")]),t._v(\" 导读\")]),t._v(\" \"),r(\"p\",[t._v(\"本节标题：「建造毛坯」- 双端路由同构\")]),t._v(\" \"),r(\"p\",[t._v(\"本节主旨： 继续以发现问题，分析问题，解决问题的思路，来实现多路由的双端同构，重点在于服务端和客户端如何处理\")]),t._v(\" \"),r(\"p\",[t._v(\"本节配套代码：\")]),t._v(\" \"),r(\"p\",[r(\"a\",{attrs:{href:\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr2\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr2\"),r(\"OutboundLink\")],1)]),t._v(\" \"),r(\"h1\",{attrs:{id:\"正文\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#正文\"}},[t._v(\"#\")]),t._v(\" 正文\")]),t._v(\" \"),r(\"p\",[t._v(\"前面几节我们实现了一个最基础的 \"),r(\"code\",[t._v(\"react ssr\")]),t._v(\"，同时也初步接触了同构，双端渲染同一个组件，服务端直出 \"),r(\"code\",[t._v(\"html\")]),t._v(\" 结构，浏览器端也能够实现组件事件的绑定。\")]),t._v(\" \"),r(\"p\",[t._v(\"然后又对应用骨架的开发体验做了一次重要的升级。\")]),t._v(\" \"),r(\"h1\",{attrs:{id:\"引出问题\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#引出问题\"}},[t._v(\"#\")]),t._v(\" 引出问题\")]),t._v(\" \"),r(\"p\",[t._v(\"虽然我们能展示页面并且执行事件，但我们还缺一个非常重要的能力。\")]),t._v(\" \"),r(\"p\",[t._v(\"那就是路由！\")]),t._v(\" \"),r(\"p\",[t._v(\"现在我们只有一个路由，属于服务端的根路由 \"),r(\"code\",[t._v(\"/\")]),t._v(\" 。\")]),t._v(\" \"),r(\"p\",[t._v(\"我们无论怎么在浏览器内改变路由地址都会显示同一个\"),r(\"code\",[t._v(\"UI\")]),t._v(\"。\")]),t._v(\" \"),r(\"p\",[t._v(\"当然我们的项目不可能只有一个页面，那我们该怎样来处理和维护项目的路由呢？\")]),t._v(\" \"),r(\"h1\",{attrs:{id:\"路由同构\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#路由同构\"}},[t._v(\"#\")]),t._v(\" 路由同构\")]),t._v(\" \"),r(\"p\",[t._v(\"由于我们打造的是基于服务端渲染的\"),r(\"code\",[t._v(\"React SPA\")]),t._v(\"应用开发骨架，所以服务端和客户端都需要对路由进行处理。\")]),t._v(\" \"),r(\"p\",[t._v(\"我们使用的是\"),r(\"code\",[t._v(\"React\")]),t._v(\",那前端路由肯定会使用\"),r(\"code\",[t._v(\"react-router\")]),t._v(\"来处理。\")]),t._v(\" \"),r(\"p\",[t._v(\"那服务端呢？服务端也需要单独维护一套路由？\")]),t._v(\" \"),r(\"p\",[t._v(\"当然不需要，这样不科学，更不合理。\")]),t._v(\" \"),r(\"p\",[t._v(\"在前几节我们初步接触了同构，现在解决这个问题的办法还是同构 - \"),r(\"code\",[t._v(\"路由同构\")]),t._v(\"，经过同构后服务端和客户端可以使用同一套路由。\")]),t._v(\" \"),r(\"h2\",{attrs:{id:\"同构思路与实现\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#同构思路与实现\"}},[t._v(\"#\")]),t._v(\" 同构思路与实现\")]),t._v(\" \"),r(\"p\",[t._v(\"先整体说下实现思路,让大家先有个基本的了解。\")]),t._v(\" \"),r(\"p\",[t._v(\"当第一请求页面的时候，服务端接收请求，根据当前的\"),r(\"code\",[t._v(\"path\")]),t._v(\"来查找具体的路由，然后根据路由得到具体的组件，然后将组件直出。\")]),t._v(\" \"),r(\"p\",[t._v(\"服务端直出后，页面由浏览器接管，后面的渲染执行就交给前端代码了。\")]),t._v(\" \"),r(\"p\",[t._v(\"思路很简单，接下来看下具体的实现和代码。\")]),t._v(\" \"),r(\"p\",[r(\"strong\",[t._v(\"创建一个客户端路由配置\")])]),t._v(\" \"),r(\"p\",[t._v(\"从\"),r(\"code\",[t._v(\"react router4\")]),t._v(\"开始，\"),r(\"code\",[t._v(\"react\")]),t._v(\"对路由做了重大的升级，将组件化的思想贯彻到底 - 一切皆组件。\")]),t._v(\" \"),r(\"p\",[t._v(\"所以从\"),r(\"code\",[t._v(\"v4\")]),t._v(\"版本开始不再是集中式路由配置，路由也是组件，也可以和 \"),r(\"code\",[t._v(\"UI\")]),t._v(\" 写在一起。\")]),t._v(\" \"),r(\"p\",[t._v(\"当然你仍然可以使用集中式的路由配置方式。\")]),t._v(\" \"),r(\"p\",[t._v(\"新增一个\"),r(\"code\",[t._v(\"Layout\")]),t._v(\"组件作为页面公共组件，在这个组件内进行路由渲染,当然也可以不用，这里也是为了让每个页面都有公共部分，无需每重复渲染。\")]),t._v(\" \"),r(\"p\",[t._v(\"具体用不用看自身的业务即可。\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"// ./src/client/app/layout.js\\n\\nimport React from 'react';\\nimport { Link } from 'react-router-dom';\\nexport default class Index extends React.Component{\\nconstructor(props){\\n super(props);\\n}\\nrender(){\\nreturn  <div>\\n    <Link to=\\\"/index\\\">首页</Link>  <Link to=\\\"/artice\\\">列表页</Link>\\n    <div>{this.props.children}</div>\\n    </div>\\n}\\n}\\n\\n\")])])]),r(\"p\",[r(\"strong\",[t._v(\"配置路由\")])]),t._v(\" \"),r(\"p\",[t._v(\"顺便简单介绍几个\"),r(\"code\",[t._v(\"react router4\")]),t._v(\"的路由组件 \"),r(\"code\",[t._v(\"Route, Switch, BrowserRouter\")])]),t._v(\" \"),r(\"p\",[r(\"code\",[t._v(\"Route 组件\")])]),t._v(\" \"),r(\"p\",[t._v(\"用于绑定组件和\"),r(\"code\",[t._v(\"path\")]),t._v(\"的关系,一般使用\"),r(\"code\",[t._v(\"component\")]),t._v(\"属性指定要渲染的组件,其中\"),r(\"code\",[t._v(\"exact\")]),t._v(\"属性表示是否是精确匹配模式，默认是\"),r(\"code\",[t._v(\"false\")]),t._v(\"。\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(' <Route path=\"/index\"  exact={true} component={Index}></Route>\\n\\n')])])]),r(\"p\",[r(\"code\",[t._v(\"Switch 组件\")])]),t._v(\" \"),r(\"p\",[t._v(\"使用该组件只会渲染第一个匹配到的路由，否则所有的路由都会渲染。\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v('  <Switch>\\n      <Route path=\"/\"  exact={true} component={Root}></Route>\\n      <Route path=\"/list\" exact={true} component={List}></Route>\\n  </Switch>\\n\\n')])])]),r(\"p\",[r(\"code\",[t._v(\"BrowserRouter 组件\")])]),t._v(\" \"),r(\"p\",[t._v(\"此组件相信大家都熟悉，基于浏览器 \"),r(\"code\",[t._v(\"History api\")]),t._v(\" 来达到浏览器地址和 \"),r(\"code\",[t._v(\"UI\")]),t._v(\" 同步的能力。\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v('<BrowserRouter>\\n    <Switch>\\n        <Route path=\"/root\"  exact={true} component={Root}></Route>\\n        <Route path=\"/list\" exact={true} component={List}></Route>\\n    </Switch>\\n</BrowserRouter>\\n\\n')])])]),r(\"p\",[r(\"strong\",[t._v(\"来看下完整的路由配置\")])]),t._v(\" \"),r(\"p\",[t._v(\"提取为独立的模块，方便维护和管理。\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"// ./src/client/router/route-config.js\\n//路由配置文件\\n\\nimport Index from '../pages/index';\\nimport List from '../pages/list';\\n\\nexport default [\\n    {\\n        path:'/index',\\n        component:Index,\\n        exact: true //是否精确匹配\\n    },\\n    {\\n        path: '/list',\\n        component: List,\\n        exact: true,\\n    }\\n]\\n\\n\\n\")])])]),r(\"p\",[r(\"strong\",[t._v(\"路由渲染入口配置\")])]),t._v(\" \"),r(\"p\",[t._v(\"遍历路由配置\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"// src/client/router/indxex.js\\n//路由配置文件\\n\\nimport Layout from '../app/layout';\\nimport React  from 'react';\\nimport { Route, Switch } from 'react-router-dom';\\n\\n//服务端也会用到所以通过参数的方式将配置传递进来\\nfunction App({routeList}) {\\n    return (\\n        <Layout> //公共组件\\n            <Switch>\\n                {\\n                    routeList.map(item=>{\\n                            return <Route key={item.path} {...item}></Route>\\n                    })\\n                }\\n            </Switch>\\n        </Layout>\\n    );\\n}\\n\\nexport default App;\\n\\n\\n\")])])]),r(\"p\",[r(\"strong\",[t._v(\"调整客户端组件渲染的入口代码\")])]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"//client/app/index.js\\n//浏览器端页面结构渲染入口\\n\\nimport React from 'react';\\nimport ReactDom from 'react-dom';\\nimport { BrowserRouter} from 'react-router-dom';\\nimport App from '../router/index';\\nimport routeList from '../router/route-config';//路由配置\\n\\n\\n//渲染入口\\nReactDom.hydrate(\\n   - <Index>\\n   + <BrowserRouter>\\n        <App routeList={routeList} />\\n   </BrowserRouter>//改成路由组件\\n, document.getElementById('root'))\\n\\n\\n\")])])]),r(\"p\",[t._v(\"到这里，客户端路由已生效，路由改变同时能够渲对应的组件。\")]),t._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/12/30/16f56eb3292a57c0?w=500&h=375&f=png&s=19009\",alt:\"\"}})]),t._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/12/30/16f56eb7840ab331?w=500&h=375&f=png&s=19308\",alt:\"\"}})]),t._v(\" \"),r(\"p\",[r(\"strong\",[t._v(\"现在客户端路由基本上已经配置好，服务端该如何处理？\")])]),t._v(\" \"),r(\"p\",[r(\"strong\",[t._v(\"服务端路由处理\")])]),t._v(\" \"),r(\"p\",[t._v(\"按照我们上面的思路，根据请求的 \"),r(\"code\",[t._v(\"path\")]),t._v(\"，去路由配置里查找对应的组件，得到匹配的组件后，服务端完成组件直出。\")]),t._v(\" \"),r(\"p\",[t._v(\"上面的思路没什么问题，不过\"),r(\"code\",[t._v(\"v4\")]),t._v(\"中 已经为我们提供了相关的组件来完成服务端的渲染。\")]),t._v(\" \"),r(\"p\",[r(\"code\",[t._v(\"StaticRouter\")])]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"import { StaticRouter} from 'react-router';\\n\\n\")])])]),r(\"p\",[t._v(\"该组件主要用于服务端渲染，可以帮助我们完成路由查找功能,无需再做手动匹配。\")]),t._v(\" \"),r(\"p\",[t._v(\"基本的思路是，将替换为无状态的。\")]),t._v(\" \"),r(\"p\",[t._v(\"将服务器上接收到的\"),r(\"code\",[t._v(\"path\")]),t._v(\"传递给此组件用来匹配，同时支持传入\"),r(\"code\",[t._v(\"context\")]),t._v(\"特性,此组件会自动匹配到目标组件进行渲染。\")]),t._v(\" \"),r(\"p\",[r(\"code\",[t._v(\"context\")]),t._v(\"属性是一个普通的\"),r(\"code\",[t._v(\"JavaScript\")]),t._v(\"对象。\")]),t._v(\" \"),r(\"p\",[t._v(\"在组件渲染时，可向该对象添加属性以存储有关渲染的信息，比如\"),r(\"code\",[t._v(\"302 404\")]),t._v(\"等结果状态，然后服务端可以针对不同的状态进行具体的响应处理。\")]),t._v(\" \"),r(\"p\",[t._v(\"对比来看\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"//客户端\\n<BrowserRouter>\\n      <App/>\\n</BrowserRouter>\\n     \\n// 服务端\\n<StaticRouter location={req.url} context={context}>   \\n        <App/>\\n</StaticRouter>\\n\\n\")])])]),r(\"p\",[r(\"strong\",[t._v(\"服务端渲染处理\")])]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"//引入客户端路由组件\\n//...\\nimport React from 'react';\\nimport { renderToString } from 'react-dom/server';\\nimport { StaticRouter, Route} from 'react-router';\\nimport App from '../../client/router/index';\\nimport routeList from '../../client/router/route-config';\\n\\n\\nexport default  (ctx,next)=>{\\n    \\n    //获得请求的 path\\n    const path = ctx.request.path;\\n    \\n    //渲染组件为 html 字符串\\n    const html = renderToString(<StaticRouter location={path}>\\n          <App routeList={routeList}></App>\\n    </StaticRouter>);\\n    ctx.body=`<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <title>my react ssr</title>\\n</head>\\n<body>\\n    <div id=\\\"root\\\">\\n       ${html}\\n    </div>\\n</body>\\n</html>\\n</body>\\n<script type=\\\"text/javascript\\\"  src=\\\"index.js\\\"><\\/script>\\n`;\\n\\n    return next();\\n}\\n\\n\")])])]),r(\"p\",[t._v(\"到这里我们已经实现了基本的双端路的同构，是不是很简单呢。^_^\")]),t._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/12/30/16f56f6c03bd5447?w=863&h=375&f=png&s=83817\",alt:\"\"}})]),t._v(\" \"),r(\"h2\",{attrs:{id:\"小结\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[t._v(\"#\")]),t._v(\" 小结\")]),t._v(\" \"),r(\"p\",[t._v(\"本节主要是了解和实现 \"),r(\"code\",[t._v(\"路由同构\")]),t._v(\"，整体来说比较简单，不过这也只是小试牛刀哦，后面还会更精彩。\")]),t._v(\" \"),r(\"p\",[t._v(\"本节代码已上传\")]),t._v(\" \"),r(\"p\",[r(\"a\",{attrs:{href:\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr2\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr2\"),r(\"OutboundLink\")],1)]),t._v(\" \"),r(\"p\",[t._v(\"感谢你的阅读。\")]),t._v(\" \"),r(\"p\",[t._v(\"如果有问题欢迎留言，也欢迎在留言区留下你的想法和思考。\")])])}),[],!1,null,null,null);e.default=a.exports}}]);","extractedComments":[]}