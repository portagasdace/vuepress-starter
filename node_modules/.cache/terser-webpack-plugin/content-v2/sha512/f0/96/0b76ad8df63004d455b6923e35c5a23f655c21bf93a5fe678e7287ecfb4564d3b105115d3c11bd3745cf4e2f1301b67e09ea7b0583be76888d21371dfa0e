{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[346],{702:function(e,t,n){\"use strict\";n.r(t);var a=n(42),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[n(\"h2\",{attrs:{id:\"导读\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#导读\"}},[e._v(\"#\")]),e._v(\" 导读\")]),e._v(\" \"),n(\"p\",[e._v(\"本节标题：对比业内已有框架的实现\")]),e._v(\" \"),n(\"p\",[e._v(\"本节主旨：对比业内 next.js，egg-react-ssr 的实现方案，验证自身实现的标准性\")]),e._v(\" \"),n(\"h1\",{attrs:{id:\"正文\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#正文\"}},[e._v(\"#\")]),e._v(\" 正文\")]),e._v(\" \"),n(\"p\",[n(\"code\",[e._v(\"react ssr\")]),e._v(\" 到现在已经不是新技术，技术原理也不复杂，但是真要自己弄出一个完整的轮子并非易事，有非常多的细节和边边角角需要处理。\")]),e._v(\" \"),n(\"p\",[e._v(\"所以除了自己来造轮子，我们还可以站在巨人的肩膀上，直接使用业内现成的框架进行开发。\")]),e._v(\" \"),n(\"p\",[e._v(\"造轮子可以，但是不要闭门造车，所以本节我们来了解下业内框架他们是怎样实现的，也侧面的看下我们已有功能的实现是否合理，是为了验证我们的方案，更是学习。\")]),e._v(\" \"),n(\"p\",[e._v(\"这里主要来看下\"),n(\"code\",[e._v(\"next.js\")]),e._v(\"和\"),n(\"code\",[e._v(\"egg-react-ssr\")]),e._v(\"的实现。\")]),e._v(\" \"),n(\"p\",[e._v(\"当然还有\"),n(\"code\",[e._v(\"umi\")]),e._v(\"，不过\"),n(\"code\",[e._v(\"umi ssr\")]),e._v(\"代码核心部分也是\"),n(\"code\",[e._v(\"egg-react-ssr\")]),e._v(\"团队贡献的代码，所以就不做对比了。\")]),e._v(\" \"),n(\"p\",[e._v(\"另外在客户端组件渲染时会使用服务端直出的数据问题，也是参考\"),n(\"code\",[e._v(\"egg-react-ssr\")]),e._v(\"来实现的,只是细节不同。\")]),e._v(\" \"),n(\"h1\",{attrs:{id:\"数据预取\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据预取\"}},[e._v(\"#\")]),e._v(\" 数据预取\")]),e._v(\" \"),n(\"p\",[e._v(\"看下这两个框架在服务端如何获取组件数据的。\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[n(\"code\",[e._v(\"next.js\")]),e._v(\" 数据预取代码\")])]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"import React from 'react'\\n\\nexport default class extends React.Component {\\n  static async getInitialProps({ req }) {\\n    const userAgent = req ? req.headers['user-agent'] : navigator.userAgent\\n    return { userAgent }\\n  }\\n\\n  render() {\\n    return (\\n      <div>\\n        Hello World {this.props.userAgent}\\n      </div>\\n    )\\n  }\\n}\\n\\n\")])])]),n(\"p\",[e._v(\"当页面渲染时加载数据，使用了一个异步方法\"),n(\"code\",[e._v(\"getInitialProps\")]),e._v(\"。它能异步获取数据，并绑定在\"),n(\"code\",[e._v(\"props\")]),e._v(\"上。当服务渲染时，\"),n(\"code\",[e._v(\"getInitialProps\")]),e._v(\"将会把数据序列化，就像\"),n(\"code\",[e._v(\"JSON.stringify\")]),e._v(\"。\")]),e._v(\" \"),n(\"p\",[e._v(\"当第一次进入页面时,\"),n(\"code\",[e._v(\"getInitialProps\")]),e._v(\"只会在服务端执行。只有当路由跳转（Link组件跳转或 API 方法跳转）时，客户端才会执行\"),n(\"code\",[e._v(\"getInitialProps\")]),e._v(\"。\")]),e._v(\" \"),n(\"p\",[e._v(\"另外此方法只能用于页面组件内，不能在子组件内使用。\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[n(\"code\",[e._v(\"egg-react-ssr\")]),e._v(\" 数据预取代码\")])]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"import React from 'react'\\nimport { Link } from 'react-router-dom'\\nimport './index.less'\\n\\nfunction Page (props) {\\n  return (\\n    <div className='normal'>\\n      <div className='welcome' />\\n      <ul className='list'>\\n        {\\n          props.news && props.news.map(item => (\\n            <li key={item.id}>\\n              <div>文章标题: {item.title}</div>\\n              <div className='toDetail'><Link to={`/news/${item.id}`}>点击查看详情</Link></div>\\n            </li>\\n          ))\\n        }\\n      </ul>\\n    </div>\\n  )\\n}\\n\\nPage.getInitialProps = async (ctx) => {\\n  // ssr渲染模式只在服务端通过Node获取数据，csr渲染模式只在客户端通过http请求获取数据，getInitialProps方法在整个页面生命周期只会执行一次\\n  return __isBrowser__ ? (await window.fetch('/api/getIndexData')).json() : ctx.service.api.index()\\n}\\n\\nexport default Page\\n\\n\\n\")])])]),n(\"p\",[e._v(\"页面初始化时，服务端根据当前请求的\"),n(\"code\",[e._v(\"path\")]),e._v(\"，来确定我们要渲染哪一个组件，\"),n(\"code\",[e._v(\"getComponent\")]),e._v(\"可以理解为一个根据\"),n(\"code\",[e._v(\"path\")]),e._v(\"从路由表中找到匹配的组件的方法,检测该组件上有没有\"),n(\"code\",[e._v(\"getInitialProps\")]),e._v(\"静态方法，这里之所以要用静态方法，是为了不需要实例化就可以拿到方法。\")]),e._v(\" \"),n(\"p\",[e._v(\"如果有的话，将调用这个方法,将数据作为组件的\"),n(\"code\",[e._v(\"props\")]),e._v(\"传入，使得组件可以通过\"),n(\"code\",[e._v(\"props.xxx\")]),e._v(\"的方式来读取到服务端获取的数据。\")]),e._v(\" \"),n(\"h1\",{attrs:{id:\"本应用的数据预取\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#本应用的数据预取\"}},[e._v(\"#\")]),e._v(\" 本应用的数据预取\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"import React from 'react';\\nimport {\\n    Link\\n} from 'react-router-dom';\\nimport './index.scss';\\nimport img from '../../public/img.jpg';\\nimport PageContainer from '../../common/components/page-container';\\n\\n\\nfunction Index(props) {\\n        return <div className=\\\"page-index-box\\\">\\n            <p>首页</p>\\n            <img src={img} />\\n        </div>\\n}\\n\\nIndex.getInitialProps= async ()=>{\\n    console.log('fetch data index');\\n    //模拟数据请求方法\\n    //...\\n\\n    return {\\n        page: {\\n            tdk: {\\n                title: '首页 - koa-react-ssr',\\n                keywords: '关键词 - koa-react-ssr',\\n                description: '描述'\\n            }\\n        }\\n    };\\n}\\n\\nexport default PageContainer(Index); \\n\\n\")])])]),n(\"p\",[e._v(\"同样为组件添加\"),n(\"code\",[e._v(\"getInitialProps\")]),e._v(\"静态方法，服务端根据当前请求的\"),n(\"code\",[e._v(\"path\")]),e._v(\"，调用\"),n(\"code\",[e._v(\"matchRoute\")]),e._v(\"方法查找到对应的路由，得到具体的组件，判断组件上是否有\"),n(\"code\",[e._v(\"getInitialProps\")]),e._v(\"此方法，然后进行数据预取。\")]),e._v(\" \"),n(\"p\",[e._v(\"最后把数据作为组件的\"),n(\"code\",[e._v(\"props\")]),e._v(\"，在组件内可以通过\"),n(\"code\",[e._v(\"props.initialData\")]),e._v(\"固定属性来获取。\")]),e._v(\" \"),n(\"p\",[e._v(\"整体来看，本应用的实现方式和\"),n(\"code\",[e._v(\"egg-react-ssr\")]),e._v(\",\"),n(\"code\",[e._v(\"next.js\")]),e._v(\"非常相似，可能这也是业内一种默认的通用做法吧。\")]),e._v(\" \"),n(\"h1\",{attrs:{id:\"数据脱水\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据脱水\"}},[e._v(\"#\")]),e._v(\" 数据脱水\")]),e._v(\" \"),n(\"p\",[e._v(\"从运行时的页面看下服务端直出数据的方式。\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"next.js\")])]),e._v(\" \"),n(\"p\",[e._v(\"数据直出到页面后，通过\"),n(\"code\",[e._v(\"script\")]),e._v(\"标签来进行包裹，且\"),n(\"code\",[e._v('type=\"application/json\"')]),e._v(\"，标签内直接是 \"),n(\"code\",[e._v(\"json\")]),e._v(\"数据。\")]),e._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/15/16fa81cd98823742?w=919&h=365&f=png&s=132732\",alt:\"\"}})]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"egg-react-ssr\")])]),e._v(\" \"),n(\"p\",[e._v(\"也是作为脚本加载,然后将数据保存在了\"),n(\"code\",[e._v(\"window.__INITIAL_DATA__\")]),e._v(\"全局变量内。\")]),e._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/15/16fa81fc6d4b70de?w=808&h=449&f=png&s=87585\",alt:\"\"}})]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"本应用\")])]),e._v(\" \"),n(\"p\",[e._v(\"为了防止\"),n(\"code\",[e._v(\"xss\")]),e._v(\"攻击，将数据放在了\"),n(\"code\",[e._v(\"textarea\")]),e._v(\"标签内，客户端使用前先进行一次获取。\")]),e._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/15/16fa82210490222e?w=796&h=326&f=png&s=80946\",alt:\"\"}})]),e._v(\" \"),n(\"p\",[e._v(\"最后，本应用和他们两个框架的结果相同，只是表现形式不同。\")]),e._v(\" \"),n(\"h1\",{attrs:{id:\"热更新\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#热更新\"}},[e._v(\"#\")]),e._v(\" 热更新\")]),e._v(\" \"),n(\"p\",[e._v(\"都实现了模块热替换的功能。\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[n(\"code\",[e._v(\"next.js\")]),e._v(\"采用\"),n(\"code\",[e._v(\"hot-middleware\")]),e._v(\" + \"),n(\"code\",[e._v(\"webpackHotDevClient.js\")]),e._v(\"实现\")]),e._v(\" \"),n(\"li\",[n(\"code\",[e._v(\"egg-react-ssr\")]),e._v(\"采用社区成熟库\"),n(\"code\",[e._v(\"webpack-dev-server\")]),e._v(\"实现，使用代理抹平了双服务模式，对外看到的是一个服务\")]),e._v(\" \"),n(\"li\",[e._v(\"本应用采用社区成熟库\"),n(\"code\",[e._v(\"webpack-dev-server\")]),e._v(\"实现,未做代理转发，目前是使用双服务模式\")])]),e._v(\" \"),n(\"p\",[e._v(\"再次确认了下这两个框架是否支持了模块热更新的同时，是否能保存组件的状态，不过都不支持。\")]),e._v(\" \"),n(\"h1\",{attrs:{id:\"路由配置\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#路由配置\"}},[e._v(\"#\")]),e._v(\" 路由配置\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"next.js\")])]),e._v(\" \"),n(\"p\",[e._v(\"该框架是约定式路由，没有路由配置文件，只要在 \"),n(\"code\",[e._v(\"pages\")]),e._v(\" 文件夹下创建的文件，都会默认生成以文件名命名的路由,的确很方便，但是有些过度封装了。\")]),e._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/15/16fa88ea4d7e8fb5?w=239&h=264&f=png&s=22913\",alt:\"\"}})]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"本骨架和\"),n(\"code\",[e._v(\"egg-react-ssr\")]),e._v(\" 直接使用\"),n(\"code\",[e._v(\"react-router\")]),e._v(\",依旧使用传统的\"),n(\"code\",[e._v(\"spa\")]),e._v(\"应用的使用方式,手动编写路由规则，更加方便你去控制你的项目结构。\")])]),e._v(\" \"),n(\"p\",[n(\"code\",[e._v(\"egg-react-ssr\")]),e._v(\" 配置方式\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"const resolvePath = (path) => require('path').resolve(__dirname, path)\\n\\nmodule.exports = {\\n  type: 'ssr', // 指定运行类型可设置为csr切换为客户端渲染\\n  routes: [\\n    {\\n      path: '/',\\n      exact: true,\\n      Component: () => (require('@/page/index').default), // 这里使用一个function包裹为了让它延迟require\\n      controller: 'page',\\n      handler: 'index'\\n    },\\n    {\\n      path: '/news/:id',\\n      exact: true,\\n      Component: () => (require('@/page/news').default),\\n      controller: 'page',\\n      handler: 'index'\\n    },\\n    {\\n      path: '/test',\\n      exact: true,\\n      Component: () => (require('@/page/test').default),\\n      controller: 'page',\\n      handler: 'index'\\n    }\\n  ],\\n  baseDir: resolvePath('../'),\\n  injectCss: [\\n    `/static/css/Page.chunk.css`\\n  ], // 客户端需要加载的静态样式表\\n  injectScript: [\\n    `<script src='/static/js/runtime~Page.js'><\\/script>`,\\n    `<script src='/static/js/vendor.chunk.js'><\\/script>`,\\n    `<script src='/static/js/Page.chunk.js'><\\/script>`\\n  ], // 客户端需要加载的静态资源文件表\\n  serverJs: resolvePath(`../dist/Page.server.js`)\\n}\\n\\n\\n\")])])]),n(\"p\",[n(\"code\",[e._v(\"本骨架\")]),e._v(\"的配置方式\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"//路由配置文件\\nimport React from 'react';\\n\\n//组件动态加载容器\\nimport AsyncLoader from './async-loader';\\n\\nfunction pageNotFound() {\\n    return <div>404页面</div>\\n}\\n\\nexport default [\\n    {\\n        path: ['/','/index'],\\n        component: AsyncLoader(() => import('../pages/index')),\\n        exact:true\\n    },\\n    {\\n        path: '/list',\\n        component: AsyncLoader(() => import('../pages/list')),\\n        exact: true\\n    },\\n    {\\n        path: '/about',\\n        component: AsyncLoader(() => import('../pages/about')),\\n        exact: true\\n    },\\n    {\\n        path: '*',\\n        component: pageNotFound,\\n        exact: true\\n    }\\n]\\n\\n\")])])]),n(\"p\",[e._v(\"这两者都属于集中式路由配置，更加直观和更灵活的进行配置。多人开发的时候可能维护上有点小瑕疵，容易有冲突。\")]),e._v(\" \"),n(\"h1\",{attrs:{id:\"路由分割\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#路由分割\"}},[e._v(\"#\")]),e._v(\" 路由分割\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"next-js\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#next-js\"}},[e._v(\"#\")]),e._v(\" \"),n(\"code\",[e._v(\"next.js\")])]),e._v(\" \"),n(\"p\",[e._v(\"自动根据页面进行代码分割,无需配置。\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"egg-react-ssr-实现方式\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#egg-react-ssr-实现方式\"}},[e._v(\"#\")]),e._v(\" egg-react-ssr 实现方式\")]),e._v(\" \"),n(\"p\",[e._v(\"使用\"),n(\"code\",[e._v(\"react-loadable\")]),e._v(\"库实现，实现方式和官方的方式不同。\")]),e._v(\" \"),n(\"p\",[e._v(\"没有将服务端\"),n(\"code\",[e._v(\"bundle\")]),e._v(\"打包成多个文件,依然保持一个文件,因为服务端直接处理的是静态路由。\")]),e._v(\" \"),n(\"p\",[e._v(\"可以参考以下配置\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"  {\\n        path: '/news/:id',\\n        exact: true,\\n        Component: () => (__isBrowser__ ? require('react-loadable')({\\n        loader: () => import(/* webpackChunkName: \\\"news\\\" */ '@/page/news'),\\n        loading: function Loading () {\\n            return React.createElement('div')\\n        }\\n        }) : require('@/page/news').default // 通过这种方式来让服务端bundle不要分块打包\\n        ),\\n        controller: 'page',\\n        handler: 'index'\\n    }\\n\\n\")])])]),n(\"p\",[e._v(\"这样配置有个坑，导致\"),n(\"code\",[e._v(\"Loadable\")]),e._v(\"没办法预先知道你有哪些组件被包裹了，所以没办法直接调用\"),n(\"code\",[e._v(\"Loadable.preloadReady()\")]),e._v(\"来预加载。\")]),e._v(\" \"),n(\"p\",[e._v(\"只能自己写一个\"),n(\"code\",[e._v(\"preloadComponen\")]),e._v(\"方法来手动调用组件的\"),n(\"code\",[e._v(\"preload\")]),e._v(\"方法了。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"import { pathToRegexp } from 'path-to-regexp'\\nimport cloneDeepWith from 'lodash.clonedeepwith'\\nimport { RouteItem } from './interface/route'\\n\\nconst preloadComponent = async (Routes: RouteItem[]) => {\\n  const _Routes = cloneDeepWith(Routes)\\n  for (let i in _Routes) {\\n    const { Component, path } = _Routes[i]\\n    let activeComponent = Component()\\n    if (activeComponent.preload && pathToRegexp(path).test(location.pathname)) {\\n        // 只有在你访问的path和组件为同一个path才拿到真实的组件，其他情况还是返回Loadable Compoennt来让首屏不要去加载这些组件\\n      activeComponent = (await activeComponent.preload()).default\\n    }\\n    _Routes[i].Component = () => activeComponent\\n  }\\n  return _Routes\\n}\\n\\nexport {\\n    preloadComponent\\n}\\n\\n\")])])]),n(\"p\",[e._v(\"然后在客户端渲染的时候调用一下该方法\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"const clientRender = async () => {\\n //预加载\\n  const clientRoutes = await preloadComponent(Routes)\\n  // 客户端渲染||hydrate\\n  ReactDOM[window.__USE_SSR__ ? 'hydrate' : 'render'](\\n    <BrowserRouter>\\n      {\\n        // 使用高阶组件getWrappedComponent使得csr首次进入页面以及csr/ssr切换路由时调用getInitialProps\\n        clientRoutes.map(({ path, exact, Component }) => {\\n          const activeComponent = Component()\\n          const WrappedComponent = getWrappedComponent(activeComponent)\\n          const Layout = WrappedComponent.Layout || defaultLayout\\n          return <Route exact={exact} key={path} path={path} render={() => <Layout><WrappedComponent /></Layout>} />\\n        })\\n      }\\n    </BrowserRouter>\\n    , document.getElementById('app'))\\n\\n  if (process.env.NODE_ENV === 'development' && module.hot) {\\n    module.hot.accept()\\n  }\\n}\\n\\n\")])])]),n(\"h2\",{attrs:{id:\"本骨架实现方式\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#本骨架实现方式\"}},[e._v(\"#\")]),e._v(\" 本骨架实现方式\")]),e._v(\" \"),n(\"p\",[e._v(\"没有使用\"),n(\"code\",[e._v(\"react-loadable\")]),e._v(\"，而是依据动态导入原理，包装了一个自定义异步组件加载器\"),n(\"code\",[e._v(\"AsyncBundle\")]),e._v(\",基本原理和\"),n(\"code\",[e._v(\"react-loadable\")]),e._v(\"都是一样的。\")]),e._v(\" \"),n(\"ol\",[n(\"li\",[e._v(\"通过高阶函数对返回一个函数组件，同时为函数添加异步属性,后面服务端和客户端预加载直接通过此属性进行判断\")]),e._v(\" \"),n(\"li\",[e._v(\"服务端代码会被打包成多个文件\")]),e._v(\" \"),n(\"li\",[e._v(\"服务端在请求前对组件进行预加载，也就是转换为静态组件\")]),e._v(\" \"),n(\"li\",[e._v(\"客户端代码会打包成多个文件\")]),e._v(\" \"),n(\"li\",[e._v(\"客户端\"),n(\"code\",[e._v(\"bundle\")]),e._v(\"预加载后再渲染页面\")])]),e._v(\" \"),n(\"p\",[n(\"code\",[e._v(\"容器组件\")])]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"\\nimport React from 'react';\\nimport LoadingCompoent from './loading-compoent';\\n\\n\\n/**\\n * 动态加载组件组的容器组件\\n *\\n * @class Bundle\\n * @extends {Component}\\n */\\nexport default class AsyncBundle extends React.Component {\\n    constructor(props) {\\n        super(props);\\n        this.state = {\\n            mod: null\\n        };\\n    }\\n\\n    componentDidMount() {\\n        if (!this.state.mod) {\\n            this.load(this.props);\\n        }\\n    }\\n\\n    load(props) {\\n        this.setState({\\n            mod: null\\n        });\\n        //注意这里，使用Promise对象; mod.default导出默认\\n        props.load().then((mod) => {\\n            this.setState({\\n                mod: mod.default ? mod.default : mod\\n            });\\n        });\\n    }\\n\\n    render() {\\n        return this.state.mod ? this.props.children(this.state.mod) : <LoadingCompoent/>;\\n    }\\n}\\n\\n\\n\")])])]),n(\"p\",[n(\"code\",[e._v(\"高阶函数，返回异步加载组件的包装组件\")])]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"import AsyncBundle from './async-bundle';\\nimport proConfig from '../../share/pro-config';\\nimport React from 'react';\\nfunction AsyncLoader (loader) {\\n\\n    function asyncFn(props) {\\n       return <AsyncBundle load={loader}>\\n            {(Comp) => <Comp {...props} />}\\n        </AsyncBundle>\\n    }\\n\\n    //标记为异步组件，双端会根据此属性进行预加载\\n    asyncFn[proConfig.asyncComponentKey] = true;\\n\\n    return asyncFn;\\n}\\n\\nexport default AsyncLoader;\\n\\n\\n\")])])]),n(\"p\",[n(\"code\",[e._v(\"参考一个路由配置\")])]),e._v(\" \"),n(\"p\",[n(\"code\",[e._v(\"AsyncLoader\")]),e._v(\"函数内会标记此组件为异步组件\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"    {\\n        path: '/list',\\n        component: AsyncLoader(() => import('../pages/list')),\\n        exact: true\\n    }\\n\\n\")])])]),n(\"p\",[n(\"code\",[e._v(\"服务端组件预加载\")])]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"//将路由转换为静态路由，进行组件预加载\\nasync function getStaticRoutes(routes) {\\n\\n    const key ='__dynamics_route_to_static';\\n    if (global[key]){\\n        console.log('cache route');\\n        return global[key];\\n    }\\n\\n    let len = routes.length,\\n        i = 0;\\n    const staticRoutes = [];\\n\\n    for (; i < len; i++) {\\n        let item = routes[i];\\n        if (checkIsAsyncRoute(item.component)) {\\n            staticRoutes.push({\\n                ...item,\\n                ...{\\n                    component: (await item.component().props.load()).default\\n                }\\n            });\\n        } else {\\n            staticRoutes.push({\\n                ...item\\n            });\\n        }\\n    }\\n    global[key]=staticRoutes;\\n    return staticRoutes; //返回静态路由\\n}\\n\\n\")])])]),n(\"p\",[n(\"code\",[e._v(\"客户端渲染\")])]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"\\nfunction clientRender(routeList) {\\n      \\n\\n        let initialData = JSON.parse(document.getElementById('ssrTextInitData').value);\\n        window.__INITIAL_DATA__ = initialData;\\n\\n        //查找路由\\n        let matchResult = matchRoute(document.location.pathname, routeList);\\n        let { targetRoute } = matchResult;\\n        if (targetRoute) {\\n                //预加载完成后进行 render\\n                if (targetRoute.component[proConfig.asyncComponentKey]) {\\n                        targetRoute.component().props.load().then(res => {\\n                                //异步组件加载完成后再渲染页面\\n                                console.log('异步组件加载完成.....');\\n                                renderDom(routeList,initialData);\\n                        });\\n                }\\n\\n        } else {\\n                renderDom(routeList);\\n\\n        }\\n}\\n\\n\\n\")])])]),n(\"h1\",{attrs:{id:\"css-资源\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#css-资源\"}},[e._v(\"#\")]),e._v(\" CSS 资源\")]),e._v(\" \"),n(\"p\",[e._v(\"主要看下 \"),n(\"code\",[e._v(\"css\")]),e._v(\" 资源是如何处理的。\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"next.js\")])]),e._v(\" \"),n(\"p\",[e._v(\"该框架采用的是将\"),n(\"code\",[e._v(\"css\")]),e._v(\"代码最终打包到一个文件内，作为资源进行加载。\")]),e._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/15/16fa831e6f7eea47?w=947&h=335&f=png&s=56977\",alt:\"\"}})]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"egg-react-ssr\")])]),e._v(\" \"),n(\"p\",[e._v(\"也是最终将\"),n(\"code\",[e._v(\"css\")]),e._v(\"代码提取到一个文件内。\")]),e._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/15/16fa835dc17b8b79?w=990&h=523&f=png&s=100547\",alt:\"\"}})]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"本骨架实现方式\")])]),e._v(\" \"),n(\"p\",[e._v(\"我们目前有两种方式来处理\"),n(\"code\",[e._v(\"css\")]),e._v(\"，一种是将代码进行提取到一个文件内作为资源进行加载。\")]),e._v(\" \"),n(\"p\",[e._v(\"另外一种是同构处理，页面初始化时服务端会搜集组件所需的 \"),n(\"code\",[e._v(\"css\")]),e._v(\"，然后作为内联形式输出。\")]),e._v(\" \"),n(\"p\",[e._v(\"客户端渲染时会判断当前页面内是否已存在，只有不存在的情况下才会动态的插入样式。\")]),e._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/15/16fa839e647e8c39?w=811&h=572&f=png&s=148321\",alt:\"\"}})]),e._v(\" \"),n(\"p\",[e._v(\"其实\"),n(\"code\",[e._v(\"css\")]),e._v(\"同构处理的配置比较繁琐，直接提取为一个\"),n(\"code\",[e._v(\"css\")]),e._v(\"文件也不失为一种便捷的处理方式。\")]),e._v(\" \"),n(\"h1\",{attrs:{id:\"csr-ssr-双模式\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#csr-ssr-双模式\"}},[e._v(\"#\")]),e._v(\" csr/ssr 双模式\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[n(\"code\",[e._v(\"next.js\")]),e._v(\"是一个纯粹的\"),n(\"code\",[e._v(\"ssr\")]),e._v(\"应用服务框架\")]),e._v(\" \"),n(\"li\",[e._v(\"本应用和\"),n(\"code\",[e._v(\"egg-react-ssr\")]),e._v(\"即支持\"),n(\"code\",[e._v(\"ssr\")]),e._v(\"也支持\"),n(\"code\",[e._v(\"csr\")]),e._v(\"，且支持本地开发与生产环境\"),n(\"code\",[e._v(\"ssr/csr\")]),e._v(\"两种渲染模式无缝切换\")])]),e._v(\" \"),n(\"h1\",{attrs:{id:\"总结\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总结\"}},[e._v(\"#\")]),e._v(\" 总结\")]),e._v(\" \"),n(\"p\",[e._v(\"本骨架的方案和\"),n(\"code\",[e._v(\"egg-react-ssr\")]),e._v(\"比较相似，不过仍然有很多区别，还有很多地方可以借鉴和学习,但整体方向比较相似。\")]),e._v(\" \"),n(\"p\",[n(\"code\",[e._v(\"next.js\")]),e._v(\"是很成熟的\"),n(\"code\",[e._v(\"React SSR\")]),e._v(\"应用开发框架，进行了大量的封装，很多东西都是黑盒的，只能按照他已有的模式进行开发，很难进行改造，且只支持\"),n(\"code\",[e._v(\"ssr\")]),e._v(\"一种渲染模式。\")]),e._v(\" \"),n(\"p\",[e._v(\"比较方便的一个是它的约定式路由，根据你的目录和文件来处理的，不需要对路由进行维护，但是需要按照他的规则来创建文件，让你可以有更多时间来关注业务，而无需关注底层和配置。\")]),e._v(\" \"),n(\"p\",[e._v(\"我们的骨架是完全透明的，所有的配置和代码都在项目里，可以很方便的进行改造，路由仍然是传统的集中配置的路由，符合我们以往的开发习惯，但是多人开发可能有些问题，会产生冲突。不过也可以进行优化一下，在每个页面内增加一个路由配置，分开维护，最后通过一些手段将各个页面的路由合并为一个再使用。\")]),e._v(\" \"),n(\"p\",[e._v(\"另外本骨架同时支持\"),n(\"code\",[e._v(\"csr\")]),e._v(\"和\"),n(\"code\",[e._v(\"ssr\")]),e._v(\"两种渲染模式无缝切换。\")]),e._v(\" \"),n(\"p\",[e._v(\"生产环境来说，大家都采用的是将所有的\"),n(\"code\",[e._v(\"css\")]),e._v(\"打包合并到为一个文件方式，如果项目过大的话 \"),n(\"code\",[e._v(\"css\")]),e._v(\"文件可能会过大，导致页面渲染变慢。\")]),e._v(\" \"),n(\"p\",[e._v(\"所以本骨架使用同构对 \"),n(\"code\",[e._v(\"css\")]),e._v(\"进行按需加载，消除了独立\"),n(\"code\",[e._v(\"css\")]),e._v(\"文件，\"),n(\"code\",[e._v(\"css\")]),e._v(\"代码在服务端渲染时会和\"),n(\"code\",[e._v(\"html\")]),e._v(\"内容一起直出，客户端渲染时会动态的创建\"),n(\"code\",[e._v(\"style\")]),e._v(\"标签插入到\"),n(\"code\",[e._v(\"head\")]),e._v(\"内。\")]),e._v(\" \"),n(\"p\",[e._v(\"这样的方式可以让客户端加载更少的代码，不好的地方就是\"),n(\"code\",[e._v(\"css\")]),e._v(\"代码会打包进\"),n(\"code\",[e._v(\"js\")]),e._v(\"，修改\"),n(\"code\",[e._v(\"css\")]),e._v(\"代码也会导致相关的\"),n(\"code\",[e._v(\"js\")]),e._v(\"模块缓存失效，另外同构配置比较繁琐，坑较多，另外对代码侵入性较大，这也可能是其他框架不具备此能力的原因吧。\")]),e._v(\" \"),n(\"p\",[e._v(\"ok，对比完了，你怎么看呢？\")]),e._v(\" \"),n(\"p\",[e._v(\"感谢你的阅读。\")]),e._v(\" \"),n(\"p\",[e._v(\"如果有问题欢迎留言，也欢迎在留言区留下你的想法和思考。\")])])}),[],!1,null,null,null);t.default=s.exports}}]);","extractedComments":[]}