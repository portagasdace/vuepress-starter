{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{475:function(e,t,a){\"use strict\";a.r(t);var r=a(42),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"flutter-性能监控工具\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#flutter-性能监控工具\"}},[e._v(\"#\")]),e._v(\" Flutter 性能监控工具\")]),e._v(\" \"),a(\"p\",[e._v(\"写完 Flutter APP 后，在发布之前，需要对 APP 的性能进行测试，这部分就讲一下 Flutter 的性能监控工具。\")]),e._v(\" \"),a(\"p\",[e._v(\"本次所讲的 Flutter 性能监控工具有两个：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"PerformanceOverlay\")]),e._v(\" \"),a(\"li\",[e._v(\"Observatory\")])]),e._v(\" \"),a(\"h2\",{attrs:{id:\"performanceoverlay-介绍\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#performanceoverlay-介绍\"}},[e._v(\"#\")]),e._v(\" PerformanceOverlay 介绍\")]),e._v(\" \"),a(\"p\",[e._v(\"PerformanceOverlay 是在 app 上显示性能统计数据的浮窗。PerformanceOverlay 是一个 Widget，有几个属性，用于控制开启哪些功能。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"performanceoverlay-分析\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#performanceoverlay-分析\"}},[e._v(\"#\")]),e._v(\" PerformanceOverlay 分析\")]),e._v(\" \"),a(\"p\",[e._v(\"PerformanceOverlay 的源码是：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"~/flutter/packages/flutter/lib/src/widgets/performance_overlay.dart\\n\\n\")])])]),a(\"p\",[e._v(\"可以看出PerformanceOverlay有以下的属性：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[a(\"p\",[e._v(\"optionsMask\")]),e._v(\" \"),a(\"p\",[e._v(\"用于标记哪些功能打开的flag，有四个值:\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"displayRasterizerStatistics ：显示光栅化器统计信息（GPU）\")]),e._v(\" \"),a(\"li\",[e._v(\"visualizeRasterizerStatistics ：可视化光栅化器统计信息(GPU)\")]),e._v(\" \"),a(\"li\",[e._v(\"displayEngineStatistics ：显示引擎统计（CPU）\")]),e._v(\" \"),a(\"li\",[e._v(\"visualizeEngineStatistics ：可视化引擎统计（CPU）\")])])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"rasterizerThreshold\")]),e._v(\" \"),a(\"p\",[e._v(\"光栅化的阈值，用于捕获SkPicture跟踪以进行进一步分析，它的值代表每隔几帧捕获一次，默认是0，代表功能是关闭的\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"checkerboardRasterCacheImages\")]),e._v(\" \"),a(\"p\",[e._v(\"检查缓存图片的情况\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"checkerboardOffscreenLayers 检查不必要的setlayer\")])])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"开启-performanceoverlay\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#开启-performanceoverlay\"}},[e._v(\"#\")]),e._v(\" 开启 PerformanceOverlay\")]),e._v(\" \"),a(\"p\",[e._v(\"开启 Performance Overlay 的方法有两种：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"使用 IDE 里集成的 Flutter Inspector 工具\")]),e._v(\" \"),a(\"li\",[e._v(\"使用代码设置\")])]),e._v(\" \"),a(\"h4\",{attrs:{id:\"_1、-使用-ide-里集成的-flutter-inspector-工具\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、-使用-ide-里集成的-flutter-inspector-工具\"}},[e._v(\"#\")]),e._v(\" 1、 使用 IDE 里集成的 Flutter Inspector 工具\")]),e._v(\" \"),a(\"p\",[e._v(\"Flutter Inspector 是集成在 IDE 里的一个强大的工具，Performance Overlay 的功能也集成在 Flutter Inspector 里。\")]),e._v(\" \"),a(\"p\",[e._v(\"需要我们运行 Flutter APP 后才可以使用，\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"在 Android Studio 里\")])]),e._v(\" \"),a(\"p\",[e._v(\"选择 View > Tool Windows > Flutter Inspector，就可以打开 Flutter Inspector，可以看到有很多功能，如下图：\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/28/1689018ea5935178?w=517&h=189&f=png&s=32861\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"然后选择 Performance Overlay。\")]),e._v(\" \"),a(\"ol\",{attrs:{start:\"2\"}},[a(\"li\",[e._v(\"在 VS Code里\")])]),e._v(\" \"),a(\"p\",[e._v(\"通过 View > Command Palette 或者 \"),a(\"code\",[e._v(\"cmd+p\")]),e._v(\" 打开命令板，输入 \"),a(\"code\",[e._v(\"performance\")]),e._v(\" 然后选择 Toggle Performance Overlay 就行。\")]),e._v(\" \"),a(\"h4\",{attrs:{id:\"_2-使用代码设置\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-使用代码设置\"}},[e._v(\"#\")]),e._v(\" 2. 使用代码设置\")]),e._v(\" \"),a(\"p\",[e._v(\"通过给 MaterialApp 或者 WidgetsApp 设置参数来开启 PerformanceOverlay 的功能。\")]),e._v(\" \"),a(\"p\",[e._v(\"要将MaterialApp 或者 WidgetsApp 的showPerformanceOverlay 属性设置为true，如下：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"class MyApp extends StatelessWidget {\\n  @override\\n  Widget build(BuildContext context) {\\n    return MaterialApp(\\n      showPerformanceOverlay: true,\\n      title: 'My Awesome App',\\n      theme: ThemeData(\\n        primarySwatch: Colors.blue,\\n      ),\\n      home: MyHomePage(title: 'My Awesome App'),\\n    );\\n  }\\n}\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"在-performanceoverlay-里查看-gpu、cpu-统计信息\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在-performanceoverlay-里查看-gpu、cpu-统计信息\"}},[e._v(\"#\")]),e._v(\" 在 PerformanceOverlay 里查看 GPU、CPU 统计信息\")]),e._v(\" \"),a(\"p\",[e._v(\"如下图：\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/27/1688dcffb845cf87?w=350&h=265&f=png&s=63322\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"这个浮窗有两个图形：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[a(\"p\",[e._v(\"上面的是 GPU thread\")]),e._v(\" \"),a(\"p\",[e._v(\"表示在 GPU 线程上生成每帧需要的时间。\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"下面的 UI thread\")]),e._v(\" \"),a(\"p\",[e._v(\"表示在 UI 线程上生成每帧需要的时间。\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"纵轴\")]),e._v(\" \"),a(\"p\",[e._v(\"图中的纵轴代表时间，每个图形都被分成三格，每小隔代表 16ms，如果图中超过这三条线之一，那么您的运行频率低于 60Hz。\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"横轴\")]),e._v(\" \"),a(\"p\",[e._v(\"横轴代表帧。 该图仅在应用程序绘制时更新，因此如果它处于空闲状态，该图将停止移动。每个图形绘制的都是该线程最后 300帧 的数据。\")])])]),e._v(\" \"),a(\"p\",[e._v(\"为了保证 60FPS，每帧耗费的时间应该是小于 16ms 的，看上图中绿色的粗线条，代表的是当前帧的数据，如果当前帧的数据符合预期（<16ms），那么就是绿色的，如果不符合，就是红色的，如下图：\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/27/1688ddec1fe47589?w=350&h=182&f=png&s=47753\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"遇到红色的就需要去具体分析，因为会造成 APP 卡顿：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[a(\"p\",[e._v(\"如果 GPU thread 是红色的\")]),e._v(\" \"),a(\"p\",[e._v(\"那么可能是绘制的图形过于复杂，或者是执行了过多的 GPU 操作。\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"如果 UI thread 是红色的\")]),e._v(\" \"),a(\"p\",[e._v(\"说明肯定是 Dart 代码里有耗时操作，导致阻塞 了UI 操作。\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"如果两个都是红色的 建议从 UI thread，也就是 Dart 代码查起。\")])])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"gpu-问题定位\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#gpu-问题定位\"}},[e._v(\"#\")]),e._v(\" GPU 问题定位\")]),e._v(\" \"),a(\"p\",[e._v(\"辅助定位 GPU 问题的，就是 PerformanceOverlay 的下面两个功能：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[a(\"p\",[e._v(\"checkerboardRasterCacheImages -- 检查缓存图片的情况\")]),e._v(\" \"),a(\"p\",[e._v(\"还有一个拖慢 GPU 渲染速度的是没有给静态图像做缓存，导致每次 build 都会重新绘制。我们可以把静态图像加到 RepaintBoundry 中，引擎会自动判断图像是否复杂到需要 repaint boundary。\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"checkerboardOffscreenLayers -- 检查不必要的 setlayer\")]),e._v(\" \"),a(\"p\",[e._v(\"setlayer 是 Canvas里的操作，非常耗性能，所以要尽量避免这个操作。你可能会好奇，我根本没用到这个，是的，我们一般是不会使用这个函数的，所以当你开启了这个检查后，会发现啥也没有，正好说明了你没有用到 setlayer。我们一般都是被动的使用，比如需要剪切、透明的操作，用到一些 widget 的时候，这些 widget 会用到 setlayer 方法，一旦遇到这种情况，我们要想一下是否一定要这么做，能不能通过其他方式实现。\")])])]),e._v(\" \"),a(\"p\",[e._v(\"开启这两个功能的方法：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"MaterialApp(\\n    showPerformanceOverlay: true,\\n    checkerboardOffscreenLayers: true, //使用了saveLayer的图像会显示为棋盘格式并随着页面刷新而闪烁\\n    checkerboardRasterCacheImages: true, // 做了缓存的静态图像图片在刷新页面使不会改变棋盘格的颜色；如果棋盘格颜色变了，说明被重新缓存，这是我们要避免的\\n    ...\\n);\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"gpu-优化\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#gpu-优化\"}},[e._v(\"#\")]),e._v(\" GPU 优化\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"一些效果尽量设置在子 Widget 上，而不是父 Widget\")])]),e._v(\" \"),a(\"p\",[e._v(\"例如，要实现一个混合图层的半透明效果，如果把透明度设置在顶层 Widget 上，CPU 会把每个 子Widget 的图层渲染出来，在执行 \"),a(\"code\",[e._v(\"saveLayer\")]),e._v(\" 操作保存为一个图层，最后给这个图层设置透明度，但是 \"),a(\"code\",[e._v(\"saveLayer\")]),e._v(\" 的开销很大，所以官方给出建议：首先确认这些效果是否真的有必要；如果有必要，应该把透明度设置到每个 子Widget 上，而不是 父Widget。裁剪操作也是类似。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"ui问题定位\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ui问题定位\"}},[e._v(\"#\")]),e._v(\" UI问题定位\")]),e._v(\" \"),a(\"p\",[e._v(\"可以使用 Observatory 里的 timeline 的功能分析。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"flutter-性能监控工具-observatory-介绍\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#flutter-性能监控工具-observatory-介绍\"}},[e._v(\"#\")]),e._v(\" Flutter 性能监控工具 -- Observatory 介绍\")]),e._v(\" \"),a(\"p\",[e._v(\"Flutter 的宣传说，使用 Flutter 可以达到 60FPS，但是这并不意味，不管你怎么写，都能达到 60FPS，如果有耗时的操作，可能会阻塞 UI 的渲染，如果内存使用过多，也有可能会 OOM，所以性能的好坏，是保证 Flutter 能否达到 60FPS 的关键，在对 Flutter 进行性能优化之前，我们先看下如何来监测 Flutter 的性能。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"flutter-的三种构建模式-build-modes\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#flutter-的三种构建模式-build-modes\"}},[e._v(\"#\")]),e._v(\" Flutter 的三种构建模式(build modes)\")]),e._v(\" \"),a(\"p\",[e._v(\"Flutter 有三种构建模式，适用于不同的场景:\")]),e._v(\" \"),a(\"h4\",{attrs:{id:\"_1-debug\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-debug\"}},[e._v(\"#\")]),e._v(\" 1.Debug\")]),e._v(\" \"),a(\"p\",[e._v(\"顾名思义，就是调试模式，在调试模式下：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"Flutter 的断言（Assertions）功能是开的\")]),e._v(\" \"),a(\"li\",[e._v(\"Flutter 的 Observatory 是开的，Observatory 是用于分析和调试 Dart 代码的工具，用于 Dart 的 debugger\")]),e._v(\" \"),a(\"li\",[e._v(\"扩展的服务功能（Service extensions）是开启的，如第二点的 Observatory 的服务还有性能的服务等。\")]),e._v(\" \"),a(\"li\",[e._v(\"JIT 编译模式，可以使用 Hot Reload，为了快速开发\")])]),e._v(\" \"),a(\"p\",[e._v(\"可以看到，在 Debug 模式下，为了 debug 和快速开发，牺牲了性能，所以 Debug 模式都是用在开发阶段。 而且模拟器只能运行 Debug 模式。\")]),e._v(\" \"),a(\"p\",[e._v(\"用命令行:\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"$flutter run\\n\\n\")])])]),a(\"h4\",{attrs:{id:\"_2-release\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-release\"}},[e._v(\"#\")]),e._v(\" 2.Release\")]),e._v(\" \"),a(\"p\",[e._v(\"顾名思义，就是要发布了，在 Release 模式下，要追求最高的性能和最小的安装包，所以会：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"断言（Assertions）功能关闭\")]),e._v(\" \"),a(\"li\",[e._v(\"没有 Debugging 的信息\")]),e._v(\" \"),a(\"li\",[e._v(\"Debugger 的功能关闭\")]),e._v(\" \"),a(\"li\",[e._v(\"AOT 编译，为了快速启动，快速执行和更小的包装包大小。\")]),e._v(\" \"),a(\"li\",[e._v(\"扩展的服务功能（Service extensions）关闭\")])]),e._v(\" \"),a(\"p\",[e._v(\"所以，Release 模式是 APP 要发布的时候才用。\")]),e._v(\" \"),a(\"p\",[e._v(\"Release 模式只能跑在真机上。\")]),e._v(\" \"),a(\"p\",[e._v(\"用命令行:\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"$flutter run --release\\n\\n\")])])]),a(\"p\",[e._v(\"或者\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"$flutter build\\n\\n\")])])]),a(\"h4\",{attrs:{id:\"_3-profile\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-profile\"}},[e._v(\"#\")]),e._v(\" 3.Profile\")]),e._v(\" \"),a(\"p\",[e._v(\"Profile 是专门监控性能的模式，在 Debug 模式下，不能实际反应应用的性能，而在 Release 模式下，却没有监控的功能，所以就诞生了 Profile 模式，Profile 模式和 Release 模式更接近，Profile 和 Release 都采用的 AOT 编译，所以都不能用 Hot Reload，但是 Profile 相对于 Release，多了如下的功能：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"一些扩展的服务功能（Service extensions）是打开的，例如监控性能的浮层等。\")]),e._v(\" \"),a(\"li\",[e._v(\"Tracing 是打开的，Observatory 也可以连接到进程\")])]),e._v(\" \"),a(\"p\",[e._v(\"Profile 模式只能跑在真机上。\")]),e._v(\" \"),a(\"p\",[e._v(\"用命令行:\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"$flutter run --profile\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"使用-observatory-来监控性能\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-observatory-来监控性能\"}},[e._v(\"#\")]),e._v(\" 使用 Observatory 来监控性能\")]),e._v(\" \"),a(\"p\",[e._v(\"Observatory 是用于分析和调试 Dart 代码的工具，因为 Flutter 自带 Dart VM，所以也可以用 Observatory。\")]),e._v(\" \"),a(\"h4\",{attrs:{id:\"_1-命令行启动-observatory\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-命令行启动-observatory\"}},[e._v(\"#\")]),e._v(\" 1. 命令行启动 Observatory\")]),e._v(\" \"),a(\"p\",[e._v(\"Debug 下启用 Observatory：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"$flutter run\\n\\n\")])])]),a(\"p\",[e._v(\"Profile 下启用 Observatory：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"$flutter run --profile\\n\\n\")])])]),a(\"p\",[e._v(\"运行完命令后，会看到如下的信息：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"$ flutter run --profile\\nInitializing gradle...                                       0.8s\\nResolving dependencies...                                    6.6s\\nLaunching lib/main.dart on ALP AL00 in profile mode...\\nGradle task 'assembleProfile'...\\nGradle task 'assembleProfile'... Done                       21.2s\\nBuilt build/app/outputs/apk/profile/app-profile.apk (66.5MB).\\nInstalling build/app/outputs/apk/app.apk...                  5.4s\\nD/mali_winsys(18612): EGLint new_window_surface(egl_winsys_display *, void *, EGLSurface, EGLConfig, egl_winsys_surface **, EGLBoolean) returns 0x3000\\n\\nAn Observatory debugger and profiler on ALP AL00 is available at http://127.0.0.1:57535/\\nFor a more detailed help message, press \\\"h\\\". To quit, press \\\"q\\\".\\n\\n\")])])]),a(\"p\",[e._v(\"这一句:\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"available at http://127.0.0.1:57535/\\n\\n\")])])]),a(\"p\",[e._v(\"打开 \"),a(\"code\",[e._v(\"http://127.0.0.1:57535/\")]),e._v(\" 这个网址，就会看到如下的界面：\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/27/1688b0505b551f25?w=3248&h=1822&f=png&s=438659\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"Observatory 支持如下的功能：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"Allocation Profile\")]),e._v(\" \"),a(\"li\",[e._v(\"Code Coverage\")]),e._v(\" \"),a(\"li\",[e._v(\"CPU Profile\")]),e._v(\" \"),a(\"li\",[e._v(\"Debugger\")]),e._v(\" \"),a(\"li\",[e._v(\"Evaluating Expressions\")]),e._v(\" \"),a(\"li\",[e._v(\"Heap Map\")]),e._v(\" \"),a(\"li\",[e._v(\"Isolate\")]),e._v(\" \"),a(\"li\",[e._v(\"Metrics\")]),e._v(\" \"),a(\"li\",[e._v(\"User and VM Tags\")])]),e._v(\" \"),a(\"p\",[e._v(\"部分功能的截图如下：\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/27/1688b5532c6515f8?w=2984&h=1676&f=png&s=476051\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/27/1688b5736a3f22c5?w=2558&h=1576&f=png&s=498544\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/27/1688b58c88493630?w=2956&h=1598&f=png&s=417010\",alt:\"\"}})]),e._v(\" \"),a(\"h4\",{attrs:{id:\"_2-flutter-inspector-启动\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-flutter-inspector-启动\"}},[e._v(\"#\")]),e._v(\" 2.Flutter Inspector 启动\")]),e._v(\" \"),a(\"p\",[e._v(\"Flutter Inspector 是一个强大的工具，要想使用 Flutter Inspector，就得先运行 Flutter APP。\")]),e._v(\" \"),a(\"p\",[e._v(\"运行 Flutter APP后:\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"在 Android Studio 里\")])]),e._v(\" \"),a(\"p\",[e._v(\"选择 View > Tool Windows > Flutter Inspector，就可以打开 Flutter Inspector，可以看到有很多功能，如下图：\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/28/1689018ea5935178?w=517&h=189&f=png&s=32861\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"然后选择 Open observatory。\")]),e._v(\" \"),a(\"ol\",{attrs:{start:\"2\"}},[a(\"li\",[e._v(\"在 VS Code里\")])]),e._v(\" \"),a(\"p\",[e._v(\"通过 View > Command Palette 或者 \"),a(\"code\",[e._v(\"cmd+p\")]),e._v(\" 打开命令板，输入 \"),a(\"code\",[e._v(\"Open observatory\")]),e._v(\" 然后选择 Open observatory就行。\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/28/168902466cfa2ac4?w=1196&h=122&f=png&s=18681\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"如果看不到，说明你没有运行 Flutter APP，得以 \"),a(\"code\",[e._v(\"Start Debugging\")]),e._v(\" 的方式运行。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"flutter-性能监控工具-observatory-使用\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#flutter-性能监控工具-observatory-使用\"}},[e._v(\"#\")]),e._v(\" Flutter 性能监控工具 -- Observatory 使用\")]),e._v(\" \"),a(\"p\",[e._v(\"前面主要讲了如何打开 Observatory，现在讲一下如何使用 Observatory 里的各个功能来分析性能问题，\")]),e._v(\" \"),a(\"p\",[e._v(\"下图是 Observatory 的主页面：\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/28/168951b1b83c6000?w=3228&h=1812&f=png&s=444838\",alt:\"\"}})]),e._v(\" \"),a(\"h3\",{attrs:{id:\"最上面的蓝色导航栏\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#最上面的蓝色导航栏\"}},[e._v(\"#\")]),e._v(\" 最上面的蓝色导航栏\")]),e._v(\" \"),a(\"p\",[e._v(\"表示当前所在的位置\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[a(\"p\",[e._v(\"vm@ws://127.0.0.1:50579/ws ：表示当前连接的VM\")]),e._v(\" \"),a(\"p\",[e._v(\"鼠标放在这个上面，会看到这个，表示当前 APP 的 main()：\")])])]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/28/168951f40059bfc5?w=512&h=188&f=png&s=16769\",alt:\"\"}})]),e._v(\" \"),a(\"ol\",{attrs:{start:\"2\"}},[a(\"li\",[e._v(\"右边的 Refresh ：刷新数据\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"vm\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vm\"}},[e._v(\"#\")]),e._v(\" VM\")]),e._v(\" \"),a(\"p\",[e._v(\"这里显示当前 VM 的信息\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"name ： 当前 VM 的名字\")]),e._v(\" \"),a(\"li\",[e._v(\"version ：Dart 的版本，APP build 的时间，运行在哪个平台上\")]),e._v(\" \"),a(\"li\",[e._v(\"embedder ：嵌入的平台\")]),e._v(\" \"),a(\"li\",[e._v(\"started at ：VM 启动时的时间戳\")]),e._v(\" \"),a(\"li\",[e._v(\"uptime ：VM 已运行的时长\")]),e._v(\" \"),a(\"li\",[e._v(\"refreshed at ：上次采样数据的时间\")]),e._v(\" \"),a(\"li\",[e._v(\"pid ： 进程 ID\")]),e._v(\" \"),a(\"li\",[e._v(\"peak memory ：APP 运行时用的峰值内存\")]),e._v(\" \"),a(\"li\",[e._v(\"current memory : APP 当前用的内存\")]),e._v(\" \"),a(\"li\",[e._v(\"native zone memory ：native 原生内存\")]),e._v(\" \"),a(\"li\",[e._v(\"native heap memory ：native 堆内存\")]),e._v(\" \"),a(\"li\",[e._v(\"native heap allocatioon count ： native 堆对象数量\")]),e._v(\" \"),a(\"li\",[e._v(\"flag ：一些标记位\")]),e._v(\" \"),a(\"li\",[e._v(\"timeline ：工具\")]),e._v(\" \"),a(\"li\",[e._v(\"native memory profile ：\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"isolates\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#isolates\"}},[e._v(\"#\")]),e._v(\" Isolates\")]),e._v(\" \"),a(\"p\",[e._v(\"这里是显示 APP 里的 Isolates，每个 APP 都有一个 root Isolates。\")]),e._v(\" \"),a(\"p\",[e._v(\"Isolates 是用一个饼图显示，这个饼图有很多组成部分，我们把这些叫做 tags，这些 tags 用来代表在 VM 里不同的执行列表，包括 User TAG 和 VM TAG：\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[e._v(\"User TAG\")]),e._v(\" \"),a(\"p\",[e._v(\"用户自定义的 TAG，使用方式如下：\")])])]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"import 'dart:developer';\\n\\nvar customTag = new UserTag('MyTag');\\n\\n// Save the previous tag when installing the custom tag.\\nvar previousTag = customTag.makeCurrent();\\n\\n// your code here\\n\\n// Restore the previous tag.\\npreviousTag.makeCurrent();\\n\\n\")])])]),a(\"ul\",[a(\"li\",[a(\"p\",[e._v(\"VM TAG\")]),e._v(\" \"),a(\"p\",[e._v(\"VM TAG 是系统定义的，在整个 UI 中使用，有：\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"CompileOptimized, CompileScanner, CompileTopLevel, CompileUnoptimized ：编译 Dart 代码\")]),e._v(\" \"),a(\"li\",[e._v(\"GCNewSpace ： 新生代的垃圾收集\")]),e._v(\" \"),a(\"li\",[e._v(\"GCOldSpace ： 老生代的垃圾收集\")]),e._v(\" \"),a(\"li\",[e._v(\"Idle ： 不是 VM TAG，但是用来标识 Isolate 空闲的占比\")]),e._v(\" \"),a(\"li\",[e._v(\"Native ： 执行Native代码，dart：io 库使用的 C++ 代码 或者 平台相关代码(Platform Channel)\")]),e._v(\" \"),a(\"li\",[e._v(\"Runtime : 执行 Runtime 代码\")]),e._v(\" \"),a(\"li\",[e._v(\"Dart ： 执行 自己的业务 Dart 代码\")]),e._v(\" \"),a(\"li\",[e._v(\"VM ：创建 isolate，和其他未被覆盖的部分\")])])])]),e._v(\" \"),a(\"p\",[e._v(\"图像的右边还有一系列链接，代表着不同的功能。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"debug\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#debug\"}},[e._v(\"#\")]),e._v(\" debug\")]),e._v(\" \"),a(\"p\",[e._v(\"可以设置断点并调试您的应用程序。\")]),e._v(\" \"),a(\"p\",[e._v(\"如何设置 debugger，看 \"),a(\"a\",{attrs:{href:\"https://dart-lang.github.io/observatory/debugger.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://dart-lang.github.io/observatory/debugger.html\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"h3\",{attrs:{id:\"class-hierarchy\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#class-hierarchy\"}},[e._v(\"#\")]),e._v(\" class hierarchy\")]),e._v(\" \"),a(\"p\",[e._v(\"显示应用程序的类层次结构。\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/29/168954d8f7e10997?w=1504&h=1192&f=png&s=187886\",alt:\"\"}})]),e._v(\" \"),a(\"h3\",{attrs:{id:\"cpu-profile\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cpu-profile\"}},[e._v(\"#\")]),e._v(\" cpu profile\")]),e._v(\" \"),a(\"p\",[e._v(\"显示当前 isolate 的 CPU 使用数据\")]),e._v(\" \"),a(\"p\",[e._v(\"图表的下部按 CPU 占用比例做了一个列表，反映的是函数的调用次数和执行时间（划重点）。一般排在前面的函数（这些函数是？有待学习）都不是我们写的 dart 代码。如果你发现自己的某个函数调用占比反常，那么可能存在问题。\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/29/168954d20cf1c4c3?w=1658&h=1598&f=png&s=292517\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"具体使用的地址：\"),a(\"a\",{attrs:{href:\"https://dart-lang.github.io/observatory/cpu-profile.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://dart-lang.github.io/observatory/cpu-profile.html\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"h3\",{attrs:{id:\"cpu-profile-table\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cpu-profile-table\"}},[e._v(\"#\")]),e._v(\" cpu profile (table)\")]),e._v(\" \"),a(\"p\",[e._v(\"和 cpu profile 一样，但是是以表格的形式来展示\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/29/168954e997e3f6ed?w=1796&h=1232&f=png&s=333231\",alt:\"\"}})]),e._v(\" \"),a(\"h3\",{attrs:{id:\"allocation-profile\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#allocation-profile\"}},[e._v(\"#\")]),e._v(\" allocation profile\")]),e._v(\" \"),a(\"p\",[e._v(\"显示 isolate 已分配的内存。通过这个面板你能看到新生代/老生代的内存大小和占比；每个类型所占用的内存大小。\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/29/1689552297814fd9?w=3224&h=1650&f=png&s=509264\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"Heap 堆，动态分配的Dart对象所在的内存空间\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"New generation: 新创建的对象，一般来说对象比较小，生命周期短，如local 变量。在这里GC活动频繁\")]),e._v(\" \"),a(\"li\",[e._v(\"Old generation：从GC中存活下来的New generation将会提拔到老生代Old generation，它比新生代空间大，更适合大的对象和生命周期长的对象\")])]),e._v(\" \"),a(\"p\",[e._v(\"通过这个面板你能看到新生代/老生代的内存大小和占比；每个类型所占用的内存大小。\")]),e._v(\" \"),a(\"p\",[e._v(\"为了 debug 的方便，我们可以获取到某段时间的内存分配情况：点击 Reset Accumulator 按钮，把数据清零，执行一下要测试的程序，点击刷新。 为了检查内存泄露，我们可以点击 GC 按钮，手动执行 GC。\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"Accumulator Size:自点击Reset Accumulator以来，累加对象占用内存大小\")]),e._v(\" \"),a(\"li\",[e._v(\"Accumulator Instances：自点击Reset Accumulator以来，累加实例个数\")]),e._v(\" \"),a(\"li\",[e._v(\"Current Size：当前对象占用内存大小\")]),e._v(\" \"),a(\"li\",[e._v(\"Current Instances：当前对象数量\")])]),e._v(\" \"),a(\"p\",[e._v(\"具体使用的地址：\"),a(\"a\",{attrs:{href:\"https://dart-lang.github.io/observatory/allocation-profile.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://dart-lang.github.io/observatory/allocation-profile.html\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"h3\",{attrs:{id:\"heap-snapshot\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#heap-snapshot\"}},[e._v(\"#\")]),e._v(\" heap snapshot\")]),e._v(\" \"),a(\"p\",[e._v(\"堆快照\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/29/168955461b809164?w=1914&h=1332&f=png&s=314132\",alt:\"\"}})]),e._v(\" \"),a(\"h3\",{attrs:{id:\"heap-map\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#heap-map\"}},[e._v(\"#\")]),e._v(\" heap map\")]),e._v(\" \"),a(\"p\",[e._v(\"将分配的内存显示为颜色块\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/29/16895562c59f0628?w=3250&h=1120&f=png&s=227222\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"heap map 面板能查看 old generation 中的内存状态, 它以颜色显示内存块。 每个内存页面(page of memory)为256 KB，每页由水平黑线分隔。\")]),e._v(\" \"),a(\"p\",[e._v(\"例如，蓝色表示字符串，绿色表示双精度表。 可用空间为白色，指令（代码）为紫色。 如果启动垃圾收集（使用“分配配置文件”屏幕中的GC按钮），堆映射中将显示更多空白区域（可用空间）。 将光标悬停在上面时，顶部的状态栏显示有关光标下像素所代表的对象的信息。 显示的信息包括该对象的类型，大小和地址。\")]),e._v(\" \"),a(\"p\",[e._v(\"当你看到白色区域中有很多分散的其它颜色，说明存在内存碎片化，可能是内存泄露导致的。\")]),e._v(\" \"),a(\"p\",[e._v(\"具体使用看：\"),a(\"a\",{attrs:{href:\"https://dart-lang.github.io/observatory/heap-map.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"https://dart-lang.github.io/observatory/heap-map.html\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"h3\",{attrs:{id:\"metrics\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#metrics\"}},[e._v(\"#\")]),e._v(\" metrics\")]),e._v(\" \"),a(\"p\",[e._v(\"包含您应用中收集的指标。\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/29/168955726d747d24?w=1308&h=714&f=png&s=77705\",alt:\"\"}})]),e._v(\" \"),a(\"h3\",{attrs:{id:\"persistent-handles\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#persistent-handles\"}},[e._v(\"#\")]),e._v(\" persistent handles\")]),e._v(\" \"),a(\"p\",[e._v(\"查看强对象和弱对象\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/29/16895588df8b5263?w=2054&h=1726&f=png&s=419852\",alt:\"\"}})]),e._v(\" \"),a(\"h3\",{attrs:{id:\"ports\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ports\"}},[e._v(\"#\")]),e._v(\" ports\")]),e._v(\" \"),a(\"p\",[e._v(\"端口\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/29/16895595f55f01cf?w=1362&h=212&f=png&s=31114\",alt:\"\"}})]),e._v(\" \"),a(\"h3\",{attrs:{id:\"logging\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#logging\"}},[e._v(\"#\")]),e._v(\" logging\")]),e._v(\" \"),a(\"p\",[e._v(\"设置Log的级别\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/1/29/168955a02d935469?w=1314&h=222&f=png&s=40853\",alt:\"\"}})])])}),[],!1,null,null,null);t.default=s.exports}}]);","extractedComments":[]}