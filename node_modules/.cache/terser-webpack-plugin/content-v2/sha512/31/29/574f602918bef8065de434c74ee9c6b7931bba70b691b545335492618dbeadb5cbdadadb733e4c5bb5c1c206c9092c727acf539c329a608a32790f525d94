{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[405],{759:function(e,t,a){\"use strict\";a.r(t);var n=a(42),v=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"一面-2-js-web-api-知识点与高频考题解析\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一面-2-js-web-api-知识点与高频考题解析\"}},[e._v(\"#\")]),e._v(\" 一面 2：JS-Web-API 知识点与高频考题解析\")]),e._v(\" \"),a(\"p\",[e._v(\"除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"知识点梳理\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#知识点梳理\"}},[e._v(\"#\")]),e._v(\" 知识点梳理\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"BOM 操作\")]),e._v(\" \"),a(\"li\",[e._v(\"DOM 操作\")]),e._v(\" \"),a(\"li\",[e._v(\"事件绑定\")]),e._v(\" \"),a(\"li\",[e._v(\"Ajax\")]),e._v(\" \"),a(\"li\",[e._v(\"存储\")])]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"h2\",{attrs:{id:\"bom\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bom\"}},[e._v(\"#\")]),e._v(\" BOM\")]),e._v(\" \"),a(\"p\",[e._v(\"BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"code\",[e._v(\"navigator\")])]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"screen\")])]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"location\")])]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"history\")])])]),e._v(\" \"),a(\"p\",[e._v(\"这些对象就是一堆非常简单粗暴的 API，没任何技术含量，讲起来一点意思都没有，大家去 MDN 或者 w3school 这种网站一查就都明白了。面试的时候，面试官基本不会出太多这方面的题目，因为只要基础知识过关了，这些 API 即便你记不住，上网一查也都知道了。下面列举一下常用功能的代码示例\")]),e._v(\" \"),a(\"p\",[e._v(\"获取浏览器特性（即俗称的\"),a(\"code\",[e._v(\"UA\")]),e._v(\"）然后识别客户端，例如判断是不是 Chrome 浏览器\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"var ua = navigator.userAgent\\nvar isChrome = ua.indexOf('Chrome')\\nconsole.log(isChrome)\\n\\n\")])])]),a(\"p\",[e._v(\"获取屏幕的宽度和高度\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"console.log(screen.width)\\nconsole.log(screen.height)\\n\\n\")])])]),a(\"p\",[e._v(\"获取网址、协议、path、参数、hash 等\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// 例如当前网址是 https://juejin.im/timeline/frontend?a=10&b=10#some\\nconsole.log(location.href)  // https://juejin.im/timeline/frontend?a=10&b=10#some\\nconsole.log(location.protocol) // https:\\nconsole.log(location.pathname) // /timeline/frontend\\nconsole.log(location.search) // ?a=10&b=10\\nconsole.log(location.hash) // #some\\n\\n\")])])]),a(\"p\",[e._v(\"另外，还有调用浏览器的前进、后退功能等\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"history.back()\\nhistory.forward()\\n\\n\")])])]),a(\"hr\"),e._v(\" \"),a(\"h2\",{attrs:{id:\"dom\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dom\"}},[e._v(\"#\")]),e._v(\" DOM\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"题目：DOM 和 HTML 区别和联系\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"什么是-dom\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是-dom\"}},[e._v(\"#\")]),e._v(\" 什么是 DOM\")]),e._v(\" \"),a(\"p\",[e._v(\"讲 DOM 先从 HTML 讲起，讲 HTML 先从 XML 讲起。XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的数据，它是一棵树！\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<note>\\n  <to>Tove</to>\\n  <from>Jani</from>\\n  <heading>Reminder</heading>\\n  <body>Don\\'t forget me this weekend!</body>\\n  <other>\\n    <a></a>\\n    <b></b>\\n  </other>\\n</note>\\n\\n')])])]),a(\"p\",[e._v(\"HTML 是一个有既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('<!DOCTYPE html>\\n<html>\\n<head>\\n    <meta charset=\"UTF-8\">\\n    <title>Document</title>\\n</head>\\n<body>\\n    <div>\\n        <p>this is p</p>\\n    </div>\\n</body>\\n</html>\\n\\n')])])]),a(\"p\",[e._v(\"我们开发完的 HTML 代码会保存到一个文档中（一般以\"),a(\"code\",[e._v(\".html\")]),e._v(\"或者\"),a(\"code\",[e._v(\".htm\")]),e._v(\"结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是 HTML 格式的代码。\")]),e._v(\" \"),a(\"p\",[e._v(\"但是浏览器要把这个文档中的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JS 能理解的东西，因为还得允许 JS 修改页面内容呢。\")]),e._v(\" \"),a(\"p\",[e._v(\"基于以上需求，浏览器就需要把 HTML 转变成 DOM，HTML 是一棵树，DOM 也是一棵树。对 DOM 的理解，可以暂时先抛开浏览器的内部因素，先从 JS 着手，即可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/2/23/161c1050cf00d5bd?w=2102&h=1612&f=png&s=806057\",alt:\"DOM图示\"}})]),e._v(\" \"),a(\"h3\",{attrs:{id:\"获取-dom-节点\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#获取-dom-节点\"}},[e._v(\"#\")]),e._v(\" 获取 DOM 节点\")]),e._v(\" \"),a(\"p\",[e._v(\"最常用的 DOM API 就是获取节点，其中常用的获取方法如下面代码示例：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// 通过 id 获取\\nvar div1 = document.getElementById('div1') // 元素\\n\\n// 通过 tagname 获取\\nvar divList = document.getElementsByTagName('div')  // 集合\\nconsole.log(divList.length)\\nconsole.log(divList[0])\\n\\n// 通过 class 获取\\nvar containerList = document.getElementsByClassName('container') // 集合\\n\\n// 通过 CSS 选择器获取\\nvar pList = document.querySelectorAll('p') // 集合\\n\\n\")])])]),a(\"blockquote\",[a(\"p\",[e._v(\"题目：property 和 attribute 的区别是什么？\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"property\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#property\"}},[e._v(\"#\")]),e._v(\" property\")]),e._v(\" \"),a(\"p\",[e._v(\"DOM 节点就是一个 JS 对象，它符合之前讲述的对象的特征 —— 可扩展属性，因为 DOM 节点本质上也是一个 JS 对象。因此，如下代码所示，\"),a(\"code\",[e._v(\"p\")]),e._v(\"可以有\"),a(\"code\",[e._v(\"style\")]),e._v(\"属性，有\"),a(\"code\",[e._v(\"className\")]),e._v(\" \"),a(\"code\",[e._v(\"nodeName\")]),e._v(\" \"),a(\"code\",[e._v(\"nodeType\")]),e._v(\"属性。注意，\"),a(\"strong\",[e._v(\"这些都是 JS 范畴的属性，符合 JS 语法标准的\")]),e._v(\"。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"var pList = document.querySelectorAll('p')\\nvar p = pList[0]\\nconsole.log(p.style.width)  // 获取样式\\np.style.width = '100px'  // 修改样式\\nconsole.log(p.className)  // 获取 class\\np.className = 'p1'  // 修改 class\\n\\n// 获取 nodeName 和 nodeType\\nconsole.log(p.nodeName)\\nconsole.log(p.nodeType)\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"attribute\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#attribute\"}},[e._v(\"#\")]),e._v(\" attribute\")]),e._v(\" \"),a(\"p\",[e._v(\"property 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。attribute 就是对 HTML 属性的 get 和 set，和 DOM 节点的 JS 范畴的 property 没有关系。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"var pList = document.querySelectorAll('p')\\nvar p = pList[0]\\np.getAttribute('data-name')\\np.setAttribute('data-name', 'juejin')\\np.getAttribute('style')\\np.setAttribute('style', 'font-size:30px;')\\n\\n\")])])]),a(\"p\",[e._v(\"而且，get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"题目：DOM 操作的基本 API 有哪些？\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"dom-树操作\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dom-树操作\"}},[e._v(\"#\")]),e._v(\" DOM 树操作\")]),e._v(\" \"),a(\"p\",[e._v(\"新增节点\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"var div1 = document.getElementById('div1')\\n\\n// 添加新节点\\nvar p1 = document.createElement('p')\\np1.innerHTML = 'this is p1'\\ndiv1.appendChild(p1) // 添加新创建的元素\\n\\n// 移动已有节点。注意，这里是“移动”，并不是拷贝\\nvar p2 = document.getElementById('p2')\\ndiv1.appendChild(p2)\\n\\n\")])])]),a(\"p\",[e._v(\"获取父元素\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"var div1 = document.getElementById('div1')\\nvar parent = div1.parentElement\\n\\n\")])])]),a(\"p\",[e._v(\"获取子元素\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"var div1 = document.getElementById('div1')\\nvar child = div1.childNodes\\n\\n\")])])]),a(\"p\",[e._v(\"删除节点\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"var div1 = document.getElementById('div1')\\nvar child = div1.childNodes\\ndiv1.removeChild(child[0])\\n\\n\")])])]),a(\"p\",[e._v(\"还有其他操作的API，例如获取前一个节点、获取后一个节点等，但是面试过程中经常考到的就是上面几个。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"h2\",{attrs:{id:\"事件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事件\"}},[e._v(\"#\")]),e._v(\" 事件\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"事件绑定\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事件绑定\"}},[e._v(\"#\")]),e._v(\" 事件绑定\")]),e._v(\" \"),a(\"p\",[e._v(\"普通的事件绑定写法如下：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"var btn = document.getElementById('btn1')\\nbtn.addEventListener('click', function (event) {\\n    // event.preventDefault() // 阻止默认行为\\n    // event.stopPropagation() // 阻止冒泡\\n    console.log('clicked')\\n})\\n\\n\")])])]),a(\"p\",[e._v(\"为了编写简单的事件绑定，可以编写通用的事件绑定函数。这里虽然比较简单，但是会随着后文的讲解，来继续完善和丰富这个函数。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// 通用的事件绑定函数\\nfunction bindEvent(elem, type, fn) {\\n    elem.addEventListener(type, fn)\\n}\\nvar a = document.getElementById('link1')\\n// 写起来更加简单了\\nbindEvent(a, 'click', function(e) {\\n    e.preventDefault() // 阻止默认行为\\n    alert('clicked')\\n})\\n\\n\")])])]),a(\"p\",[e._v(\"最后，\"),a(\"strong\",[e._v(\"如果面试被问到 IE 低版本兼容性问题，我劝你果断放弃这份工作机会\")]),e._v(\"。现在互联网流量都在 App 上， IE 占比越来越少，再去为 IE 浪费青春不值得，要尽量去做 App 相关的工作。\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"题目：什么是事件冒泡？\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"事件冒泡\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事件冒泡\"}},[e._v(\"#\")]),e._v(\" 事件冒泡\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('<body>\\n    <div id=\"div1\">\\n        <p id=\"p1\">激活</p>\\n        <p id=\"p2\">取消</p>\\n        <p id=\"p3\">取消</p>\\n        <p id=\"p4\">取消</p>\\n    </div>\\n    <div id=\"div2\">\\n        <p id=\"p5\">取消</p>\\n        <p id=\"p6\">取消</p>\\n    </div>\\n</body>\\n\\n')])])]),a(\"p\",[e._v(\"对于以上 HTML 代码结构，要求点击\"),a(\"code\",[e._v(\"p1\")]),e._v(\"时候进入激活状态，点击其他任何\"),a(\"code\",[e._v(\"<p>\")]),e._v(\"都取消激活状态，如何实现？代码如下，注意看注释：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"var body = document.body\\nbindEvent(body, 'click', function (e) {\\n    // 所有 p 的点击都会冒泡到 body 上，因为 DOM 结构中 body 是 p 的上级节点，事件会沿着 DOM 树向上冒泡\\n    alert('取消')\\n})\\n\\nvar p1 = document.getElementById('p1')\\nbindEvent(p1, 'click', function (e) {\\n    e.stopPropagation() // 阻止冒泡\\n    alert('激活')\\n})\\n\\n\\n\")])])]),a(\"p\",[e._v(\"如果我们在\"),a(\"code\",[e._v(\"p1\")]),e._v(\" \"),a(\"code\",[e._v(\"div1\")]),e._v(\" \"),a(\"code\",[e._v(\"body\")]),e._v(\"中都绑定了事件，它是会根据 DOM 的结构来冒泡，从下到上挨个执行的。但是我们使用\"),a(\"code\",[e._v(\"e.stopPropagation()\")]),e._v(\"就可以阻止冒泡\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"题目：如何使用事件代理？有何好处？\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"事件代理\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#事件代理\"}},[e._v(\"#\")]),e._v(\" 事件代理\")]),e._v(\" \"),a(\"p\",[e._v(\"我们设定一种场景，如下代码，一个\"),a(\"code\",[e._v(\"<div>\")]),e._v(\"中包含了若干个\"),a(\"code\",[e._v(\"<a>\")]),e._v(\"，而且还能继续增加。那如何快捷方便地为所有\"),a(\"code\",[e._v(\"<a>\")]),e._v(\"绑定事件呢？\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('<div id=\"div1\">\\n    <a href=\"#\">a1</a>\\n    <a href=\"#\">a2</a>\\n    <a href=\"#\">a3</a>\\n    <a href=\"#\">a4</a>\\n</div>\\n<button>点击增加一个 a 标签</button>\\n\\n')])])]),a(\"p\",[e._v(\"这里就会用到事件代理。我们要监听\"),a(\"code\",[e._v(\"<a>\")]),e._v(\"的事件，但要把具体的事件绑定到\"),a(\"code\",[e._v(\"<div>\")]),e._v(\"上，然后看事件的触发点是不是\"),a(\"code\",[e._v(\"<a>\")]),e._v(\"。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"var div1 = document.getElementById('div1')\\ndiv1.addEventListener('click', function (e) {\\n    // e.target 可以监听到触发点击事件的元素是哪一个\\n    var target = e.target\\n    if (e.nodeName === 'A') {\\n        // 点击的是 <a> 元素\\n        alert(target.innerHTML)\\n    }\\n})\\n\\n\")])])]),a(\"p\",[e._v(\"我们现在完善一下之前写的通用事件绑定函数，加上事件代理。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"function bindEvent(elem, type, selector, fn) {\\n    // 这样处理，可接收两种调用方式 bindEvent(div1, 'click', 'a', function () {...}) 和 bindEvent(div1, 'click', function () {...}) 这两种\\n    if (fn == null) {\\n        fn = selector\\n        selector = null\\n    }\\n\\n    // 绑定事件\\n    elem.addEventListener(type, function (e) {\\n        var target\\n        if (selector) {\\n            // 有 selector 说明需要做事件代理\\n            // 获取触发时间的元素，即 e.target\\n            target = e.target\\n            // 看是否符合 selector 这个条件\\n            if (target.matches(selector)) {\\n                fn.call(target, e)\\n            }\\n        } else {\\n            // 无 selector ，说明不需要事件代理\\n            fn(e)\\n        }\\n    })\\n}\\n\\n\")])])]),a(\"p\",[e._v(\"然后这样使用，简单很多。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// 使用代理，bindEvent 多一个 'a' 参数\\nvar div1 = document.getElementById('div1')\\nbindEvent(div1, 'click', 'a', function (e) {\\n    console.log(this.innerHTML)\\n})\\n\\n// 不使用代理\\nvar a = document.getElementById('a1')\\nbindEvent(div1, 'click', function (e) {\\n    console.log(a.innerHTML)\\n})\\n\\n\")])])]),a(\"p\",[e._v(\"最后，使用代理的优点如下：\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"使代码简洁\")]),e._v(\" \"),a(\"li\",[e._v(\"减少浏览器的内存占用\")])]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"h2\",{attrs:{id:\"ajax\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#ajax\"}},[e._v(\"#\")]),e._v(\" Ajax\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"xmlhttprequest\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#xmlhttprequest\"}},[e._v(\"#\")]),e._v(\" XMLHttpRequest\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"题目：手写 XMLHttpRequest 不借助任何库\")])]),e._v(\" \"),a(\"p\",[e._v(\"这是很多奇葩的、个性的面试官经常用的手段。这种考查方式存在很多争议，但是你不能完全说它是错误的，毕竟也是考查对最基础知识的掌握情况。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('var xhr = new XMLHttpRequest()\\nxhr.onreadystatechange = function () {\\n    // 这里的函数异步执行，可参考之前 JS 基础中的异步模块\\n    if (xhr.readyState == 4) {\\n        if (xhr.status == 200) {\\n            alert(xhr.responseText)\\n        }\\n    }\\n}\\nxhr.open(\"GET\", \"/api\", false)\\nxhr.send(null)\\n\\n')])])]),a(\"p\",[e._v(\"当然，使用 jQuery、Zepto 或 Fetch 等库来写就更加简单了，这里不再赘述。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"状态码说明\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#状态码说明\"}},[e._v(\"#\")]),e._v(\" 状态码说明\")]),e._v(\" \"),a(\"p\",[e._v(\"上述代码中，有两处状态码需要说明。\"),a(\"code\",[e._v(\"xhr.readyState\")]),e._v(\"是浏览器判断请求过程中各个阶段的，\"),a(\"code\",[e._v(\"xhr.status\")]),e._v(\"是 HTTP 协议中规定的不同结果的返回状态说明。\")]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"xhr.readyState\")]),e._v(\"的状态码说明：\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"0 -代理被创建，但尚未调用 \"),a(\"code\",[e._v(\"open()\")]),e._v(\" 方法。\")]),e._v(\" \"),a(\"li\",[e._v(\"1 -\"),a(\"code\",[e._v(\"open()\")]),e._v(\" 方法已经被调用。\")]),e._v(\" \"),a(\"li\",[e._v(\"2 -\"),a(\"code\",[e._v(\"send()\")]),e._v(\" 方法已经被调用，并且头部和状态已经可获得。\")]),e._v(\" \"),a(\"li\",[e._v(\"3 -下载中， \"),a(\"code\",[e._v(\"responseText\")]),e._v(\" 属性已经包含部分数据。\")]),e._v(\" \"),a(\"li\",[e._v(\"4 -下载操作已完成\")])]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"题目：HTTP 协议中，response 的状态码，常见的有哪些？\")])]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"xhr.status\")]),e._v(\"即 HTTP 状态码，有 \"),a(\"code\",[e._v(\"2xx\")]),e._v(\" \"),a(\"code\",[e._v(\"3xx\")]),e._v(\" \"),a(\"code\",[e._v(\"4xx\")]),e._v(\" \"),a(\"code\",[e._v(\"5xx\")]),e._v(\" 这几种，比较常用的有以下几种：\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"code\",[e._v(\"200\")]),e._v(\" 正常\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"3xx\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"code\",[e._v(\"301\")]),e._v(\" 永久重定向。如\"),a(\"code\",[e._v(\"http://xxx.com\")]),e._v(\"这个 GET 请求（最后没有\"),a(\"code\",[e._v(\"/\")]),e._v(\"），就会被\"),a(\"code\",[e._v(\"301\")]),e._v(\"到\"),a(\"code\",[e._v(\"http://xxx.com/\")]),e._v(\"（最后是\"),a(\"code\",[e._v(\"/\")]),e._v(\"）\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"302\")]),e._v(\" 临时重定向。临时的，不是永久的\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"304\")]),e._v(\" 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有\"),a(\"code\",[e._v(\"If-Modified-Since: xxx\")]),e._v(\"（要求返回更新时间是\"),a(\"code\",[e._v(\"xxx\")]),e._v(\"时间之后的资源），如果此时服务器 端资源未更新，则会返回\"),a(\"code\",[e._v(\"304\")]),e._v(\"，即不符合要求\")])])]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"404\")]),e._v(\" 找不到资源\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"5xx\")]),e._v(\" 服务器端出错了\")])]),e._v(\" \"),a(\"p\",[e._v(\"看完要明白，为何上述代码中要同时满足\"),a(\"code\",[e._v(\"xhr.readyState == 4\")]),e._v(\"和\"),a(\"code\",[e._v(\"xhr.status == 200\")]),e._v(\"。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"fetch-api\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#fetch-api\"}},[e._v(\"#\")]),e._v(\" Fetch API\")]),e._v(\" \"),a(\"p\",[e._v(\"目前已经有一个获取 HTTP 请求更加方便的 API：\"),a(\"code\",[e._v(\"Fetch\")]),e._v(\"，通过\"),a(\"code\",[e._v(\"Fetch\")]),e._v(\"提供的\"),a(\"code\",[e._v(\"fetch()\")]),e._v(\"这个全局函数方法可以很简单地发起异步请求，并且支持\"),a(\"code\",[e._v(\"Promise\")]),e._v(\"的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 \"),a(\"a\",{attrs:{href:\"https://caniuse.com/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"caniuse\"),a(\"OutboundLink\")],1),e._v(\"，看下其浏览器兼容情况。\")]),e._v(\" \"),a(\"p\",[e._v(\"看一个简单的例子：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"fetch('some/api/data.json', {\\n  method:'POST', //请求类型 GET、POST\\n  headers:{}, // 请求的头信息，形式为 Headers 对象或 ByteString\\n  body:{}, //请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get 或head 方法中不能包含 body）\\n  mode:'', //请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin\\n  credentials:'', //cookie 的跨域策略，如 omit、same-origin 或 include\\n  cache:'', //请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached\\n}).then(function(response) { ... });\\n\\n\")])])]),a(\"p\",[a(\"code\",[e._v(\"Fetch\")]),e._v(\" 支持\"),a(\"code\",[e._v(\"headers\")]),e._v(\"定义，通过\"),a(\"code\",[e._v(\"headers\")]),e._v(\"自定义可以方便地实现多种请求方法（ PUT、GET、POST 等）、请求头（包括跨域）和\"),a(\"code\",[e._v(\"cache\")]),e._v(\"策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和\"),a(\"code\",[e._v(\"formData\")]),e._v(\"等。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"跨域\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#跨域\"}},[e._v(\"#\")]),e._v(\" 跨域\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"题目：如何实现跨域？\")])]),e._v(\" \"),a(\"p\",[e._v(\"浏览器中有 \"),a(\"strong\",[e._v(\"同源策略\")]),e._v(\" ，即一个域下的页面中，无法通过 Ajax 获取到其他域的接口。例如有一个接口\"),a(\"code\",[e._v(\"http://m.juejin.com/course/ajaxcourserecom?cid=459\")]),e._v(\"，你自己的一个页面\"),a(\"code\",[e._v(\"http://www.yourname.com/page1.html\")]),e._v(\"中的 Ajax 无法获取这个接口。这正是命中了“同源策略”。如果浏览器哪些地方忽略了同源策略，那就是浏览器的安全漏洞，需要紧急修复。\")]),e._v(\" \"),a(\"p\",[e._v(\"url 哪些地方不同算作跨域？\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"协议\")]),e._v(\" \"),a(\"li\",[e._v(\"域名\")]),e._v(\" \"),a(\"li\",[e._v(\"端口\")])]),e._v(\" \"),a(\"p\",[e._v(\"但是 HTML 中几个标签能逃避过同源策略——\"),a(\"code\",[e._v('<script src=\"xxx\">')]),e._v(\"、\"),a(\"code\",[e._v('<img src=\"xxxx\"/>')]),e._v(\"、\"),a(\"code\",[e._v('<link href=\"xxxx\">')]),e._v(\"，这三个标签的\"),a(\"code\",[e._v(\"src/href\")]),e._v(\"可以加载其他域的资源，不受同源策略限制。\")]),e._v(\" \"),a(\"p\",[e._v(\"因此，这使得这三个标签可以做一些特殊的事情。\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"code\",[e._v(\"<img>\")]),e._v(\"可以做打点统计，因为统计方并不一定是同域的，在讲解 JS 基础知识异步的时候有过代码示例。除了能跨域之外，\"),a(\"code\",[e._v(\"<img>\")]),e._v(\"几乎没有浏览器兼容问题，它是一个非常古老的标签。\")]),e._v(\" \"),a(\"li\",[a(\"code\",[e._v(\"<script>\")]),e._v(\"和\"),a(\"code\",[e._v(\"<link>\")]),e._v(\"可以使用 CDN，CDN 基本都是其他域的链接。\")]),e._v(\" \"),a(\"li\",[e._v(\"另外\"),a(\"code\",[e._v(\"<script>\")]),e._v(\"还可以实现 JSONP，能获取其他域接口的信息，接下来马上讲解。\")])]),e._v(\" \"),a(\"p\",[e._v(\"但是请注意，所有的跨域请求方式，最终都需要信息提供方来做出相应的支持和改动，也就是要经过信息提供方的同意才行，否则接收方是无法得到它们的信息的，浏览器是不允许的。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"解决跨域-jsonp\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#解决跨域-jsonp\"}},[e._v(\"#\")]),e._v(\" 解决跨域 - JSONP\")]),e._v(\" \"),a(\"p\",[e._v(\"首先，有一个概念你要明白，例如访问\"),a(\"code\",[e._v(\"http://coding.m.juejin.com/classindex.html\")]),e._v(\"的时候，服务器端就一定有一个\"),a(\"code\",[e._v(\"classindex.html\")]),e._v(\"文件吗？—— 不一定，服务器可以拿到这个请求，动态生成一个文件，然后返回。 同理，\"),a(\"code\",[e._v('<script src=\"http://coding.m.juejin.com/api.js\">')]),e._v(\"也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。OK，接下来正式开始。\")]),e._v(\" \"),a(\"p\",[e._v(\"例如我们的网站和掘金网，肯定不是一个域。我们需要掘金网提供一个接口，供我们来获取。首先，我们在自己的页面这样定义\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"<script>\\nwindow.callback = function (data) {\\n    // 这是我们跨域得到信息\\n    console.log(data)\\n}\\n<\\/script>\\n\\n\")])])]),a(\"p\",[e._v(\"然后掘金网给我提供了一个\"),a(\"code\",[e._v(\"http://coding.m.juejin.com/api.js\")]),e._v(\"，内容如下（之前说过，服务器可动态生成内容）\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"callback({x:100, y:200})\\n\\n\")])])]),a(\"p\",[e._v(\"最后我们在页面中加入\"),a(\"code\",[e._v('<script src=\"http://coding.m.juejin.com/api.js\"><\\/script>')]),e._v(\"，那么这个js加载之后，就会执行内容，我们就得到内容了。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"解决跨域-服务器端设置-http-header\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#解决跨域-服务器端设置-http-header\"}},[e._v(\"#\")]),e._v(\" 解决跨域 - 服务器端设置 http header\")]),e._v(\" \"),a(\"p\",[e._v(\"这是需要在服务器端设置的，作为前端工程师我们不用详细掌握，但是要知道有这么个解决方案。而且，现在推崇的跨域解决方案是这一种，比 JSONP 简单许多。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('response.setHeader(\"Access-Control-Allow-Origin\", \"http://m.juejin.com/\");  // 第二个参数填写允许跨域的域名称，不建议直接写 \"*\"\\nresponse.setHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\\nresponse.setHeader(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\");\\n\\n// 接收跨域的cookie\\nresponse.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\\n\\n')])])]),a(\"hr\"),e._v(\" \"),a(\"h2\",{attrs:{id:\"存储\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#存储\"}},[e._v(\"#\")]),e._v(\" 存储\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"题目：cookie 和 localStorage 有何区别？\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"cookie\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cookie\"}},[e._v(\"#\")]),e._v(\" cookie\")]),e._v(\" \"),a(\"p\",[e._v(\"cookie 本身不是用来做服务器端存储的（计算机领域有很多这种“狗拿耗子”的例子，例如 CSS 中的 float），它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。\")]),e._v(\" \"),a(\"p\",[e._v(\"使用起来也非常简单，\"),a(\"code\",[e._v(\"document.cookie = ....\")]),e._v(\"即可。\")]),e._v(\" \"),a(\"p\",[e._v(\"但是 cookie 有它致命的缺点：\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"存储量太小，只有 4KB\")]),e._v(\" \"),a(\"li\",[e._v(\"所有 HTTP 请求都带着，会影响获取资源的效率\")]),e._v(\" \"),a(\"li\",[e._v(\"API 简单，需要封装才能用\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"localstorage-和-sessionstorage\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#localstorage-和-sessionstorage\"}},[e._v(\"#\")]),e._v(\" localStorage 和 sessionStorage\")]),e._v(\" \"),a(\"p\",[e._v(\"后来，HTML5 标准就带来了\"),a(\"code\",[e._v(\"sessionStorage\")]),e._v(\"和\"),a(\"code\",[e._v(\"localStorage\")]),e._v(\"，先拿\"),a(\"code\",[e._v(\"localStorage\")]),e._v(\"来说，它是专门为了浏览器端缓存而设计的。其优点有：\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"存储量增大到 5MB\")]),e._v(\" \"),a(\"li\",[e._v(\"不会带到 HTTP 请求中\")]),e._v(\" \"),a(\"li\",[e._v(\"API 适用于数据存储 \"),a(\"code\",[e._v(\"localStorage.setItem(key, value)\")]),e._v(\" \"),a(\"code\",[e._v(\"localStorage.getItem(key)\")])])]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"sessionStorage\")]),e._v(\"的区别就在于它是根据 session 过去时间而实现，而\"),a(\"code\",[e._v(\"localStorage\")]),e._v(\"会永久有效，应用场景不同。例如，一些需要及时失效的重要信息放在\"),a(\"code\",[e._v(\"sessionStorage\")]),e._v(\"中，一些不重要但是不经常设置的信息，放在\"),a(\"code\",[e._v(\"localStorage\")]),e._v(\"中。\")]),e._v(\" \"),a(\"p\",[e._v(\"另外告诉大家一个小技巧，针对\"),a(\"code\",[e._v(\"localStorage.setItem\")]),e._v(\"，使用时尽量加入到\"),a(\"code\",[e._v(\"try-catch\")]),e._v(\"中，某些浏览器是禁用这个 API 的，要注意。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"h2\",{attrs:{id:\"小结\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[e._v(\"#\")]),e._v(\" 小结\")]),e._v(\" \"),a(\"p\",[e._v(\"本小节总结了 W3C 标准中 Web-API 部分，面试中常考的知识点，这些也是日常开发中最常用的 API 和知识。\")])])}),[],!1,null,null,null);t.default=v.exports}}]);","extractedComments":[]}