{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[243],{599:function(e,t,a){\"use strict\";a.r(t);var s=a(42),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"拓展篇-2-系统稳定性测试-使用-lab-code\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#拓展篇-2-系统稳定性测试-使用-lab-code\"}},[e._v(\"#\")]),e._v(\" 拓展篇 2：系统稳定性测试 —— 使用 Lab & Code\")]),e._v(\" \"),a(\"p\",[e._v(\"测试框架，是运行测试的工具。通过它，可以为 JavaScript 应用添加测试，从而保证代码的质量。现行的 Javascript 常用流行测试库有 Jasmine，Mocha， Karma 等，虽然框架的名称不同，但背后的核心套件却大同小异。\")]),e._v(\" \"),a(\"p\",[e._v(\"以常见的 JavaScript 单元测试框架 Mocha 为例。我们要为一个求和模块 \"),a(\"code\",[e._v(\"sum\")]),e._v(\" 方法来做一个简单的单元测试：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// sum.js\\n\\nmodule.exports = (x, y) => x + y\\n\\n// sum.test.js\\n\\nconst sum = require('./sum.js');\\nconst expect = require('chai').expect;\\n\\n// 测试套件(test suite) -- describe\\ndescribe('求和模块的测试', () => {\\n  // 测试用例(test case) -- it\\n  it('1 加 2 应该等于 3', () => {\\n    // 测试断言(test expect) -- expect\\n    expect(sum(1, 2)).to.be.equal(3);\\n  });\\n});\\n\\n\")])])]),a(\"p\",[e._v(\"由案例中的注视标记可以大致了解到单元测试的三个关键术语：\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"strong\",[e._v(\"describe\")]),e._v(\"：测试套件\")]),e._v(\" \"),a(\"li\",[a(\"strong\",[e._v(\"it\")]),e._v(\"：测试用例\")]),e._v(\" \"),a(\"li\",[a(\"strong\",[e._v(\"expect\")]),e._v(\"：测试断言\")])]),e._v(\" \"),a(\"p\",[e._v(\"一个完整的测试，可以由多个 describe 组成； 每个 describe 里可以包含多个 describe 或者多个 it ； 每个 it 里可以包涵多个 expect，来最终描述每个测试用例，得到最终的程序执行结果校验。\")]),e._v(\" \"),a(\"p\",[e._v(\"其他还有一些高级的属性，诸如 before / after / beforeEach / afterEach 等测试用例生命周期的钩子，以及其他特性，我们可以后续再系统学习。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"lab-code\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lab-code\"}},[e._v(\"#\")]),e._v(\" Lab & Code\")]),e._v(\" \"),a(\"p\",[e._v(\"Lab & Code 是 hapi 的配套测试框架。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"lab\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lab\"}},[e._v(\"#\")]),e._v(\" Lab\")]),e._v(\" \"),a(\"p\",[e._v(\"Lab 库支持 async/await，尽可能保持测试引擎的足够简单，并包含了我们希望从现代 Node.js 测试框架程序中需要的所有特性。提供了 describe 和 it，以及生命周期的钩子等功能。\")]),e._v(\" \"),a(\"p\",[e._v(\"Lab 仅使用 async/await 功能，并包含了你希望从现代 Node.js测试框架程序中需要的所有特性。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"code\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#code\"}},[e._v(\"#\")]),e._v(\" Code\")]),e._v(\" \"),a(\"p\",[e._v(\"Code 库用于提供 expect 断言的相关函数库，code-expect 与 mocha-expect 用法上几乎完全一致。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"使用-lab-code-测试求和模块\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-lab-code-测试求和模块\"}},[e._v(\"#\")]),e._v(\" 使用 Lab & Code 测试求和模块\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// sum.js\\n\\nmodule.exports = (x, y) => x + y\\n\\n// sum.test.js\\nvar const = require('./sum.js');\\n// requires for testing\\nconst Code        = require('code');\\nconst Lab         = require('lab');\\nconst lab         = Lab.script();\\n\\n// 测试框架方法提取\\nconst describe    = lab.describe;\\nconst it          = lab.it;\\nconst expect      = Code.expect;\\n\\n// 测试套件(test suite) -- describe\\ndescribe('求和模块的测试', () => {\\n  // 测试用例(test case) -- it\\n  it('1 加 2 应该等于 3', () => {\\n    // 测试断言(test expect) -- expect\\n    expect(sum(1, 2)).to.equal(3);\\n  });\\n});\\n\\n\")])])]),a(\"p\",[e._v(\"执行单元测试命令 \"),a(\"code\",[e._v(\"node node_modules/lab/bin/lab -v\")]),e._v(\"。 \"),a(\"code\",[e._v(\"-v\")]),e._v(\" 的参数打印测试明细，在只想关注错误的测试用例结果时，可以不带上此参数，保持控制台信息输出的简洁性。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"  # 执行结果\\n  求和模块的测试\\n    ✓ 1 加 2 应该等于 3\\n\\n  1 tests complete\\n  Test duration: 236 ms\\n  No global variable leaks detected\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"在-hapi-中测试-api-接口\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在-hapi-中测试-api-接口\"}},[e._v(\"#\")]),e._v(\" 在 hapi 中测试 API 接口\")]),e._v(\" \"),a(\"p\",[e._v(\"以测试用户登录为例，我们希望测试接口的异步调用是否返回 200 的状态编码，并且返回的 response 的 result 中，签发的 JWT payload 中的信息如 userid、openid 符合预期。\")]),e._v(\" \"),a(\"p\",[e._v(\"hapi 的测试用例中，直接使用 app.inject，即服务器 server 自身的 API，来实现指定接口的调用。代码如下：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// users.test.js\\n\\nconst app = require('../app.js')\\n\\n// appJWT 用于暂存已登录的用户jwt，供后续需要 jwt 登录认证的测试套件使用\\nlet appJWT = ''\\ndescribe(\\\"POST: /user/login-jwt-test\\\", () => {  \\n  it(\\\"状态码200并且返回了正确的jwt\\\", async() => {\\n    const response = await app.inject({\\n      method: 'POST',\\n      url: '/users/login-jwt-test'\\n    })\\n    expect(response.statusCode).to.equal(200)\\n    const JWT = require('jsonwebtoken')\\n    appJWT = response.result\\n    const jwtPayload = JWT.decode(response.result)\\n    expect(jwtPayload.userId).to.equal(1)\\n    expect(jwtPayload.openId).to.equal(1)\\n  })\\n})\\n\\n// 获取店铺列表需要用到 authorization 的 jwt 验证，语法实现如下\\ndescribe(\\\"GET /shops\\\", () => {\\n  it(\\\"状态码200\\\", async() => {\\n    const response = await app.inject({\\n      method: 'GET',\\n      url: '/shops',\\n      headers: {\\n        authorization: appJWT\\n      }\\n    })\\n    expect(response.statusCode).to.equal(200)  \\n  })\\n})\\n\\n\")])])]),a(\"p\",[e._v(\"hapi 的单元测试框架还会在执行基础测试后，贴心地检测系统中是否存在有全局变量，例如下述的全局变量声明：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"foo = 'bar';\\nhello = 'hapi';\\n\\n\")])])]),a(\"p\",[e._v(\"在运行完测试后，会红字提示： \"),a(\"em\",[e._v(\"The following leaks were detected:foo，hello\")]),e._v(\"，引起开发者的重视。\")]),e._v(\" \"),a(\"p\",[e._v(\"而 \"),a(\"em\",[e._v(\"No global variable leaks detected\")]),e._v(\" 的结果，则表示系统中不存在任何的全局变量，较好地确保了变量作用域的安全可靠性。\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"常用的断言表达式\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#常用的断言表达式\"}},[e._v(\"#\")]),e._v(\" 常用的断言表达式\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// 相等或不相等 equal()\\nexpect(1 + 2).to.be.equal(3);\\nexpect(1 + 2).to.be.not.equal(4);\\nexpect(hello).to.be.deep.equal({ hapi: 'hapi' });\\n\\n// 布尔值检测 boolean\\nexpect(true).to.be.true();\\nexpect(false).to.not.be.false();\\n\\n// 数据类型检测 type\\nexpect('hapi').to.be.a.string();\\nexpect({ hello: 'hapi' }).to.be.an.object();\\nexpect(hello).to.be.an.instanceof(Hello);\\n\\n// 包含检测 include\\nexpect([1,2,3]).to.include(2);\\nexpect('hello hapi').to.contain('hapi');\\nexpect({ hello: 'hapi' }).to.include.keys('hello');\\n\\n// 判空检测 empty()\\nexpect('').to.be.empty();\\nexpect([]).to.be.empty();\\nexpect({}).to.be.empty();\\n\\n// 正则匹配 match()\\nexpect('foobar').to.match(/^foo/);\\n\\n// 断言条件与 and\\nexpect('hello hapi').to.be.a.string().and.contain('hapi');\\n\\n\")])])]),a(\"blockquote\",[a(\"p\",[a(\"a\",{attrs:{href:\"https://github.com/hapijs/code/blob/master/API.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"断言表达式详细手册\"),a(\"OutboundLink\")],1),e._v(\"。\")])]),e._v(\" \"),a(\"h2\",{attrs:{id:\"coverage\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#coverage\"}},[e._v(\"#\")]),e._v(\" coverage\")]),e._v(\" \"),a(\"p\",[e._v(\"coverage 用于量化代码的被测试的比例与程度。被测试的代码数量处以总代码量所得的比例即为覆盖率值。\")]),e._v(\" \"),a(\"p\",[e._v(\"开启测试覆盖率，可以帮助我们快速定位测试用例所未涵盖的代码区域，决定是否追加测试用例，并且高覆盖率的测试用例，能在一定程度上确保我们的系统基础可执行性。\")]),e._v(\" \"),a(\"p\",[e._v(\"执行 \"),a(\"code\",[e._v(\"node node_modules/lab/bin/lab -v -c\")]),e._v(\"，追加的 \"),a(\"code\",[e._v(\"-c\")]),e._v(\" 可以额外统计测试用例的覆盖率。覆盖率的测试结果会以比例与未覆盖明细的方式输出显示。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"Coverage: 92.26% (57/736)\\nmodels/index.js missing coverage on line(s): 35, 41, 49, 50\\nroutes/hello-hapi.js missing coverage on line(s): 8, 9\\n\\n\")])])]),a(\"p\",[e._v(\"当然，实际的项目实践中，业务型系统做得越深，代码覆盖率 100% 的实现成本也会越来越高。能效与稳定性之间的平衡点会存在一个分寸的问题，盲目追求 100% 是极度不可取的。我们有几种手法可以帮助优化 coverage 的质量。\")]),e._v(\" \"),a(\"p\",[e._v(\"1）使用 threshold\")]),e._v(\" \"),a(\"p\",[e._v(\"针对 coverage，可以设定一个 \"),a(\"code\",[e._v(\"-t (--threshold)\")]),e._v(\" 的参数，来设定一个域值。比如 \"),a(\"code\",[e._v(\"-t 80\")]),e._v(\" 表征覆盖率高于 80% 即满足要求，用来粗颗粒度降低覆盖标准。笔者以为，这样的域值调整意义不大，更多的是一种心理暗示。\")]),e._v(\" \"),a(\"p\",[e._v(\"2） 使用 \"),a(\"code\",[e._v(\"--coverage-exclude\")]),e._v(\" / \"),a(\"code\",[e._v(\"--coverage-path\")])]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"--coverage-exclude\")]),e._v(\" 与 \"),a(\"code\",[e._v(\"--coverage-exclude\")]),e._v(\" 可以帮助我们直接排除或指定一些目录或是单个文件，来更加明确覆盖率所要覆盖的目标，但精度仅限于文件。一些快速迭代的局部业务级代码，或是非核心主干的代码，可以采用这种方式。\")]),e._v(\" \"),a(\"p\",[e._v(\"3） 使用 \"),a(\"code\",[e._v(\"/* $lab:coverage:(off|on)$ */\")])]),e._v(\" \"),a(\"p\",[e._v(\"使用 \"),a(\"code\",[e._v(\"/* $lab:coverage:(off|on)$ */\")]),e._v(\" 可以帮助我们在最终单个文件中的任意代码部分，增加一个特殊约定的表达式，来标记不需要测试覆盖的局部代码，从而提升测试的有效覆盖率。例如：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"/* $lab:coverage:off$ */\\nif (typeof value === 'symbol') {\\n    // do something with value\\n}\\n/* $lab:coverage:on$ */\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"使用-labrc-js-来进行配置\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-labrc-js-来进行配置\"}},[e._v(\"#\")]),e._v(\" 使用 .labrc.js 来进行配置\")]),e._v(\" \"),a(\"p\",[e._v(\".labrc.js 是 Lab 的直观配置文件，我们把 .labrc.js 放在当前工程目录的根目录，后续执行 Lab 的指令，将自动从 .labrc.js 中提取相应的运行参数。下面是一个简单的例子等价于执行了 \"),a(\"code\",[e._v(\"lab -c -t 100\")]),e._v(\"。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"module.exports = {\\n  coverage: true, //开启覆盖率测试\\n  threshold: 100,  //覆盖率搁值为 100%\\n};\\n\\n\")])])]),a(\"blockquote\",[a(\"p\",[a(\"a\",{attrs:{href:\"https://github.com/hapijs/lab\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Lab 说明手册\"),a(\"OutboundLink\")],1),e._v(\"。\")])]),e._v(\" \"),a(\"h2\",{attrs:{id:\"小结\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[e._v(\"#\")]),e._v(\" 小结\")]),e._v(\" \"),a(\"p\",[e._v(\"关键词：单元测试，Lab，Code，coverage 覆盖率\")]),e._v(\" \"),a(\"p\",[e._v(\"本小节，我们介绍了如何使用 Lab & Code，解决测试用例过程中所需要解决的常见问题，从套件定义、用例声明，到最终的断言验证，并通过 coverage 量化测试用例的覆盖率。\")]),e._v(\" \"),a(\"p\",[e._v(\"基于 REST 接口的开发，一个相对好的习惯是先完成接口文档的书写。利用 hapi-swagger 和 Joi，可以高效地帮助我们完成接口文档化任务。接下来便是书写测试用例，将测试用例通过 BDD 或者 TDD 的方式，进行组合书写，最终得到一套文档完备、测试配套的良好接口。这是一个值得去持续实践优化与体会的好习惯。\")]),e._v(\" \"),a(\"p\",[a(\"strong\",[e._v(\"本小节参考代码汇总\")])]),e._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://github.com/hapijs/code/blob/master/API.md\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"断言表达式详细手册\"),a(\"OutboundLink\")],1)]),e._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"https://github.com/hapijs/lab\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Lab 说明手册\"),a(\"OutboundLink\")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);","extractedComments":[]}