{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{539:function(e,n,t){\"use strict\";t.r(n);var r=t(42),s=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"第-8-节-复杂数据处理-·-关系图谱\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#第-8-节-复杂数据处理-·-关系图谱\"}},[e._v(\"#\")]),e._v(\" 第 8 节 复杂数据处理 · 关系图谱\")]),e._v(\" \"),t(\"p\",[e._v(\"我们在上一节中用了一个企业中的人员结构作为树形结构的例子，在这棵树中其实节点与节点之间的边（Edge）所表达的是人员之间的上下级关系。而在日常生活中我们还有非常多并不存在上下层次的关系（人际关系、事物关系等等），就好比我们的人际交往中绝大部分都是平等的。而且在树形结构中节点之间的关系严格遵守不形成环的原则，然而在我们的人际交往关系中，环形关系结构则是必然存在的。\")]),e._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/4/29/16311ff0140c3772?w=271&h=221&f=png&s=9971\",alt:\"环形关系结构\"}})]),e._v(\" \"),t(\"p\",[e._v(\"当需要使用计算机编程来实现这种结构的时候，就需要用到\"),t(\"strong\",[e._v(\"关系图谱\")]),e._v(\"（Graph）。需要注意的是，关系图谱与我们平时所听到的图片是完完全全的两回事。图片是用于表达视觉效果的二维格式（包含点阵图和矢量图），而图形是一种多维的抽象结构，主要用于表达抽象事物之间的关系。\")]),e._v(\" \"),t(\"p\",[e._v(\"有趣的是我们刚学习完的树形结构其实是一种特殊的关系图谱，树形结构中所规定的是一种节点之间只能有上下级的关系，且不再重复。一棵树形结构中必然存在着根节点和叶节点，但是在关系图谱中却不一定存在明确的头尾节点，它可能是由一群看似杂乱无章的节点相互连接，并且彼此的连接还有一些各式各样的差异，如连接强度不同等。\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"_8-1-无向图\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-1-无向图\"}},[e._v(\"#\")]),e._v(\" 8.1 无向图\")]),e._v(\" \"),t(\"p\",[e._v(\"在 7.1.2 节中我们定义了一个用于树形结构的节点，在每一个树形节点中拥有一个来自父节点的引用、存储自身数据的空间和存储子节点引用的数组。\")]),e._v(\" \"),t(\"p\",[e._v(\"不过与树形结构存在区别的是，树形结构中节点之间的连接是带有方向属性的，即从父节点指向其子节点。而关系图谱存在着两种类型，\"),t(\"strong\",[e._v(\"无向图（Graph）\"),t(\"strong\",[e._v(\"和\")]),e._v(\"有向图（Directed Graph，或 Digraph）\")]),e._v(\"。其中树形结构正是一种特殊的、每两个顶点之间只有\"),t(\"strong\",[e._v(\"单向边\")]),e._v(\"的有向图。但正如上面的图所示，实际应用中同样存在着具有双向关系的有向图。所以在关系图谱中并不存在子节点这一概念，取而代之的则是\"),t(\"strong\",[e._v(\"相邻顶点（Adjacent Vertice）\")]),e._v(\"。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"_8-1-1-定义顶点\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-1-1-定义顶点\"}},[e._v(\"#\")]),e._v(\" 8.1.1 定义顶点\")]),e._v(\" \"),t(\"p\",[e._v(\"一般来说，因为关系图谱具有非常高的复杂性和不确定性，节点与节点之间的关系经常需要发生不同的变化，如果采取像上一节中树形结构中一样，使用引用来表示节点之间的关系，就会产生非常深的引用嵌套。而且 JavaScript 中的引用也无法满足我们表达节点之间关系数据的需求。\")]),e._v(\" \"),t(\"p\",[e._v(\"所以我们需要另辟蹊径，使用另外一种方式来描述一个关系图谱。我们在上一节的树形结构中，定义一个节点并不需要对其进行编号，因为稳定且单向的层级关系可以使得节点在树形结构中的位置会较为稳定。但这在关系图谱中情况则变得非常的复杂，而导致没办法使用这种简单的方式来完成，那么我们就需要对节点进行编号了。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Vertex {\\n  constructor(id, property) {\\n    this.id = id\\n    this.property = property\\n  }\\n}\\n\\nconst me = new Vertex(1, [ 'Will', 'male' ])\\n\\n\")])])]),t(\"p\",[e._v(\"那么问题来了，如果说我们在创建顶点的时候原数据并不带有能够标识每一个个体信息的标识符，就需要有一个能够产生具有唯一性的的标识符。业界通常会使用如 UUID（Universally Unique Identifier，通用唯一识别码）、数据库自增键值等方式。而我们这里可以简单地定义一个用于创建带有标识符的顶点的函数以方便我们使用。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"let vertexId = 0\\nfunction newVertex(property) {\\n  return new Vertex(++vertexId, property)\\n}\\n\\nconst me = newVertex([ 'Will', 'male' ])\\n\\n\")])])]),t(\"h3\",{attrs:{id:\"_8-1-2-定义边\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-1-2-定义边\"}},[e._v(\"#\")]),e._v(\" 8.1.2 定义边\")]),e._v(\" \"),t(\"p\",[e._v(\"定义好了关系图谱中的顶点之后，就需要开始定义我们用于表达节点之间关系的边了。而因为 JavaScript 中的引用并不能满足稀疏存储和附带信息的需求，所以我们同样需要为边定义一个类型以创建一个边对象。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Edge {\\n  constructor(leftId, rightId, property) {\\n    this.leftId = leftId\\n    this.rightId = rightId\\n    this.property = property\\n  }\\n}\\n\\nconst will = newVertex({\\n  name: 'Will',\\n  gender: 'male'\\n})\\nconst ru = newVertex({\\n  name: 'Rrrruu',\\n  gender: 'female'\\n})\\n\\nconst relation = new Edge(will.id, ru.id, 'couple')\\n\\n\")])])]),t(\"p\",[e._v(\"现在我们可以通过顶点对象中的 \"),t(\"code\",[e._v(\"id\")]),e._v(\" 属性取得该顶点的标识符，但若需要使用标识符来获取顶点对象本身，就需要别的实体来完成这个需求。而这样的任务我们可以交由关系图谱本身来完成。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"_8-1-3-图\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-1-3-图\"}},[e._v(\"#\")]),e._v(\" 8.1.3 图\")]),e._v(\" \"),t(\"p\",[e._v(\"既然我们对关系图谱中的顶点对象进行编号，以便进行检索，那么我们是不是可以使用同样的方式来对边对象进行编号以便进行检索呢？答案自然是肯定的。\")]),e._v(\" \"),t(\"p\",[e._v(\"相比于顶点对象只会从自身的 \"),t(\"code\",[e._v(\"id\")]),e._v(\" 被检索，边对象则会从与边相连的两个顶点被检索，所以更需要进行编号以提升检索的速度。通过对边对象的编号和关系的变换，我们可以整理出顶点与边的关系。\")]),e._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/4/29/16311ff01433688d?w=1598&h=814&f=png&s=101488\",alt:\"顶点与边的关系\"}})]),e._v(\" \"),t(\"p\",[e._v(\"整理好这些关系之后，我们就可以通过已经梳理好的逻辑来定义一个关系图谱的 JavaScript 类了。\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"对顶点进行编号，以优化对顶点的检索；\")]),e._v(\" \"),t(\"li\",[e._v(\"对边进行编号，并存储好边与顶点的关系。\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Graph {\\n  constructor(vertices, edges) {\\n\\n    // Vertices\\n    this.vertexIds = []\\n    this.vertices = {}\\n\\n    for (let i = 0; i < vertices.length; ++i) {\\n      const vertex = vertices[i]\\n\\n      this.vertexIds.push(vertex.id)\\n      this.vertices[vertex.id] = vertex\\n    }\\n\\n    const edgesWithId = edges.map(function(edge, i) {\\n      edge.id = i + 1\\n      return edge\\n    })\\n    \\n    // Edges\\n    this.edgeIds = []\\n    this.edges = {}\\n    this.edgeRelations = {}\\n\\n    for (let i = 0; i < edgesWithId.length; ++i) {\\n      const edge = edgesWithId[i]\\n\\n      this.edgeIds.push(edge.id)\\n      this.edges[edge.id] = edge\\n      \\n      // 初始化顶点与边的关系\\n      if (typeof this.edgeRelations[edge.leftId] === 'undefined') {\\n        this.edgeRelations[edge.leftId] = []\\n      }\\n\\n      if (typeof this.edgeRelations[edge.rightId] === 'undefined') {\\n        this.edgeRelations[edge.rightId] = []\\n      }\\n\\n      this.edgeRelations[edge.leftId].push(edge.id)\\n      this.edgeRelations[edge.rightId].push(edge.id)\\n    }\\n\\n  }\\n}\\n\\nconst vertices = [\\n  new Vertex(1, 'A'),\\n  new Vertex(2, 'B'),\\n  new Vertex(3, 'C'),\\n  new Vertex(4, 'D')\\n]\\n\\nconst edges = [\\n  new Edge(1, 2, 1),\\n  new Edge(1, 3, 2),\\n  new Edge(2, 4, 1),\\n  new Edge(3, 4, 1)\\n]\\n\\nconst graph = new Graph(vertices, edges)\\n\\n\")])])]),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/4/29/16311ff014b4caf0?w=231&h=231&f=png&s=8876\",alt:\"graph\"}})]),e._v(\" \"),t(\"h3\",{attrs:{id:\"_8-1-4-操作图形\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-1-4-操作图形\"}},[e._v(\"#\")]),e._v(\" 8.1.4 操作图形\")]),e._v(\" \"),t(\"p\",[e._v(\"完成了关系图谱的建立后，自然需要将其运用起来以配合算法来解决一些我们所面临的问题。但在实现算法之前自然不可能让算法直接涉及图对象中的内部元素，所以我们也需要先为关系图谱定义一些操作方法，如获取某一个顶点、遍历所有顶点、遍历所有边等。\")]),e._v(\" \"),t(\"h4\",{attrs:{id:\"获取某一个顶点\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#获取某一个顶点\"}},[e._v(\"#\")]),e._v(\" 获取某一个顶点\")]),e._v(\" \"),t(\"p\",[e._v(\"前面在关系图谱类中使用了 \"),t(\"code\",[e._v(\"vertexIds\")]),e._v(\" 存储顶点的标识符和使用 \"),t(\"code\",[e._v(\"vertices\")]),e._v(\" 来存储顶点对象。那么要获取图形中的某一个顶点，保险起见首先要确保在 \"),t(\"code\",[e._v(\"vertexIds\")]),e._v(\" 中存在该节点标识符，否则就直接返回 \"),t(\"code\",[e._v(\"null\")]),e._v(\"。然后再从 \"),t(\"code\",[e._v(\"vertices\")]),e._v(\" 中获取该节点的实例对象以返回。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Graph {\\n  // ...\\n\\n  getVertex(vertexId) {\\n    if (!_.includes(this.vertexIds, vertexId)) {\\n      return null\\n    }\\n\\n    return this.vertices[vertexId]\\n  }\\n}\\n\\n\")])])]),t(\"h4\",{attrs:{id:\"遍历顶点-边\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#遍历顶点-边\"}},[e._v(\"#\")]),e._v(\" 遍历顶点/边\")]),e._v(\" \"),t(\"p\",[e._v(\"虽然在 JavaScript 中我们默认所使用的数组都是自带有序特性的，但是在关系图谱的定义中，顶点之间并不存在顺序。所以我们自然也不会允许对图对象中的顶点进行直接的循环操作，而采用回调函数的方式进行循环，以模糊其有序性。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Graph {\\n  // ...\\n  \\n  eachVertices(callbackFunc) {\\n    const self = this\\n\\n    return self.vertexIds.forEach(function(vertexId) {\\n      return callbackFunc(self.vertices[vertexId])\\n    })\\n  }\\n  \\n  eachEdges(callbackFunc) {\\n    const self = this\\n\\n    return self.edgeIds.forEach(function(edgeId) {\\n      return callbackFunc(self.edges[edgeId])\\n    })\\n  }\\n}\\n\\n\")])])]),t(\"h3\",{attrs:{id:\"_8-1-5-特征值\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-1-5-特征值\"}},[e._v(\"#\")]),e._v(\" 8.1.5 特征值\")]),e._v(\" \"),t(\"p\",[e._v(\"我们将关系图谱建立了起来以后，就需要开始对这个图进行一些操作了。首先我们前面就说到树形结构是一种特别的图形结构，那么在树形结构中的一些节点特性在图形结构中也同样适用。\")]),e._v(\" \"),t(\"h4\",{attrs:{id:\"degree\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#degree\"}},[e._v(\"#\")]),e._v(\" Degree\")]),e._v(\" \"),t(\"p\",[e._v(\"Degree 在树形结构的节点中表示的是某一个节点的子节点数量，而因为在关系图谱中的顶点并不存在“子节点”或“子顶点”的概念，取而代之的则是相邻顶点。而相邻顶点的数量就等于与该顶点相连的边的数量。那么要获取相邻边的数量则首先需要定义一个方法以传入顶点标识符并得到相邻边数组。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Graph {\\n  // ...\\n  \\n  getEdgesByVertexId(vertexId) {\\n    if (!_.includes(this.vertexIds, vertexId)) {\\n      return []\\n    }\\n\\n    if (!_.has(this.edgeRelations, vertexId)) {\\n      return []\\n    }\\n\\n    const self = this\\n\\n    return self.edgeRelations[vertexId].map(function(edgeId) {\\n      return self.edges[edgeId]\\n    })\\n  }\\n}\\n\\n\")])])]),t(\"p\",[e._v(\"得到相邻边后返回其长度则便是该顶点的度。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Graph {\\n  // ...\\n  \\n  degree(vertexId) {\\n    return this.getEdgesByVertexId(vertexId).length\\n  }\\n}\\n\\n\")])])]),t(\"h4\",{attrs:{id:\"最大的度-max-degree\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#最大的度-max-degree\"}},[e._v(\"#\")]),e._v(\" 最大的度（Max Degree）\")]),e._v(\" \"),t(\"p\",[e._v(\"在关系图谱中每一个顶点的度是图论算法中非常重要的计算对象。就好比使用关系图谱描述一个社交群体中人与人的相关关系，每一个人作为一个顶点时，顶点的度则代表了对应的个人社交关系，数量越多则代表该名成员在该群体中的重要性越高。显而易见，如果某一个节点的度最大，则说明他很有可能是这个群体中的核心人物。\")]),e._v(\" \"),t(\"p\",[e._v(\"寻找一个关系图谱中带有最大度数的顶点并不困难，只需全部先计算出所有顶点的度，然后找出最大数即可。\")]),e._v(\" \"),t(\"p\",[e._v(\"当然，光是找出最大的度可不能满足算法的需要。除了找出最大的度数以外，自然还需要知道是哪一个顶点具有最大的度数。所以我们需要准备两个函数，一个用于找出带有最大度数的顶点，而另外一个则用于获取其度数。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Graph {\\n  // ...\\n\\n  largestVertex() {\\n    const self = this\\n\\n    const degrees = self.vertexIds.map(function(vertexId) {\\n      return {\\n        degree: self.degree(vertexId),\\n        id: vertexId\\n      }\\n\\n    })\\n\\n    return self.getVertex(_.maxBy(degrees, 'degree').id)\\n  }\\n\\n  maxDegree() {\\n    return this.degree(this.largestVertex().id)\\n  }\\n}\\n\\nconst vertices = [\\n  new Vertex(1, 'A'),\\n  new Vertex(2, 'B'),\\n  new Vertex(3, 'C'),\\n  new Vertex(4, 'D'),\\n  new Vertex(5, 'E')\\n]\\n\\nconst edges = [\\n  new Edge(1, 2, 1),\\n  new Edge(1, 3, 2),\\n  new Edge(2, 4, 1),\\n  new Edge(3, 4, 1),\\n  new Edge(1, 4, 2),\\n  new Edge(4, 5, 3)\\n]\\n\\nconst graph = new Graph(vertices, edges)\\nconsole.log(graph.largestVertex().property) //=> D\\nconsole.log(graph.maxDegree()) //=> 4\\n\\n\")])])]),t(\"h4\",{attrs:{id:\"平均度-average-degree\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#平均度-average-degree\"}},[e._v(\"#\")]),e._v(\" 平均度（Average Degree）\")]),e._v(\" \"),t(\"p\",[e._v(\"在一个关系图谱中，除了最大的顶点度以外，每一个顶点的平均度数也是一个非常重要的数学特征值。在这里我们可以有一个比较巧妙的计算方式，而不需要像上面计算最大度的时候那样子先把所有的顶点度数求出来。这有一个用于计算关系图谱中平均度的公式。\")]),e._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://juejin.im/equation?tex=%5Coverline%7BD%7D%3D%5Cfrac%7B2%5Ctimes%20N_e%7D%7BN_v%7D%0A\",alt:\"\\\\overline{D}=\\\\frac{2\\\\times N_e}{N_v}\"}})]),e._v(\" \"),t(\"p\",[e._v(\"其中 \"),t(\"img\",{attrs:{src:\"https://juejin.im/equation?tex=%5Coverline%7BD%7D\",alt:\"\\\\overline{D}\"}}),e._v(\" 为一个图中的平均度，而 \"),t(\"img\",{attrs:{src:\"https://juejin.im/equation?tex=N_e\",alt:\"N_e\"}}),e._v(\" 是该图中边的数量，\"),t(\"img\",{attrs:{src:\"https://juejin.im/equation?tex=N_v\",alt:\"N_v\"}}),e._v(\" 则是顶点的数量。这个公式还是非常好理解的，因为一条边同时属于左右两个顶点，所以在计算平均度的时候首先需要将边数乘以 \"),t(\"img\",{attrs:{src:\"https://juejin.im/equation?tex=2\",alt:\"2\"}}),e._v(\"，然后再除以顶点的数量即可得到平均度。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Graph {\\n  // ...\\n\\n  avgDegree() {\\n    return 2 * this.edgeIds.length / this.vertexIds.length\\n  }\\n}\\n\\nconst vertices = [\\n  new Vertex(1, 'A'),\\n  new Vertex(2, 'B'),\\n  new Vertex(3, 'C'),\\n  new Vertex(4, 'D'),\\n  new Vertex(5, 'E')\\n]\\n\\nconst edges = [\\n  new Edge(1, 2, 1),\\n  new Edge(1, 3, 2),\\n  new Edge(2, 4, 1),\\n  new Edge(3, 4, 1),\\n  new Edge(1, 4, 2),\\n  new Edge(4, 5, 3)\\n]\\n\\nconst graph = new Graph(vertices, edges)\\nconsole.log(graph.avgDegree()) //=> 2.4\\n\\n\")])])]),t(\"h4\",{attrs:{id:\"自环-self-loop\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#自环-self-loop\"}},[e._v(\"#\")]),e._v(\" 自环（Self-Loop）\")]),e._v(\" \"),t(\"p\",[e._v(\"自环是一种十分抽象的概念，其定义是在一个关系图谱内，某一个顶点存在一条边再与自己相连。这种情况我们很难使用一个现实生活中的例子来说明，但是我们可以将一个关系图谱中的每一个顶点看作是事件序列中的某一个事件，顶点间的边则表示多种情况下事件之间的连续关系。那么在这种场景下，顶点的自环就可以被解释为某一个事件的连续发生可能性。\")]),e._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/5/1/16319f91981d945a?w=251&h=256&f=png&s=11009\",alt:\"self-loop\"}})]),e._v(\" \"),t(\"p\",[e._v(\"在多种事件顺序发生的可能性中，如果某一个事件的连续发生次数（我们可以使用边的属性值表示）越多，则表示该事件的重要性越强。这种概念在一些对用户行为进行分析的应用中十分重要。\")]),e._v(\" \"),t(\"p\",[e._v(\"而找到自环的边的方法也非常简单，只需要找到那些左右顶点相同的边即可。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Graph {\\n  // ...\\n  \\n  loops() {\\n    const self = this\\n\\n    return self.edgeIds\\n      .map(function(edgeId) {\\n        return self.edges[edgeId]\\n      })\\n      .filter(function(edge) {\\n        return edge.leftId === edge.rightId\\n      })\\n  }\\n}\\n\\nconst vertices = [\\n  new Vertex(1, '1'),\\n  new Vertex(2, '2'),\\n  new Vertex(3, '3')\\n]\\n\\nconst edges = [\\n  new Edge(1, 1, 3),\\n  new Edge(1, 2, 1),\\n  new Edge(1, 3, 1),\\n  new Edge(2, 3, 2)\\n]\\n\\nconst graph = new Graph(vertices, edges)\\nconsole.log(graph.loops()) //=> [ Edge{ leftId: 1, rightId: 1, property: 3 } ]\\n\\n\")])])]),t(\"h3\",{attrs:{id:\"_8-1-6-无向图代码清单\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-1-6-无向图代码清单\"}},[e._v(\"#\")]),e._v(\" 8.1.6 无向图代码清单\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Vertex {\\n  constructor(id, property) {\\n    this.id = id\\n    this.property = property\\n  }\\n}\\n\\nclass Edge {\\n  constructor(leftId, rightId, property) {\\n    this.leftId = leftId\\n    this.rightId = rightId\\n    this.property = property\\n  }\\n}\\n\\nlet vertexId = 0\\nfunction newVertex(property) {\\n  return new Vertex(++vertexId, property)\\n}\\n\\n\\nclass Graph {\\n  constructor(vertices, edges) {\\n\\n    // Vertices\\n    this.vertexIds = []\\n    this.vertices = {}\\n\\n    for (let i = 0; i < vertices.length; ++i) {\\n      const vertex = vertices[i]\\n\\n      this.vertexIds.push(vertex.id)\\n      this.vertices[vertex.id] = vertex\\n    }\\n\\n    const edgesWithId = edges.map(function(edge, i) {\\n      edge.id = i + 1\\n      return edge\\n    })\\n    \\n    // Edges\\n    this.edgeIds = []\\n    this.edges = {}\\n    this.edgeRelations = {}\\n\\n    for (let i = 0; i < edgesWithId.length; ++i) {\\n      const edge = edgesWithId[i]\\n\\n      this.edgeIds.push(edge.id)\\n      this.edges[edge.id] = edge\\n      \\n      if (typeof this.edgeRelations[edge.leftId] === 'undefined') {\\n        this.edgeRelations[edge.leftId] = []\\n      }\\n\\n      if (typeof this.edgeRelations[edge.rightId] === 'undefined') {\\n        this.edgeRelations[edge.rightId] = []\\n      }\\n\\n      this.edgeRelations[edge.leftId].push(edge.id)\\n      this.edgeRelations[edge.rightId].push(edge.id)\\n    }\\n\\n  }\\n\\n  getVertex(vertexId) {\\n    if (!_.includes(this.vertexIds, vertexId)) {\\n      return null\\n    }\\n\\n    return this.vertices[vertexId]\\n  }\\n\\n  eachVertices(callbackFunc) {\\n    const self = this\\n\\n    return self.vertexIds.forEach(function(vertexId) {\\n      return callbackFunc(self.vertices[vertexId])\\n    })\\n  }\\n\\n  eachEdges(callbackFunc) {\\n    const self = this\\n\\n    return self.edgeIds.forEach(function(edgeId) {\\n      return callbackFunc(self.edges[edgeId])\\n    })\\n  }\\n\\n  getEdgesByVertexId(vertexId) {\\n    if (!_.includes(this.vertexIds, vertexId)) {\\n      return []\\n    }\\n\\n    if (!_.has(this.edgeRelations, vertexId)) {\\n      return []\\n    }\\n\\n    const self = this\\n\\n    return self.edgeRelations[vertexId].map(function(edgeId) {\\n      return self.edges[edgeId]\\n    })\\n  }\\n\\n  degree(vertexId) {\\n    return this.getEdgesByVertexId(vertexId).length\\n  }\\n\\n  largestVertex() {\\n    const self = this\\n\\n    const degrees = self.vertexIds.map(function(vertexId) {\\n      return {\\n        degree: self.degree(vertexId),\\n        id: vertexId\\n      }\\n\\n    })\\n\\n    return self.getVertex(_.maxBy(degrees, 'degree').id)\\n  }\\n\\n  maxDegree() {\\n    return this.degree(this.largestVertex().id)\\n  }\\n\\n  avgDegree() {\\n    return 2 * this.edgeIds.length / this.vertexIds.length\\n  }\\n\\n  loops() {\\n    const self = this\\n\\n    return self.edgeIds\\n      .map(function(edgeId) {\\n        return self.edges[edgeId]\\n      })\\n      .filter(function(edge) {\\n        return edge.leftId === edge.rightId\\n      })\\n  }\\n}\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"_8-2-有向图\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-2-有向图\"}},[e._v(\"#\")]),e._v(\" 8.2 有向图\")]),e._v(\" \"),t(\"p\",[e._v(\"相比于无向图，有向图则是将无向图中的边加上方向特征，即从原本的一条边即代表两个顶点共同拥有一个平等的关系，变成允许顶点之间存在单向的关系。就好像我们在人际社交中，朋友之间互相认识所以我们是平等的，但是我们也有很多我们只认识他们，他们却不认识我们的人。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"_8-2-1-有向边\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-2-1-有向边\"}},[e._v(\"#\")]),e._v(\" 8.2.1 有向边\")]),e._v(\" \"),t(\"p\",[e._v(\"因为我们前面所定义的边是不存在方向特性的，所以我们直接使用了 \"),t(\"code\",[e._v(\"leftId\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"rightId\")]),e._v(\" 来存储与边相连的两个顶点的信息。而有向图的边是带有方向特征的，虽然我们也可以像数学一样定义一个向量的表达方式就是从左到右的（如 \"),t(\"img\",{attrs:{src:\"https://juejin.im/equation?tex=%5Coverrightarrow%7BAB%7D\",alt:\"\\\\overrightarrow{AB}\"}}),e._v(\"），直接使用前面所定义的边来表示有向边。\")]),e._v(\" \"),t(\"p\",[e._v(\"但是出于对程序严谨性和语义的考虑，我们还是需要另外定义一个有向边类型以使用。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class DirectedEdge {\\n  constructor(originalId, targetId, property) {\\n    this.originalId = originalId\\n    this.targetId = targetId\\n    this.property = property\\n  }\\n}\\n\\n\")])])]),t(\"h3\",{attrs:{id:\"_8-2-2-有向图-digraph\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-2-2-有向图-digraph\"}},[e._v(\"#\")]),e._v(\" 8.2.2 有向图 Digraph\")]),e._v(\" \"),t(\"p\",[e._v(\"因为使用的边不再是无方向特性的边，所以之前所定义的无向图类型也不能直接当做有向图使用了。有向图和无向图最大的区别就是顶点之间从平行的关系变成了有\"),t(\"strong\",[e._v(\"出\")]),e._v(\"或\"),t(\"strong\",[e._v(\"入\")]),e._v(\"的单边关系。出代表着某一个顶点存在一个单向的关系指向另外一个顶点，而入则表示某一个顶点被另外一个顶点所指向。\")]),e._v(\" \"),t(\"p\",[e._v(\"那么前面使用 \"),t(\"code\",[e._v(\"edgeRelations\")]),e._v(\" 来存储顶点与边的关系时则需要加以改动了，我们可以简单地分开 \"),t(\"code\",[e._v(\"inEdgeRelations\")]),e._v(\" 和 \"),t(\"code\",[e._v(\"outEdgeRelations\")]),e._v(\" 来分别存储顶点与入边、出边的关系。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Digraph {\\n  constructor(vertices, edges) {\\n\\n    // Vertices\\n    this.vertexIds = []\\n    this.vertices = {}\\n\\n    for (let i = 0; i < vertices.length; ++i) {\\n      const vertex = vertices[i]\\n\\n      this.vertexIds.push(vertex.id)\\n      this.vertices[vertex.id] = vertex\\n    }\\n\\n    const edgesWithId = edges.map(function(edge, i) {\\n      edge.id = i + 1\\n      return edge\\n    })\\n\\n    // Edges\\n    this.edgeIds = []\\n    this.edges = {}\\n    this.inEdgeRelations = {}\\n    this.outEdgeRelations = {}\\n\\n    for (let i = 0; i < edgesWithId.length; ++i) {\\n      const edge = edgesWithId[i]\\n\\n      this.edgeIds.push(edge.id)\\n      this.edges[edge.id] = edge\\n\\n      if (typeof this.outEdgeRelations[edge.originalId] === 'undefined') {\\n        this.outEdgeRelations[edge.originalId] = []\\n      }\\n\\n      if (typeof this.inEdgeRelations[edge.targetId] === 'undefined') {\\n        this.inEdgeRelations[edge.targetId] = []\\n      }\\n\\n      this.inEdgeRelations[edge.targetId].push(edge.id)\\n      this.outEdgeRelations[edge.originalId].push(edge.id)\\n    }\\n    \\n  }\\n}\\n\\n\")])])]),t(\"p\",[e._v(\"完成了有向图的基本构建后，我们就可以将无向图中的一些数学特征值计算方法应用到有向图中。但其中度的概念在有向图中被分开为入度和出度，所以平均值、最大值等等都需要分别计算。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Graph {\\n  // ...\\n\\n  getVertex(vertexId) {\\n    if (!_.includes(this.vertexIds, vertexId)) {\\n      return null\\n    }\\n\\n    return this.vertices[vertexId]\\n  }\\n\\n  eachVertices(callbackFunc) {\\n    const self = this\\n\\n    return self.vertexIds.forEach(function(vertexId) {\\n      return callbackFunc(self.vertices[vertexId])\\n    })\\n  }\\n\\n  eachEdges(callbackFunc) {\\n    const self = this\\n\\n    return self.edgeIds.forEach(function(edgeId) {\\n      return callbackFunc(self.edges[edgeId])\\n    })\\n  }\\n\\n  getInEdgesByVertexId(vertexId) {\\n    if (!_.includes(this.vertexIds, vertexId)) {\\n      return []\\n    }\\n\\n    if (!_.has(this.inEdgeRelations, vertexId)) {\\n      return []\\n    }\\n\\n    const self = this\\n\\n    return self.inEdgeRelations[vertexId].map(function(edgeId) {\\n      return self.edges[edgeId]\\n    })\\n  }\\n\\n  getOutEdgesByVertexId(vertexId) {\\n    if (!_.includes(this.vertexIds, vertexId)) {\\n      return []\\n    }\\n\\n    if (!_.has(this.outEdgeRelations, vertexId)) {\\n      return []\\n    }\\n\\n    const self = this\\n\\n    return self.outEdgeRelations[vertexId].map(function(edgeId) {\\n      return self.edges[edgeId]\\n    })\\n  }\\n\\n  inDegree(vertexId) {\\n    return this.getInEdgesByVertexId(vertexId).length\\n  }\\n\\n  outDegree(vertexId) {\\n    return this.getOutEdgesByVertexId(vertexId).length\\n  }\\n\\n  largestInDegreeVertex() {\\n    const self = this\\n\\n    const inDegrees = self.vertexIds.map(function(vertexId) {\\n      return {\\n        inDegree: self.inDegree(vertexId),\\n        id: vertexId\\n      }\\n    })\\n\\n    return self.getVertex(_.maxBy(inDegrees, 'inDegree').id)\\n  }\\n\\n  largestOutDegreeVertex() {\\n    const self = this\\n\\n    const outDegrees = self.vertexIds.map(function(vertexId) {\\n      return {\\n        outDegree: self.outDegree(vertexId),\\n        id: vertexId\\n      }\\n    })\\n\\n    return self.getVertex(_.maxBy(outDegrees, 'outDegree').id)\\n  }\\n\\n  maxInDegree() {\\n    return this.inDegree(this.largestInDegreeVertex().id)\\n  }\\n\\n  maxOutDegree() {\\n    return this.outDegree(this.largestOutDegreeVertex().id)\\n  }\\n\\n  avgInDegree() {\\n    const self = this\\n\\n    const totalInEdgesCount = self.vertexIds\\n      .map(function(vertexId) {\\n        if (typeof self.inEdgeRelations[vertexId] !== 'undefined') {\\n          return self.inEdgeRelations[vertexId]\\n        } else {\\n          return []\\n        }\\n      })\\n      .map(function(edges) {\\n        return edges.length\\n      })\\n      .reduce(function(a, b) {\\n        return a + b\\n      })\\n\\n    return totalInEdgesCount / this.vertexIds.length\\n  }\\n\\n  avgOutDegree() {\\n    const self = this\\n\\n    const totalOutEdgesCount = self.vertexIds\\n      .map(function(vertexId) {\\n        if (typeof self.outEdgeRelations[vertexId] !== 'undefined') {\\n          return self.outEdgeRelations[vertexId]\\n        } else {\\n          return []\\n        }\\n      })\\n      .map(function(edges) {\\n        return edges.length\\n      })\\n      .reduce(function(a, b) {\\n        return a + b\\n      })\\n\\n    return totalOutEdgesCount / this.vertexIds.length\\n  }\\n\\n  loops() {\\n    const self = this\\n\\n    return self.edgeIds\\n      .map(function(edgeId) {\\n        return self.edges[edgeId]\\n      })\\n      .filter(function(edge) {\\n        return edge.originalId === edge.targetId\\n      })\\n  }\\n\\n}\\n\\n\")])])]),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/4/29/16311ff84929c604?w=373&h=243&f=png&s=15547\",alt:\"有向图\"}})]),e._v(\" \"),t(\"p\",[e._v(\"如图所示，我们首先建立一个有向图以备后续使用。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"const vertices = [\\n  new Vertex(1, 'A'),\\n  new Vertex(2, 'B'),\\n  new Vertex(3, 'C'),\\n  new Vertex(4, 'D'),\\n  new Vertex(5, 'E')\\n]\\n\\nconst edges = [\\n  new DirectedEdge(1, 2, 1),\\n  new DirectedEdge(1, 3, 2),\\n  new DirectedEdge(2, 4, 1),\\n  new DirectedEdge(3, 4, 1),\\n  new DirectedEdge(1, 1, 3),\\n  new DirectedEdge(3, 5, 4),\\n  new DirectedEdge(4, 5, 5)\\n]\\n\\nconst graph = new Digraph(vertices, edges)\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"_8-3-有向图的最短路径\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-3-有向图的最短路径\"}},[e._v(\"#\")]),e._v(\" 8.3 有向图的最短路径\")]),e._v(\" \"),t(\"p\",[e._v(\"有向图的意义在于能够以抽象的方式表示一些实际生活中的事物，人际关系、地点之间路网关系等等。在心理学中有一个非常重要的理论叫做\"),t(\"a\",{attrs:{href:\"https://en.wikipedia.org/wiki/Six_degrees_of_separation\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"“六度隔离”（Six Degrees of Separation）\"),t(\"OutboundLink\")],1),e._v(\"，而假如我们将一个足够大的人际关系网络使用关系图谱的方式表示出来，那么就可以一探这个理论的究竟了。\")]),e._v(\" \"),t(\"p\",[e._v(\"而在交通系统中，则可以使用顶点表示地点、交叉路口，用边表示路程，而边的值则可以表示路程的长度。那么这个关系图谱则可以用于计算地点之间的路程，这也是我们所使用的导航系统中的基本原理。\")]),e._v(\" \"),t(\"p\",[e._v(\"要计算在一个关系图谱中两个顶点之间的最短距离，有非常多的算法用于计算，这里我们介绍一个非常直观和常用的算法——Dijkstra 算法。\")]),e._v(\" \"),t(\"p\",[e._v(\"Dijkstra 算法是一种适用于有向图的最短路径计算算法，它需要遍历所有的可能性之后，然后返回其中的最短路程。\")]),e._v(\" \"),t(\"p\",[e._v(\"假设我们使用前面所创建的有向图模型，并将每一条边的距离（边的属性值）作为计算指标，对一整条路径的总距离进行计算。\")]),e._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/4/29/16311ff84916e881?w=373&h=258&f=png&s=16872\",alt:\"加权有向图\"}})]),e._v(\" \"),t(\"p\",[e._v(\"但由于 Dijkstra 算法涉及的逻辑十分的复杂，有兴趣的同学可以参考掘金上一篇不错的\"),t(\"a\",{attrs:{href:\"https://juejin.im/post/5a38c27d6fb9a045132ad188\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"介绍文章\"),t(\"OutboundLink\")],1),e._v(\"进行学习，这里本节仅提供实现代码以供参考学习。\")]),e._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"class Digraph {\\n  // ...\\n  \\n  // Dijkstra's algorithm\\n  shortestPath(fromVertexId, toVertexId) {\\n    const self = this\\n\\n    const preferQueue = []\\n    const rootNode = new Node(fromVertexId)\\n    const candidateTree = new Tree(rootNode)\\n    \\n    preferQueue.push(...self.getOutEdgesByVertexId(fromVertexId).map(function(edge) {\\n      return [ fromVertexId, edge.targetId ]\\n    }))\\n\\n    while (preferQueue.length > 0) {\\n      const pair = preferQueue.shift()\\n      const parentVertexId = pair[0]\\n      const currentVertexId = pair[1]\\n\\n      // Add the edge to the candidate tree\\n      const parentNodes = candidateTree.search(function(node) {\\n        return node.name === parentVertexId\\n      })\\n      const currentNode = new Node(currentVertexId)\\n      parentNodes.forEach(function(parentNode) {\\n        candidateTree.addNode(currentNode, parentNode)\\n      })\\n\\n      if (currentVertexId === toVertexId) {\\n        continue\\n      }\\n\\n      // Add the next vertex into the prefer queue\\n      let outEdges = self.getOutEdgesByVertexId(currentVertexId)\\n\\n      if (outEdges.length <= 0) {\\n        continue\\n      }\\n\\n      outEdges = outEdges.filter(function(edge) {\\n        return candidateTree.search(function(node) {\\n          return node.name === edge.targetId\\n        }).length === 0\\n      })\\n\\n      preferQueue\\n        .push(...outEdges.map(function(edge) {\\n          return [ currentVertexId, edge.targetId ]\\n        }))\\n    }\\n\\n    const targetNodes = candidateTree.search(function(node) {\\n      return node.name === toVertexId\\n    })\\n\\n    if (targetNodes.length > 0) {\\n      const pathsWithDistance = targetNodes\\n        .map(function(node) {\\n          const vertexId = node.name\\n          const path = [ vertexId ]\\n          let lastNode = node\\n\\n          while (lastNode.parent != null) {\\n            path.push(lastNode.parent.name)\\n            lastNode = lastNode.parent\\n          }\\n\\n          return path.reverse()\\n        })\\n        .map(function(path) {\\n          const distance = path\\n            .map(function(vertexId, index) {\\n              const nextVertexId = path[index + 1]\\n\\n              if (typeof nextVertexId === 'undefined') {\\n                return\\n              }\\n\\n              const edge = self.getOutEdgesByVertexId(vertexId)\\n                .find(function(edge) {\\n                  return edge.targetId === nextVertexId\\n                })\\n              \\n              return edge\\n            })\\n            .filter(function(edge) {\\n              return typeof edge !== 'undefined'\\n            })\\n            .map(function(edge) {\\n              return edge.property\\n            })\\n            .reduce(function(distanceA, distanceB) {\\n              return distanceA + distanceB\\n            })\\n\\n          return { path, distance }\\n        })\\n      \\n      const shortestPath = _.minBy(pathsWithDistance, 'distance')\\n\\n      shortestPath.path = shortestPath.path.map(function(vertexId) {\\n        return self.getVertex(vertexId)\\n      })\\n\\n      return shortestPath\\n    } else {\\n      return {\\n        path: [],\\n        distance: Infinity\\n      }\\n    }\\n  }\\n}\\n\\nconst vertices = [\\n  new Vertex(1, 'A'),\\n  new Vertex(2, 'B'),\\n  new Vertex(3, 'C'),\\n  new Vertex(4, 'D'),\\n  new Vertex(5, 'E')\\n]\\n\\nconst edges = [\\n  new DirectedEdge(1, 2, 1),\\n  new DirectedEdge(1, 3, 2),\\n  new DirectedEdge(2, 4, 1),\\n  new DirectedEdge(3, 4, 1),\\n  new DirectedEdge(1, 1, 3),\\n  new DirectedEdge(3, 5, 4),\\n  new DirectedEdge(4, 5, 5)\\n]\\n\\nconst graph = new Digraph(vertices, edges)\\nconsole.log(graph.shortestPath(1, 5)) //=>\\n// {\\n//   distance: 6,\\n//   path: [\\n//     Vertex{ A },\\n//     Vertex{ C },\\n//     Vertex{ E }\\n//   ]\\n// }\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"小结\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[e._v(\"#\")]),e._v(\" 小结\")]),e._v(\" \"),t(\"p\",[e._v(\"在本节中，我们学习了如何构建一个没有方向特征的关系图谱，也就是无向图，来表示一些事物之间的平等关系网络；还学习了在无向图的基础上，为顶点之间的边加上方向特性，构成具有传递性的关系网络，以表示一些更为具体的事物关系；并且对一种最短路径寻路算法 Dijkstra 进行了探索。\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"习题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#习题\"}},[e._v(\"#\")]),e._v(\" 习题\")]),e._v(\" \"),t(\"ol\",[t(\"li\",[e._v(\"请自行并认真地学习 Dijkstra 算法，并思考如何对 Dijkstra 算法进行变化，使其可以应用在无向图中。\")]),e._v(\" \"),t(\"li\",[e._v(\"使用加权无向图构建一个你身边朋友圈的关系图谱，并使用习题 1 中所得到的 Dijkstra 算法变种，探索“六度隔离”理论在你身边朋友圈中的适用性。并且通过使用\"),t(\"strong\",[e._v(\"度\")]),e._v(\"的概念，寻找你身边朋友圈中的“核心人物”。\")]),e._v(\" \"),t(\"li\",[e._v(\"学习了最短路径计算算法之后，请思考如何寻找一个关系图谱中两个点之间的最长路径。\")])])])}),[],!1,null,null,null);n.default=s.exports}}]);","extractedComments":[]}