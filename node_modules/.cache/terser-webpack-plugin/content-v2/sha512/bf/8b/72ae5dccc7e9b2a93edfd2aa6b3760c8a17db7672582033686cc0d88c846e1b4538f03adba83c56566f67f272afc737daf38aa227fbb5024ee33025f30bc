{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[341],{697:function(t,e,n){\"use strict\";n.r(e);var a=n(42),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[n(\"h2\",{attrs:{id:\"导读\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#导读\"}},[t._v(\"#\")]),t._v(\" 导读\")]),t._v(\" \"),n(\"p\",[t._v(\"本节标题：「装修阶段」- 基于路由的按需渲染\")]),t._v(\" \"),n(\"p\",[t._v(\"本节主旨：页面渲染性能优化，实现基于路由的拆分，按需渲染，需要特别注意双端路由如何处理\")]),t._v(\" \"),n(\"p\",[t._v(\"本节配套代码：\")]),t._v(\" \"),n(\"p\",[n(\"a\",{attrs:{href:\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-routesplit\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-routesplit\"),n(\"OutboundLink\")],1)]),t._v(\" \"),n(\"h1\",{attrs:{id:\"正文\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#正文\"}},[t._v(\"#\")]),t._v(\" ---正文\")]),t._v(\" \"),n(\"h1\",{attrs:{id:\"react-ssr-下的路由分割-按需渲染\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#react-ssr-下的路由分割-按需渲染\"}},[t._v(\"#\")]),t._v(\" react ssr 下的路由分割 - 按需渲染\")]),t._v(\" \"),n(\"p\",[t._v(\"到这里，我们的应用骨架已相对完善，已经可以 用来进行实际项目开发，但是仍然不够，还有优化的空间。\")]),t._v(\" \"),n(\"p\",[t._v(\"现在的所有业务代码都打包到了一个文件内\"),n(\"code\",[t._v(\"main.js\")]),t._v(\"。\")]),t._v(\" \"),n(\"p\",[t._v(\"若开发一个真实的项目，在开始阶段页面较少，支持的业务较少，\"),n(\"code\",[t._v(\"js\")]),t._v(\" 代码体积并不会太大，但是随着时间的推移，这个 \"),n(\"code\",[t._v(\"js\")]),t._v(\" 文件会变得越来越大，有可能超过\"),n(\"code\",[t._v(\"1M\")]),t._v(\"。\")]),t._v(\" \"),n(\"p\",[t._v(\"过大的文件会严重影响页面的加载速度，直接影响用户体验。\")]),t._v(\" \"),n(\"h1\",{attrs:{id:\"如何优化\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何优化\"}},[t._v(\"#\")]),t._v(\" 如何优化\")]),t._v(\" \"),n(\"p\",[t._v(\"代码全部打包到一个文件内在访问时被全部加载，但用户当前访问的也就一个页面，所以我们只需要当前页面的业务代码就可以了，其他页面的代码是不需要加载的，当用户访问的时候再加载和执行岂不是更好？\")]),t._v(\" \"),n(\"p\",[t._v(\"所以我们本节开始来实现基于路由的按需渲染。\")]),t._v(\" \"),n(\"h1\",{attrs:{id:\"需渲染原理\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#需渲染原理\"}},[t._v(\"#\")]),t._v(\" 需渲染原理\")]),t._v(\" \"),n(\"p\",[t._v(\"早期接触过 \"),n(\"code\",[t._v(\"webpack2\")]),t._v(\" 的同学应该都知道\"),n(\"code\",[t._v(\"require.ensure\")]),t._v(\"方法，甚至使用过该方法来实现按需加载。\")]),t._v(\" \"),n(\"p\",[t._v(\"这个 \"),n(\"code\",[t._v(\"Api\")]),t._v(\" 的作用就是用来实现代码分割，它会单独打包指定的文件，不和主文件打包在一起。\")]),t._v(\" \"),n(\"p\",[t._v(\"不过后来有了更加规范的方式来实现按需加载-\"),n(\"code\",[t._v(\"动态导入\")]),t._v(\"。\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"const A = import('./pages/A');\\n\\n\")])])]),n(\"p\",[t._v(\"并且在\"),n(\"code\",[t._v(\"webpack2\")]),t._v(\"版本中早就支持了该特性，只需要配置\"),n(\"code\",[t._v(\"@babel/plugin-syntax-dynamic-import\")]),t._v(\"插件便可使用。\")]),t._v(\" \"),n(\"p\",[t._v(\"也就是说从\"),n(\"code\",[t._v(\"webpack2\")]),t._v(\"开始已经支持了\"),n(\"code\",[t._v(\"require.ensure\")]),t._v(\"和动态导入两种方式来实现按需加载。\")]),t._v(\" \"),n(\"p\",[t._v(\"这里我们主要介绍下使用动态导入的方式来实现按需加载。\")]),t._v(\" \"),n(\"p\",[n(\"code\",[t._v(\"import()\")]),t._v(\"只是一个语法糖，当前模块没有加载时，内部会发起一个\"),n(\"code\",[t._v(\"JSONP\")]),t._v(\"请求来加载目标代码模块， 返回值是一个\"),n(\"code\",[t._v(\"Promise\")]),t._v(\"对象，可以在\"),n(\"code\",[t._v(\"then\")]),t._v(\"方法内得到真正的模块。\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"// pages/a.js\\nexport default class A{\\n    //...\\n}\\n\\nimport('./pags/a').then({default:A}=>{\\n    \\n    //...\\n})\\n\\n\")])])]),n(\"p\",[t._v(\"代码拆分和异步加载逻辑\"),n(\"code\",[t._v(\"webpack\")]),t._v(\"已帮我们完成。\")]),t._v(\" \"),n(\"p\",[t._v(\"那动态导入怎样和\"),n(\"code\",[t._v(\"react\")]),t._v(\"结合来实现按需加载呢？\")]),t._v(\" \"),n(\"h1\",{attrs:{id:\"具体实现\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#具体实现\"}},[t._v(\"#\")]),t._v(\" 具体实现\")]),t._v(\" \"),n(\"p\",[t._v(\"实现按需加载并不复杂，官方也有很多 \"),n(\"code\",[t._v(\"demo\")]),t._v(\" 可以参考。\")]),t._v(\" \"),n(\"p\",[t._v(\"在\"),n(\"code\",[t._v(\"react router3\")]),t._v(\"下实现按需加载更简单，但是 \"),n(\"code\",[t._v(\"react router4\")]),t._v(\"就完全不同了。\")]),t._v(\" \"),n(\"p\",[t._v(\"在\"),n(\"code\",[t._v(\"v3\")]),t._v(\"中，路由提供了特定的属性来支持，下面简短的几行代码就达到了按需加载的效果。\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"const A = (location, cb) => {\\n    require.ensure([], require => {\\n        cb(null, require('../Component/A').default)\\n    },'A')\\n}\\n\\n//配置route\\n<Route path=\\\"/a\\\" getComponent={A} />\\n\\n\")])])]),n(\"h1\",{attrs:{id:\"react-router4-按需渲染\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#react-router4-按需渲染\"}},[t._v(\"#\")]),t._v(\" react router4 按需渲染\")]),t._v(\" \"),n(\"p\",[t._v(\"我们需要抽象一个\"),n(\"code\",[t._v(\"AsyncBundler\")]),t._v(\"组件，用于按需加载。\")]),t._v(\" \"),n(\"p\",[t._v(\"我们为该组件添了一个\"),n(\"code\",[t._v(\"state mod\")]),t._v(\"状态， 表示异步加载(import())完成后得到的组件，并且加载过程增加\"),n(\"code\",[t._v(\"laoding\")]),t._v(\"显示。\")]),t._v(\" \"),n(\"p\",[t._v(\"该组件还接收一个\"),n(\"code\",[t._v(\"load props\")]),t._v(\"，此属性为\"),n(\"code\",[t._v(\"Promise\")]),t._v(\"类型，用于动态导入其他组件，当\"),n(\"code\",[t._v(\"AsyncBundler\")]),t._v(\"挂载完成后，在\"),n(\"code\",[t._v(\"componentDidMount\")]),t._v(\"事件内执行异步组件的加载,也就是\"),n(\"code\",[t._v(\"props. load\")]),t._v(\"方法，在\"),n(\"code\",[t._v(\"then\")]),t._v(\"方法内得到加载成功的异步组件，同时更新\"),n(\"code\",[t._v(\"AsyncBundler\")]),t._v(\"组件的\"),n(\"code\",[t._v(\"state.mod\")]),t._v(\"，完成渲染。\")]),t._v(\" \"),n(\"p\",[t._v(\"以下是该组件完整代码\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"/**\\n * 容器组件，组件按需加载器\\n *\\n * @class Bundle\\n * @extends {Component}\\n */\\nexport default class AsyncBundle extends React.Component {\\n    constructor(props) {\\n        super(props);\\n        this.state = {\\n            mod: null//自身状态\\n        };\\n    }\\n\\n    componentDidMount() {\\n        if (!this.state.mod) {\\n            this.load(this.props);\\n        }\\n    }\\n\\n\\n    load(props) {\\n        this.setState({\\n            mod: null\\n        });\\n        //注意这里，使用Promise对象; mod.default导出默认\\n        props.load().then((mod) => {\\n            this.setState({\\n                mod: mod.default ? mod.default : mod\\n            });\\n        });\\n    }\\n\\n    render() {\\n        return this.state.mod ? this.props.children(this.state.mod) : <LoadingCompoent/>;\\n    }\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"组件的具体用法如下\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\" <AsyncBundle load={()=>import('../pages/a'))}>\\n            {(Comp) => <Comp />}\\n </AsyncBundle>\\n\\n\")])])]),n(\"p\",[t._v(\"为了使用更方便，我们对上面的写法再次进行封装，只需要调用一个方法就可以。\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"\\n//异步加载组件的高阶函数\\n\\nimport AsyncBundle from './async-bundle';\\nimport React from 'react';\\nfunction AsyncLoader (loader) {\\n\\n    function asyncFn(props) {\\n       return <AsyncBundle load={loader}>\\n            {(Comp) => <Comp {...props}/>}\\n        </AsyncBundle>\\n    }\\n    \\n    return asyncFn;\\n}\\n\\nexport default AsyncLoader;\\n\\n\\n\")])])]),n(\"p\",[t._v(\"封装后的用法如下，这样使用可以节省不少代码。\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\" AsyncLoader(() => import('../pages/index')),\\n\\n\")])])]),n(\"h1\",{attrs:{id:\"路由改造\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#路由改造\"}},[t._v(\"#\")]),t._v(\" 路由改造\")]),t._v(\" \"),n(\"p\",[t._v(\"我们可以通过\"),n(\"code\",[t._v('/*webpackChunkName:\"chunk-index\"*/')]),t._v(\"的方式来执行文件名称，默认按照数字来命名.\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"\\n//组件动态加载容器\\nimport AsyncLoader from './async-loader';\\n\\nexport default [\\n    {\\n        path: ['/','/index'],\\n        component: AsyncLoader(() => import(/*webpackChunkName:\\\"chunk-index\\\"*/'../pages/index')),\\n        exact:true\\n    },\\n    {\\n        path: '/list',\\n        component: AsyncLoader(() => import('../pages/list')),\\n        exact: true\\n    },\\n    {\\n        path: '*',\\n        component: pageNotFound,\\n        exact: true\\n    }\\n]\\n\\n\")])])]),n(\"h1\",{attrs:{id:\"react-ssr-按需加载的坑\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#react-ssr-按需加载的坑\"}},[t._v(\"#\")]),t._v(\" react ssr 按需加载的坑\")]),t._v(\" \"),n(\"p\",[t._v(\"路由改造完成后，已经可以看效果，同时控制台也能看到按需加载的包。\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/6/16f7afadf72ace7e?w=1488&h=688&f=png&s=131673\",alt:\"\"}})]),t._v(\" \"),n(\"p\",[t._v(\"但是页面效果并不是我们所期望的。\")]),t._v(\" \"),n(\"p\",[t._v(\"页面显示时会先显示\"),n(\"code\",[t._v(\"loading...\")]),t._v(\"，然后又渲染了对应的组件。\")]),t._v(\" \"),n(\"p\",[t._v(\"此时查看网页源代码发现并没有具体内容，也就是我们的\"),n(\"code\",[t._v(\"ssr\")]),t._v(\"无效了。\")]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/6/16f7afd0bdf69f2f?w=726&h=334&f=png&s=33097\",alt:\"\"}})]),t._v(\" \"),n(\"p\",[n(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2020/1/6/16f7afd75596dca7?w=729&h=365&f=png&s=38204\",alt:\"\"}})]),t._v(\" \"),n(\"h1\",{attrs:{id:\"处理-ssr-无效问题\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#处理-ssr-无效问题\"}},[t._v(\"#\")]),t._v(\" 处理 ssr 无效问题\")]),t._v(\" \"),n(\"p\",[t._v(\"路由按需加载后，服务端渲染的组件发生了改变。\")]),t._v(\" \"),n(\"p\",[t._v(\"组件按需加载仅仅是针对浏览器端的，在服务器端是没必要。由于路由对应的组件外层包裹了一个动态渲染组件，服务端执行时他并没有得到真正的组件，所以\"),n(\"code\",[t._v(\"ssr\")]),t._v(\"直出的内容会显示为一个\"),n(\"code\",[t._v(\"loading\")]),t._v(\"。\")]),t._v(\" \"),n(\"p\",[t._v(\"比如非按需时会渲染\"),n(\"code\",[t._v(\"A\")]),t._v(\"组件，现在改造成按需渲染此时\"),n(\"code\",[t._v(\"A\")]),t._v(\"外层会包裹\"),n(\"code\",[t._v(\"AsyncBundle\")]),t._v(\"组件，所以在服务端渲染的组件变成了\"),n(\"code\",[t._v(\"AsyncBundle\")]),t._v(\" 容器组件。\")]),t._v(\" \"),n(\"p\",[t._v(\"其实在服务端根本不需要按需，只需要一个路由的静态配置就可以了。\")]),t._v(\" \"),n(\"p\",[t._v(\"如何处理呢？\")]),t._v(\" \"),n(\"p\",[t._v(\"服务端在路由匹配前，将动态化为静态路由（也就是预加载）。\")]),t._v(\" \"),n(\"p\",[t._v(\"看下转换代码，就明白了。\")]),t._v(\" \"),n(\"p\",[n(\"code\",[t._v(\"转为静态路由\")])]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"//将路由转换为静态路由\\nasync function getStaticRoutes(routes) {\\n\\n    let len = routes.length,\\n        i = 0;\\n    const staticRoutes = [];\\n\\n    for (; i < len; i++) {\\n        let item = routes[i];\\n        if (checkIsAsyncRoute(item.component)) {\\n            staticRoutes.push({\\n                ...item,\\n                ...{\\n                    component: (await item.component().props.load()).default\\n                }//调用下load方法得到返回值即可\\n            });\\n        } else {\\n            staticRoutes.push({\\n                ...item\\n            });\\n        }\\n    }\\n    return staticRoutes; //返回静态路由\\n}\\n\\n\")])])]),n(\"p\",[t._v(\"上面方法返回了一个静态配置的路由，之后的匹配和渲染都基于这个静态路由。\")]),t._v(\" \"),n(\"p\",[t._v(\"这里有个点可以优化一下，把查找的结果缓存起来，没必要每次请求都去转换一次。\")]),t._v(\" \"),n(\"p\",[t._v(\"看下\"),n(\"code\",[t._v(\"ssr\")]),t._v(\"中间件代码的改造\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"// src/server/middlewares/react-ssr.js 主要变更代码\\n//...\\n\\n//获得静态路由\\nconst staticRoutesList = await getStaticRoutes(routeList);\\n\\n//查找到的目标路由对象\\n\\nlet matchResult = await matchRoute(path, staticRoutesList);\\n\\nlet { targetRoute, targetMatch } = matchResult;\\n//....\\n\\n//staticRouter 也是用静态路由 staticRoutesList\\n\\nconst html = renderToString(<StaticRouter location={path} context={context}>\\n        <App routeList={staticRoutesList}></App>\\n    </StaticRouter>);\\n\\n\\n\")])])]),n(\"p\",[t._v(\"查看效果后，\"),n(\"code\",[t._v(\"ssr\")]),t._v(\" 组件直出问题解决。\")]),t._v(\" \"),n(\"p\",[t._v(\"不过还有问题。。。\")]),t._v(\" \"),n(\"p\",[t._v(\"这次页面的效果更加神奇了，先显示服务端直出的内容，随后显示\"),n(\"code\",[t._v(\"loading\")]),t._v(\"，然后\"),n(\"code\",[t._v(\"loading\")]),t._v(\"消失，又显示了组件的内容。\")]),t._v(\" \"),n(\"h1\",{attrs:{id:\"处理客户端覆盖渲染问题\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#处理客户端覆盖渲染问题\"}},[t._v(\"#\")]),t._v(\" 处理客户端覆盖渲染问题\")]),t._v(\" \"),n(\"p\",[t._v(\"为什么浏览器接管后，页面还会出现\"),n(\"code\",[t._v(\"...loading\")]),t._v(\"并且一闪而过呢?\")]),t._v(\" \"),n(\"p\",[t._v(\"这里请大家屏气凝神的想一下，其实很简单。\")]),t._v(\" \"),n(\"p\",[t._v(\"非按需渲染时是不会出现 \"),n(\"code\",[t._v(\"loading\")]),t._v(\" 的吧，不过这好像是废话。\")]),t._v(\" \"),n(\"p\",[t._v(\"那么按需的时候出现\"),n(\"code\",[t._v(\"loading\")]),t._v(\"，其实是在等待异步 \"),n(\"code\",[t._v(\"js\")]),t._v(\" 代码的加载， 动态创建 \"),n(\"code\",[t._v(\"script\")]),t._v(\"后，\"),n(\"code\",[t._v(\"js\")]),t._v(\"代码的请求和下载也是需要时间的。\")]),t._v(\" \"),n(\"p\",[t._v(\"所以呢？\")]),t._v(\" \"),n(\"p\",[t._v(\"我们应该等这段异步\"),n(\"code\",[t._v(\"js\")]),t._v(\"代码下载完后再去执行渲染是不是就好了呢？\")]),t._v(\" \"),n(\"p\",[t._v(\"答案是对的！\")]),t._v(\" \"),n(\"p\",[t._v(\"那如何做呢？\")]),t._v(\" \"),n(\"p\",[n(\"code\",[t._v(\"组件查找\")])]),t._v(\" \"),n(\"p\",[t._v(\"客户端渲染前先进行路由查找,得到对应的组件后，调用组件的异步渲染方法\"),n(\"code\",[t._v(\"load\")]),t._v(\"，等待其加载完后，再进行组件的\"),n(\"code\",[t._v(\"DOM\")]),t._v(\"渲染。\")]),t._v(\" \"),n(\"p\",[t._v(\"具体实现如下\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"//提取出挂载到 dom 方法\\nfunction renderDom(routeList) {\\n        //渲染index\\n        ReactDom.hydrate(<BrowserRouter>\\n                <App routeList={routeList} />\\n        </BrowserRouter>\\n                , document.getElementById('root'))\\n}\\n\\n//渲染入口\\nfunction clientRender(routeList) {\\n\\n        let initialData = JSON.parse(document.getElementById('ssrTextInitData').value);\\n\\n        //查找路由\\n        let matchResult = matchRoute(document.location.pathname, routeList);\\n        let { targetRoute } = matchResult;\\n        if (targetRoute) {\\n                //设置组件初始化数据\\n                targetRoute.initialData = initialData;\\n                //****等待异步脚本加载完成****\\n                if (targetRoute.component[proConfig.asyncComponentKey]) {\\n                    targetRoute.component().props.load().then(res => {\\n                    //异步组件加载完成后再渲染页面\\n                    console.log('异步组件加完成');\\n                            \\n                    //加载完成再执行 dom 挂载    \\n                    renderDom(routeList);\\n                    });\\n                }\\n\\n        } else {\\n                renderDom(routeList);\\n        }\\n}\\n\\n//渲染入口\\nclientRender(routeList);\\n\\n\\n\")])])]),n(\"p\",[t._v(\"到这里，一个完整的\"),n(\"code\",[t._v(\"react ssr\")]),t._v(\" 路由按需加载就完成了，小伙伴们抓紧来试试吧。\")]),t._v(\" \"),n(\"h1\",{attrs:{id:\"其他方式实现按需渲染\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#其他方式实现按需渲染\"}},[t._v(\"#\")]),t._v(\" 其他方式实现按需渲染\")]),t._v(\" \"),n(\"p\",[t._v(\"在上面我们是自己手写的异步组件加载器,当然业界也有很多比较成熟的工具库,原理和我们的实现差不多，只是容错更强，功能更丰富。\")]),t._v(\" \"),n(\"p\",[t._v(\"下面几个现有库，有兴趣的可以自己试试。\")]),t._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[t._v(\"react-async-component\\nreact-loadable //广泛使用\\n@loadable/component\\nreact-imported-component\\nreact-universal-component\\n\\n\")])])]),n(\"p\",[n(\"code\",[t._v(\"react-loadable\")]),t._v(\" 该库是一个轻量级的代码分割组件，用于加载动态导入的组件，而且它考虑了非常多的边界情况，支持预加载、\"),n(\"code\",[t._v(\"ssr\")]),t._v(\"，业内使用度很高。\")]),t._v(\" \"),n(\"p\",[n(\"strong\",[t._v(\"遗留问题\")])]),t._v(\" \"),n(\"p\",[t._v(\"路由分割后，会导致热更新无效，现在官方也依然存在这个 \"),n(\"code\",[t._v(\"issue\")]),t._v(\"，现在唯一的办法就是牺牲热更新对状态的保存,但不影响模块热替换。\")]),t._v(\" \"),n(\"h1\",{attrs:{id:\"小结\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[t._v(\"#\")]),t._v(\" 小结\")]),t._v(\" \"),n(\"p\",[t._v(\"这一节我们完成了一个重大的优化，实现了基于路由的按需渲染。\")]),t._v(\" \"),n(\"p\",[t._v(\"单纯实现组件的按需加载还是很容易的，关键是和\"),n(\"code\",[t._v(\"react ssr\")]),t._v(\"结合后该如何解决出现的各种问题。\")]),t._v(\" \"),n(\"p\",[t._v(\"要知道在服务端不需要动态导入，服务端只需要处理静态路由即可，所以我们在使用前将动态路由转换为了静态路由。\")]),t._v(\" \"),n(\"p\",[t._v(\"另外客户端渲染也需要注意，需使用预加载，等异步组件加载完成再进行\"),n(\"code\",[t._v(\"DOM\")]),t._v(\"的挂载，否则会出现客户端覆盖服务端渲染的问题。\")]),t._v(\" \"),n(\"p\",[t._v(\"本节代码已上传\")]),t._v(\" \"),n(\"p\",[n(\"a\",{attrs:{href:\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-routesplit\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"https://github.com/Bigerfe/koa-react-ssr/tree/better/packages/my-react-ssr-routesplit\"),n(\"OutboundLink\")],1)]),t._v(\" \"),n(\"p\",[t._v(\"感谢你的阅读。\")]),t._v(\" \"),n(\"p\",[t._v(\"如果有问题欢迎留言，也欢迎在留言区留下你的想法和思考。\")])])}),[],!1,null,null,null);e.default=s.exports}}]);","extractedComments":[]}