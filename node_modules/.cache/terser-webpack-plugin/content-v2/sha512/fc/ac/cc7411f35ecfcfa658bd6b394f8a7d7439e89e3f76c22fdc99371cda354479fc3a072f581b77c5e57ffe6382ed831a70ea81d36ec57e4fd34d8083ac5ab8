{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[322],{680:function(n,e,t){\"use strict\";t.r(e);var a=t(42),s=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[t(\"blockquote\",[t(\"p\",[n._v(\"本节代码对应 GitHub 分支: chapter9\")])]),n._v(\" \"),t(\"p\",[t(\"a\",{attrs:{href:\"https://github.com/sanyuan0704/react-cloud-music/tree/chapter9\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"仓库传送门\"),t(\"OutboundLink\")],1)]),n._v(\" \"),t(\"h2\",{attrs:{id:\"骨架搭建\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#骨架搭建\"}},[n._v(\"#\")]),n._v(\" 骨架搭建\")]),n._v(\" \"),t(\"p\",[n._v(\"首先完成播放列表的轮廓，以及将它和播放器进行对接。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"import React from 'react';\\nimport {connect} from \\\"react-redux\\\";\\nimport { PlayListWrapper, ScrollWrapper } from './style';\\nfunction PlayList (props) {\\n  return (\\n    <PlayListWrapper>\\n      <div className=\\\"list_wrapper\\\">\\n        <ScrollWrapper></ScrollWrapper>\\n      </div>\\n    </PlayListWrapper>\\n  )\\n}\\nexport default PlayList;\\n\\n\")])])]),t(\"p\",[n._v(\"相应的 style.js 中:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('import styled from\\'styled-components\\';\\nimport style from \\'../../../assets/global-style\\';\\n\\nexport const PlayListWrapper = styled.div `\\n  position: fixed;\\n  left: 0;\\n  right: 0;\\n  top: 0;\\n  bottom: 0;\\n  z-index: 1000;\\n  background-color: ${style [\"background-color-shadow\"]};\\n  .list_wrapper {\\n    position: absolute;\\n    left: 0;\\n    bottom: 0;\\n    width: 100%;\\n    opacity: 1;\\n    border-radius: 10px 10px 0 0;\\n    background-color: ${style [\"highlight-background-color\"]};\\n    transform: translate3d (0, 0, 0);\\n    .list_close {\\n      text-align: center;\\n      line-height: 50px;\\n      background: ${style [\"background-color\"]};\\n      font-size: ${style [\"font-size-l\"]};\\n      color: ${style [\"font-color-desc\"]};\\n    }\\n  }\\n`;\\nexport const ScrollWrapper = styled.div`\\n  height: 400px;\\n  overflow: hidden;\\n`;\\n\\n')])])]),t(\"p\",[n._v(\"现在你可以看到弹出的一个白色浮层了，这就是播放列表组件。现在我们将它和播放器做一下对接。\")]),n._v(\" \"),t(\"p\",[n._v(\"首先，需要在 Player/index.js 中，往 miniPlayer 和 normalPlayer 子组件中分别传入这个属性：\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"// 当然先要从 props 取出 togglePlayListDispatch，这部分大家自己加上即可\\ntogglePlayList={togglePlayListDispatch}\\n\\n\")])])]),t(\"p\",[n._v(\"然后在 miniPlayer/index.js 中，增加以下逻辑:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('// 取出\\nconst { togglePlayList } = props;\\nconst handleTogglePlayList = (e) => {\\n  togglePlayList (true);\\n  e.stopPropagation ();\\n};\\n\\n// 给列表图标绑定事件\\n<div className=\"control\" onClick={handleTogglePlayList}>\\n\\n')])])]),t(\"p\",[n._v(\"同时，在 normalPlayer/index.js 中，增加:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('const { togglePlayList } = props;\\n//...\\n<div\\n  className=\"icon i-right\"\\n  onClick={() => togglePlayList (true)}\\n>\\n\\n')])])]),t(\"p\",[n._v(\"现在我们让 PlayList 组件对接上 redux 中的数据。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"import { connect } from \\\"react-redux\\\";\\n\\n// 组件代码省略\\n\\n// 映射 Redux 全局的 state 到组件的 props 上\\nconst mapStateToProps = (state) => ({\\n  showPlayList: state.getIn (['player', 'showPlayList']),\\n});\\n// 映射 dispatch 到 props 上\\nconst mapDispatchToProps = (dispatch) => {\\n  return {\\n    togglePlayListDispatch (data) {\\n      dispatch (changeShowPlayList (data));\\n    }\\n  }\\n};\\n\\n// 将 ui 组件包装成容器组件\\nexport default connect (mapStateToProps, mapDispatchToProps)(React.memo (PlayList));\\n\\n\")])])]),t(\"p\",[n._v(\"连接后我们专心来写组件内部的逻辑。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('// 即将引入的模块\\nimport { connect } from \"react-redux\";\\nimport { PlayListWrapper, ScrollWrapper, ListHeader, ListContent } from \\'./style\\';\\nimport { CSSTransition } from \\'react-transition-group\\';\\nimport React, { useRef, useState, useCallback } from \\'react\\';\\nimport { prefixStyle, getName } from \\'./../../../api/utils\\';\\nimport { changeShowPlayList, changeCurrentIndex, changePlayMode, changePlayList } from \"../store/actionCreators\";\\nimport { playMode } from \"../../../api/config\";\\nimport Scroll from \\'../../../baseUI/scroll\\';\\n\\n\\n// 组件内代码\\nfunction PlayList (props) {\\n  const { showPlayList } = props;\\n  const { togglePlayListDispatch } = props;\\n  const playListRef = useRef ();\\n  const listWrapperRef = useRef ();\\n  const isShow = useState (false);\\n\\n  return (\\n    <CSSTransition \\n      in={showPlayList} \\n      timeout={300} \\n      classNames=\"list-fade\"\\n      onEnter={onEnterCB}\\n      onEntering={onEnteringCB}\\n      onExiting={onExitingCB}\\n      onExited={onExitedCB}\\n    >\\n      <PlayListWrapper \\n        ref={playListRef} \\n        style={isShow === true ? { display: \"block\" } : { display: \"none\" }} \\n        onClick={() => togglePlayListDispatch (false)}\\n      >\\n        <div className=\"list_wrapper\" ref={listWrapperRef} >\\n          <ScrollWrapper></ScrollWrapper>\\n        </div>\\n      </PlayListWrapper>\\n    </CSSTransition>\\n  )\\n}\\n\\n\\n')])])]),t(\"p\",[n._v(\"接下来编写动画钩子里面的回调函数:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('import { prefixStyle } from \\'./../../../api/utils\\';\\n\\nconst transform = prefixStyle (\"transform\");\\n\\nconst onEnterCB = useCallback (() => {\\n  // 让列表显示\\n  setIsShow (true);\\n  // 最开始是隐藏在下面\\n  listWrapperRef.current.style [transform] = `translate3d (0, 100%, 0)`;\\n}, [transform]);\\n\\nconst onEnteringCB = useCallback (() => {\\n  // 让列表展现\\n  listWrapperRef.current.style [\"transition\"] = \"all 0.3s\";\\n  listWrapperRef.current.style [transform] = `translate3d (0, 0, 0)`;\\n}, [transform]);\\n\\nconst onExitingCB = useCallback (() => {\\n  listWrapperRef.current.style [\"transition\"] = \"all 0.3s\";\\n  listWrapperRef.current.style [transform] = `translate3d (0px, 100%, 0px)`;\\n}, [transform]);\\n\\nconst onExitedCB = useCallback (() => {\\n  setIsShow (false);\\n  listWrapperRef.current.style [transform] = `translate3d (0px, 100%, 0px)`;\\n}, [transform]);\\n\\n')])])]),t(\"p\",[n._v(\"在 style.js 中增加动画部分:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"export const PlayListWrapper = styled.div `\\n  /* 下面是动画部分的代码 */\\n  &.list-fade-enter {\\n    opacity: 0;\\n  }\\n  &.list-fade-enter-active {\\n    opacity: 1;\\n    transition: all 0.3s;\\n  }\\n  &.list-fade-exit {\\n    opacity: 1;\\n  }\\n  &.list-fade-exit-active {\\n    opacity: 0;\\n    transition: all 0.3s;\\n  }\\n`\\n\\n\")])])]),t(\"p\",[n._v(\"现在大家点击列表图标便能弹出浮层了。\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"完成列表展示功能\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#完成列表展示功能\"}},[n._v(\"#\")]),n._v(\" 完成列表展示功能\")]),n._v(\" \"),t(\"p\",[n._v(\"现在我们来往浮层中增添列表的内容和功能。\")]),n._v(\" \"),t(\"p\",[n._v(\"首先，得从 redux 中拿到相应的数据。获取数据如下:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"// 映射 Redux 全局的 state 到组件的 props 上\\nconst mapStateToProps = (state) => ({\\n  currentIndex: state.getIn (['player', 'currentIndex']),\\n  currentSong: state.getIn (['player', 'currentSong']),\\n  playList: state.getIn (['player', 'playList']),// 播放列表\\n  sequencePlayList: state.getIn (['player', 'sequencePlayList']),// 顺序排列时的播放列表\\n  showPlayList: state.getIn (['player', 'showPlayList']),\\n  mode: state.getIn (['player', 'mode'])\\n});\\n// 映射 dispatch 到 props 上\\nconst mapDispatchToProps = (dispatch) => {\\n  return {\\n    togglePlayListDispatch (data) {\\n      dispatch (changeShowPlayList (data));\\n    },\\n    // 修改当前歌曲在列表中的 index，也就是切歌\\n    changeCurrentIndexDispatch (data) {\\n      dispatch (changeCurrentIndex (data));\\n    },\\n    // 修改当前的播放模式\\n    changeModeDispatch (data) {\\n      dispatch (changePlayMode (data));\\n    },\\n    // 修改当前的歌曲列表\\n    changePlayListDispatch (data) {\\n      dispatch (changePlayList (data));\\n    },\\n  }\\n};\\n\\n\")])])]),t(\"p\",[n._v(\"从 props 中导入:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"const {\\n  currentIndex,\\n  currentSong:immutableCurrentSong,\\n  showPlayList,\\n  playList:immutablePlayList,\\n  mode,\\n  sequencePlayList:immutableSequencePlayList\\n} = props;\\nconst {\\n  togglePlayListDispatch,\\n  changeCurrentIndexDispatch,\\n  changePlayListDispatch,\\n  changeModeDispatch,\\n} = props;\\n\\nconst currentSong = immutableCurrentSong.toJS ();\\nconst playList = immutablePlayList.toJS ();\\nconst sequencePlayList = immutableSequencePlayList.toJS ();\\n\\n\")])])]),t(\"p\",[n._v(\"然后让列表组件对接这些数据，渲染出整个列表。JSX 结构如下:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('//div.list_wrapper 标签中包裹下面的结构\\n<ListHeader>\\n  <h1 className=\"title\">\\n    { getPlayMode () }\\n    <span className=\"iconfont clear\" onClick={handleShowClear}>&#xe63d;</span>\\n  </h1>\\n</ListHeader>\\n<ScrollWrapper>\\n  <Scroll >\\n    <ListContent>\\n      {\\n        playList.map ((item, index) => {\\n          return (\\n            <li className=\"item\" key={item.id}>\\n              {getCurrentIcon (item)}\\n              <span className=\"text\">{item.name} - {getName (item.ar)}</span>\\n              <span className=\"like\">\\n                <i className=\"iconfont\">&#xe601;</i>\\n              </span>\\n              <span className=\"delete\">\\n                <i className=\"iconfont\">&#xe63d;</i>\\n              </span>\\n            </li>\\n          )\\n        })\\n      }\\n    </ListContent>\\n  </Scroll>\\n</ScrollWrapper>\\n\\n')])])]),t(\"p\",[n._v(\"其中有一些 UI 相关的逻辑封装，包括 getPlayMode、getPlayMode 和 changeMode，比较直观，没有参杂太多的业务逻辑，直接贴出代码:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('const getCurrentIcon = (item) => {\\n  // 是不是当前正在播放的歌曲\\n  const current = currentSong.id === item.id;\\n  const className = current ? \\'icon-play\\' : \\'\\';\\n  const content = current ? \\'&#xe6e3;\\': \\'\\';\\n  return (\\n    <i className={`current iconfont ${className}`} dangerouslySetInnerHTML={{__html:content}}></i>\\n  )\\n};\\nconst getPlayMode = () => {\\n  let content, text;\\n  if (mode === playMode.sequence) {\\n    content = \"&#xe625;\";\\n    text = \"顺序播放\";\\n  } else if (mode === playMode.loop) {\\n    content = \"&#xe653;\";\\n    text = \"单曲循环\";\\n  } else {\\n    content = \"&#xe61b;\";\\n    text = \"随机播放\";\\n  }\\n  return (\\n    <div>\\n      <i className=\"iconfont\" onClick={(e) => changeMode (e)}  dangerouslySetInnerHTML={{__html: content}}></i>\\n      <span className=\"text\" onClick={(e) => changeMode (e)}>{text}</span>\\n    </div>\\n  )\\n};\\nconst changeMode = (e) => {\\n  let newMode = (mode + 1) % 3;\\n  // 具体逻辑比较复杂 后面来实现\\n};\\n\\n')])])]),t(\"p\",[n._v(\"当然，还有对应的 style.js 中的样式组件，首先是 ListHead , 作为列表头部包裹播放模式和清空按钮的容器组件:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('export const ListHeader = styled.div `\\n  position: relative;\\n  padding: 20px 30px 10px 20px;\\n  .title {\\n    display: flex;\\n    align-items: center;\\n    >div {\\n      flex:1;\\n      .text {\\n        flex: 1;\\n        font-size: ${style [\"font-size-m\"]};\\n        color: ${style [\"font-color-desc\"]};\\n      }\\n    }\\n    .iconfont {\\n      margin-right: 10px;\\n      font-size: ${style [\"font-size-ll\"]};\\n      color: ${style [\"theme-color\"]};\\n    }\\n    .clear {\\n      ${style.extendClick ()}\\n      font-size: ${style [\"font-size-l\"]};\\n    }\\n  }\\n`\\n\\n')])])]),t(\"p\",[n._v(\"ListContent 组件用来包裹整个歌曲的列表，是一个列表包裹组件， 样式代码如下：\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('export const ListContent = styled.div `\\n  .item {\\n    display: flex;\\n    align-items: center;\\n    height: 40px;\\n    padding: 0 30px 0 20px;\\n    overflow: hidden;\\n    .current {\\n      flex: 0 0 20px;\\n      width: 20px;\\n      font-size: ${style [\"font-size-s\"]};\\n      color: ${style [\"theme-color\"]};\\n    }\\n    .text {\\n      flex: 1;\\n      ${style.noWrap ()}\\n      font-size: ${style [\"font-size-m\"]};\\n      color: ${style [\"font-color-desc-v2\"]};\\n      .icon-favorite {\\n        color: ${style [\"theme-color\"]};\\n      }\\n    }\\n    .like {\\n      ${style.extendClick ()}\\n      margin-right: 15px;\\n      font-size: ${style [\"font-size-m\"]};\\n      color: ${style [\"theme-color\"]};\\n    }\\n    .delete {\\n      ${style.extendClick ()}\\n      font-size: ${style [\"font-size-s\"]};\\n      color: ${style [\"theme-color\"]};\\n    }\\n  }\\n`\\n\\n')])])]),t(\"p\",[n._v(\"现在列表的展示已经成功完成！接下来就是处理对应的业务逻辑了，梳理一下，分别是点击切歌、删除歌曲和切换播放模式这三大功能。\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"点击切歌实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#点击切歌实现\"}},[n._v(\"#\")]),n._v(\" 点击切歌实现\")]),n._v(\" \"),t(\"p\",[n._v(\"首先，我们需要绑定对应的事件:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('const handleChangeCurrentIndex = (index) => {\\n  if (currentIndex === index) return;\\n  changeCurrentIndexDispatch (index);\\n}\\n\\n// 绑定点击事件\\n<li className=\"item\" key={item.id} onClick={() => handleChangeCurrentIndex (index)}>\\n\\n')])])]),t(\"p\",[n._v(\"你现在点击一下歌曲，好像可以切歌，但是你发现有一个问题:\")]),n._v(\" \"),t(\"p\",[n._v(\"当你点击之后列表突然被隐藏了。这个 bug 是怎么产生的呢？其实我们之前在 PlayWrapper 绑定了这样一个事件:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"onClick={() => togglePlayListDispatch (false)}\\n\\n\")])])]),t(\"p\",[n._v(\"其实这是为了在用户点击列表外部的时候，直接将列表隐藏掉，也符合常理。但是 PlayWrapper 的范围是整个屏幕，包含了列表内容，因此出现了这个 bug。\")]),n._v(\" \"),t(\"p\",[n._v(\"如何解决这个问题？\")]),n._v(\" \"),t(\"p\",[n._v(\"且看这样一行代码:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('<div className=\"list_wrapper\" ref={listWrapperRef} onClick={e => e.stopPropagation ()}>\\n\\n')])])]),t(\"p\",[n._v(\"在 list_wrapper 中绑定点击事件，阻止它冒泡就行了。因为这个 div 包裹的就是整个歌曲的列表。\")]),n._v(\" \"),t(\"p\",[n._v(\"OK！接下来，我们来实现删除歌曲的功能，这里面又包括删除一首歌曲和清空全部歌曲。\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"删除一首歌曲\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#删除一首歌曲\"}},[n._v(\"#\")]),n._v(\" 删除一首歌曲\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('import { deleteSong } from \"../store/actionCreators\";\\n\\nconst { deleteSongDispatch } = props;\\nconst handleDeleteSong = (e, song) => {\\n  e.stopPropagation ();\\n  deleteSongDispatch (song);\\n};\\n\\n<span className=\"delete\" onClick={(e) => handleDeleteSong (e, item)}>\\n  <i className=\"iconfont\">&#xe63d;</i>\\n</span>\\n\\n')])])]),t(\"p\",[n._v(\"重点在于 deleteSongDispatch 的逻辑，我们来一步步拆解它。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//mapDispatchToProps 中\\ndeleteSongDispatch (data) {\\n  dispatch (deleteSong (data));\\n}\\n\\n\")])])]),t(\"p\",[n._v(\"然后在 Player/store/constants.js 中增加:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"export const DELETE_SONG = 'player/DELETE_SONG';\\n\\n\")])])]),t(\"p\",[n._v(\"在 store/actionCreator.js 中导入 DELETE_SONG, 然后增加一个新的 action:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"export const deleteSong = (data) => ({\\n  type: DELETE_SONG,\\n  data\\n});\\n\\n\")])])]),t(\"p\",[n._v(\"现在转到 store/reducer.js 下编写删除的逻辑:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"import { findIndex } from '../../../api/utils';// 注意引入工具方法\\n//...\\nconst handleDeleteSong = (state, song) => {\\n  // 也可用 loadsh 库的 deepClone 方法。这里深拷贝是基于纯函数的考虑，不对参数 state 做修改\\n  const playList = JSON.parse (JSON.stringify (state.get ('playList').toJS ()));\\n  const sequenceList = JSON.parse (JSON.stringify (state.get ('sequencePlayList').toJS ()));\\n  let currentIndex = state.get ('currentIndex');\\n  // 找对应歌曲在播放列表中的索引\\n  const fpIndex = findIndex (song, playList);、\\n  // 在播放列表中将其删除\\n  playList.splice (fpIndex, 1);\\n  // 如果删除的歌曲排在当前播放歌曲前面，那么 currentIndex--，让当前的歌正常播放\\n  if (fpIndex < currentIndex) currentIndex--;\\n  \\n  // 在 sequenceList 中直接删除歌曲即可\\n  const fsIndex = findIndex (song, sequenceList);\\n  sequenceList.splice (fsIndex, 1);\\n\\n  return state.merge ({\\n    'playList': fromJS (playList),\\n    'sequencePlayList': fromJS (sequenceList),\\n    'currentIndex': fromJS (currentIndex),\\n  });\\n}\\n\\nexport default (state = defaultState, action) => {\\n  switch (action.type) {\\n    //...\\n    case actionTypes.DELETE_SONG:\\n      return handleDeleteSong (state, action.data);\\n    default:\\n      return state;\\n  }\\n}\\n\\n\")])])]),t(\"p\",[n._v(\"现在点击单个歌曲后面的删除按钮便能成功地将歌曲从列表删除啦！\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"清空歌曲功能\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#清空歌曲功能\"}},[n._v(\"#\")]),n._v(\" 清空歌曲功能\")]),n._v(\" \"),t(\"p\",[n._v(\"一般而言，删除全部是一个影响比较大的操作，如果弹出一个确定框，让用户点击确定再操作，无疑是更加合理的。\")]),n._v(\" \"),t(\"p\",[n._v(\"因此，我们首先来封装弹框组件，然后进行事件绑定。\")]),n._v(\" \"),t(\"p\",[n._v(\"在 baseUI 目录下新建 confirm 文件夹，然后新建 index.js 文件。\")]),n._v(\" \"),t(\"p\",[n._v(\"其代码从 \"),t(\"a\",{attrs:{href:\"https://github.com/sanyuan0704/react-cloud-music/blob/master/src/baseUI/confirm/index.js\",target:\"_blank\",rel:\"noopener noreferrer\"}},[n._v(\"代码地址\"),t(\"OutboundLink\")],1),n._v(\" 中获取，也是一个非常基础的组件，里面的封装操作和之前的类似，就不再浪费篇幅了。\")]),n._v(\" \"),t(\"p\",[n._v(\"回到 PlayList 组件，我们引入 Confirm 组件:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('import Confirm from \\'./../../../baseUI/confirm/index\\';\\nconst confirmRef = useRef ();\\n//JSX\\nreturn (\\n  <PlayListWrapper>\\n    //...\\n    <Confirm \\n      ref={confirmRef}\\n      text={\"是否删除全部？\"} \\n      cancelBtnText={\"取消\"} \\n      confirmBtnText={\"确定\"} \\n      handleConfirm={handleConfirmClear}\\n    />\\n  </PlayListWrapper>\\n)\\n\\n')])])]),t(\"p\",[n._v(\"现在来绑定一下清空事件:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('const handleShowClear = () => {\\n  confirmRef.current.show ();\\n} \\n\\n<span className=\"iconfont clear\" onClick={handleShowClear}>&#xe63d;</span>\\n\\n')])])]),t(\"p\",[n._v(\"现在的工作是编写 Confirm 组件的回调函数 handleConfirmClear。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"import { changeSequecePlayList, changeCurrentSong, changePlayingState } from '../store/actionCreators';\\n//...\\nconst { clearDispatch } = props;\\nconst handleConfirmClear = () => {\\n  clearDispatch ();\\n}\\n\\n\")])])]),t(\"p\",[n._v(\"clearDispatch 在 mapDispatchToProps 中定义:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"const mapDispatchToProps = (dispatch) => {\\n  return {\\n    //...\\n    clearDispatch () {\\n      // 1. 清空两个列表\\n      dispatch (changePlayList ([]));\\n      dispatch (changeSequecePlayList ([]));\\n      // 2. 初始 currentIndex\\n      dispatch (changeCurrentIndex (-1));\\n      // 3. 关闭 PlayList 的显示\\n      dispatch (changeShowPlayList (false));\\n      // 4. 将当前歌曲置空\\n      dispatch (changeCurrentSong ({}));\\n      // 5. 重置播放状态\\n      dispatch (changePlayingState (false));\\n    }\\n  }\\n};\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"修改播放模式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#修改播放模式\"}},[n._v(\"#\")]),n._v(\" 修改播放模式\")]),n._v(\" \"),t(\"p\",[n._v(\"直接复用当时完成 normalPlayer 时修改播放模式的代码，当时我们实现过，估计你已经不陌生了。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"// 从 utils.js 中再引入 shuffle 和 findIndex\\nimport { prefixStyle, getName, shuffle, findIndex } from './../../../api/utils';\\n\\nconst changeMode = () => {\\n  let newMode = (mode + 1) % 3;\\n  if (newMode === 0) {\\n    // 顺序模式\\n    changePlayListDispatch (sequencePlayList);\\n    let index = findIndex (currentSong, sequencePlayList);\\n    changeCurrentIndexDispatch (index);\\n  } else if (newMode === 1) {\\n    // 单曲循环\\n    changePlayListDispatch (sequencePlayList);\\n  } else if (newMode === 2) {\\n    // 随机播放\\n    let newList = shuffle (sequencePlayList);\\n    let index = findIndex (currentSong, newList);\\n    changePlayListDispatch (newList);\\n    changeCurrentIndexDispatch (index);\\n  }\\n  changeModeDispatch (newMode);\\n};\\n\\n\")])])]),t(\"h2\",{attrs:{id:\"下滑关闭及反弹效果\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#下滑关闭及反弹效果\"}},[n._v(\"#\")]),n._v(\" 下滑关闭及反弹效果\")]),n._v(\" \"),t(\"p\",[n._v(\"作为一个精美的 App，在完成基本功能的同时，我们也有其他交互细节的考量。比如在安卓中下滑小段距离时会有反弹，下滑超过了一定阈值就会关闭浮层。现在就带大家来完成这个移动端常用的功能。\")]),n._v(\" \"),t(\"p\",[n._v(\"实现这个交互的关键在于利用好 touchStart， touchMove, touchEnd 这三个事件的回调。\")]),n._v(\" \"),t(\"p\",[n._v(\"首先来绑定事件:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('const handleTouchStart = (e) => {};\\nconst handleTouchMove = (e) => {};\\nconst handleTouchEnd = (e) => {};\\n//...\\n<div \\n  className=\"list_wrapper\" \\n  ref={listWrapperRef} \\n  onClick={e => e.stopPropagation ()}\\n  onTouchStart={handleTouchStart}\\n  onTouchMove={handleTouchMove}\\n  onTouchEnd={handleTouchEnd}\\n>\\n\\n')])])]),t(\"p\",[n._v(\"其次，对于 Scroll 组件:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"// 是否允许滑动事件生效\\nconst [canTouch,setCanTouch] = useState (true);\\n\\nconst listContentRef = useRef ();\\nconst handleScroll = (pos) => {\\n  // 只有当内容偏移量为 0 的时候才能下滑关闭 PlayList。否则一边内容在移动，一边列表在移动，出现 bug\\n  let state = pos.y === 0;\\n  setCanTouch (state);\\n}\\n\\n<Scroll \\n  ref={listContentRef} \\n  onScroll={pos => handleScroll (pos)}\\n  bounceTop={false}\\n>\\n\\n\")])])]),t(\"p\",[n._v(\"接下来我们来具体地编写那三个 touch 事件的回调函数。\")]),n._v(\" \"),t(\"p\",[n._v(\"首先初始化三个变量:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"//touchStart 后记录 y 值\\nconst [startY, setStartY] = useState (0);\\n//touchStart 事件是否已经被触发\\nconst [initialed, setInitialed] = useState (0);\\n// 用户下滑的距离\\nconst [distance, setDistance] = useState (0);\\n\\n\")])])]),t(\"p\",[n._v(\"对于 touchStart 事件：\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('const handleTouchStart = (e) => {\\n  if (!canTouch || initialed) return;\\n  listWrapperRef.current.style [\"transition\"] = \"\";\\n  setStartY (e.nativeEvent.touches [0].pageY);// 记录 y 值\\n  setInitialed (true);\\n};\\n\\n')])])]),t(\"p\",[n._v(\"对于 touchMove 事件:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"const handleTouchMove = (e) => {\\n  if (!canTouch || !initialed) return;\\n  let distance = e.nativeEvent.touches [0].pageY - startY;\\n  if (distance < 0) return;\\n  setDistance (distance);// 记录下滑距离\\n  listWrapperRef.current.style.transform = `translate3d (0, ${distance} px, 0)`;\\n};\\n\\n\")])])]),t(\"p\",[n._v(\"对于 touchEnd:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v('const handleTouchEnd = (e) => {\\n  setInitialed (false);\\n  // 这里设置阈值为 150px\\n  if (distance >= 150) {\\n    // 大于 150px 则关闭 PlayList\\n    togglePlayListDispatch (false);\\n  } else {\\n    // 否则反弹回去\\n    listWrapperRef.current.style [\"transition\"] = \"all 0.3s\";\\n    listWrapperRef.current.style [transform] = `translate3d (0px, 0px, 0px)`;\\n  }\\n};\\n\\n')])])]),t(\"p\",[n._v(\"恭喜你，现在终于开发完成了这个看似简单却实际上并不简单的 PlayList 组件。如今播放器的功能已经比较完整了，但是仍然有一个非常重要的功能需要完成 —— 歌词功能，下一节就让我们开始歌词开发的第一步 —— 歌词解析插件的封装。\")])])}),[],!1,null,null,null);e.default=s.exports}}]);","extractedComments":[]}