{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[453],{805:function(t,n,a){\"use strict\";a.r(n);var s=a(42),e=Object(s.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"实战篇-5-为天气页面制作雨雪效果的粒子系统\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实战篇-5-为天气页面制作雨雪效果的粒子系统\"}},[t._v(\"#\")]),t._v(\" 实战篇 5：为天气页面制作雨雪效果的粒子系统\")]),t._v(\" \"),a(\"p\",[t._v(\"经过前两节的内容，基本天气预报页面的布局和数据交互都已经完成了，本节来介绍使用小程序的绘图 API 在「实时天气」模块上做一个雨雪效果。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/8/13/165314726eeabb28?w=640&h=960&f=gif&s=2606064\",alt:\"\"}})]),t._v(\" \"),a(\"h2\",{attrs:{id:\"小程序的绘图-api\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小程序的绘图-api\"}},[t._v(\"#\")]),t._v(\" 小程序的绘图 API\")]),t._v(\" \"),a(\"p\",[t._v(\"小程序的绘图 API 跟 HTML5 的 Canvas 本质上有很大区别的，造成用法区别的原因是：\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"小程序的绘图（Canvas）是客户端实现的 Native UI 组件，而不是普通的 H5 组件，所以在使用上跟普通的 H5 组件用法略有不同。\")])]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[a(\"strong\",[t._v(\"Tips：\")]),t._v(\" 微信的 Canvas 在 iOS 上是 \"),a(\"a\",{attrs:{href:\"https://github.com/phoboslab/Ejecta\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"Ejecta\"),a(\"OutboundLink\")],1),t._v(\" 实现的。\")])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"上下文获取方式不同\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#上下文获取方式不同\"}},[t._v(\"#\")]),t._v(\" 上下文获取方式不同\")]),t._v(\" \"),a(\"p\",[t._v(\"小程序绘图 API 的 \"),a(\"code\",[t._v(\"canvasContext\")]),t._v(\" 获取方式是通过 \"),a(\"code\",[t._v(\"<canvas>\")]),t._v(\" 的 \"),a(\"code\",[t._v(\"canvas-id\")]),t._v(\" 来获取的，即\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('<canvas canvas-id=\"test\"></canvas>\\n\\n')])])]),a(\"p\",[t._v(\"获取 Context：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"let ctx = wx.createCanvasContext('test')\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"api-写法不同\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#api-写法不同\"}},[t._v(\"#\")]),t._v(\" API 写法不同\")]),t._v(\" \"),a(\"p\",[t._v(\"小程序的绘图 API 跟 HTML5 的 Canvas 在用法上主要是绝大部分的 HTML5 Canvas 属性写法，变成了小程序的方法写法，例如：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"const ctx = wx.createCanvasContext('myCanvas')\\nctx.setFillStyle('red')\\nctx.fillRect(10, 10, 150, 75)\\nctx.draw()\\n\\n\")])])]),a(\"p\",[t._v(\"不过值得一提的是，在 1.9.0 基础库以上，类似 \"),a(\"code\",[t._v(\"fillStyle\")]),t._v(\"、\"),a(\"code\",[t._v(\"lineWidth\")]),t._v(\" 这类的，可以直接跟 H5 的写法一样，不需要使用 \"),a(\"code\",[t._v(\"setXxxx\")]),t._v(\" 的方式了。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"想要显示绘制效果-需要-ctx-draw-使用\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#想要显示绘制效果-需要-ctx-draw-使用\"}},[t._v(\"#\")]),t._v(\" 想要显示绘制效果，需要 \"),a(\"code\",[t._v(\"ctx.draw()\")]),t._v(\" 使用\")]),t._v(\" \"),a(\"p\",[t._v(\"在小程序的绘图使用中，对 \"),a(\"code\",[t._v(\"context\")]),t._v(\" 进行绘制之后，并不会立即绘制到画布上，而是通过执行 \"),a(\"code\",[t._v(\"ctx.draw()\")]),t._v(\" 的方式，将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中。\"),a(\"code\",[t._v(\"ctx.draw()\")]),t._v(\" 方法比较消耗性能，因此不建议在一个绘制周期内多次调用。\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[a(\"strong\",[t._v(\"Tips：\")]),t._v(\" 小程序绘图中的内部尺寸单位都是 px，例如 \"),a(\"code\",[t._v(\"clearRect()\")]),t._v(\" 这类方法，所以在使用 \"),a(\"code\",[t._v(\"rpx\")]),t._v(\" 布局的页面中，需要注意 Canvas 内部 rpx 到 px 的转换关系，详细解释见本节粒子系统实现部分。\")])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"粒子系统设计思路\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#粒子系统设计思路\"}},[t._v(\"#\")]),t._v(\" 粒子系统设计思路\")]),t._v(\" \"),a(\"p\",[t._v(\"在 Canvas 开发中，经常会提到粒子系统，使用粒子系统可以模拟出火、雾、云、雪、尘埃、烟气等抽象视觉效果。\")]),t._v(\" \"),a(\"p\",[t._v(\"在这个小程序中，笔者使用粒子系统做了雨雪效果，通过雨雪效果的编写，可以让读者学会粒子系统的基础知识，以及在小程序中使用绘图 API 相关的接口。\")]),t._v(\" \"),a(\"p\",[t._v(\"本小册中的粒子系统由基类和子类组成。\"),a(\"code\",[t._v(\"Particle\")]),t._v(\" 是基类，定义了子类统一的方法，如 \"),a(\"code\",[t._v(\"run()\")]),t._v(\"、\"),a(\"code\",[t._v(\"stop()\")]),t._v(\"、\"),a(\"code\",[t._v(\"clear()\")]),t._v(\" 等。基类负责整个粒子系统动画周期和流程的维护，子类负责具体实现的粒子效果，比如下雨下雪的效果是子类实现的，而下雨下雪的开关和公共处理流程是基类控制的。\")]),t._v(\" \"),a(\"p\",[t._v(\"基类由如下几个方法组成：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"code\",[t._v(\"_init()\")]),t._v(\"：实例化时第一执行的方法；空，由子类具体实现\")]),t._v(\" \"),a(\"li\",[a(\"code\",[t._v(\"_draw()\")]),t._v(\"：每个动效周期内画图用的方法；空，由子类具体实现\")]),t._v(\" \"),a(\"li\",[a(\"code\",[t._v(\"run\")]),t._v(\"：设置定时器，定时执行 \"),a(\"code\",[t._v(\"_draw()\")]),t._v(\"，实现动画周期\")]),t._v(\" \"),a(\"li\",[a(\"code\",[t._v(\"stop\")]),t._v(\"：停止动画\")]),t._v(\" \"),a(\"li\",[a(\"code\",[t._v(\"clear\")]),t._v(\"：停止动画，并且清空画板\")])]),t._v(\" \"),a(\"p\",[t._v(\"这些方法之间的关系是：\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/8/13/16531478f272863c?w=803&h=558&f=png&s=64293\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"上面的关系图很清晰地展现了整个粒子系统的设计思路：\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"在构造器内调用 \"),a(\"code\",[t._v(\"_init\")]),t._v(\"，随机生成单个粒子，放进数组对象\")]),t._v(\" \"),a(\"li\",[t._v(\"在执行实例 \"),a(\"code\",[t._v(\"run\")]),t._v(\" 的时候，设置定时器，定时器回调调用 \"),a(\"code\",[t._v(\"_draw\")]),t._v(\" 绘制粒子，设置单个粒子下一步的属性\")]),t._v(\" \"),a(\"li\",[t._v(\"而 \"),a(\"code\",[t._v(\"_init\")]),t._v(\" 和 \"),a(\"code\",[t._v(\"_draw\")]),t._v(\" 是子类具体根据效果实现的\")])]),t._v(\" \"),a(\"p\",[t._v(\"根据这个关系图，基类就很简单实现了：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// lib/effect.js\\n// 两个状态\\nconst STATUS_STOP = 'stop'\\nconst STATUS_RUNNING = 'running'\\nclass Particle {\\n  constructor(ctx, width, height, opts) {\\n    this._timer = null\\n    this._options = opts || {}\\n    // canvas 上下文\\n    this.ctx = ctx\\n    this.status = STATUS_STOP\\n    this.w = width\\n    this.h = height\\n\\n    this._init()\\n  }\\n  _init() {}\\n  _draw() {}\\n  run() {\\n    if (this.status !== STATUS_RUNNING) {\\n      // 更改状态\\n      this.status = STATUS_RUNNING\\n      // 绘制循环\\n      this._timer = setInterval(() => {\\n        this._draw()\\n      }, 30)\\n    }\\n    return this\\n  }\\n  stop() {\\n    // 清理定时器，状态修改\\n    this.status = STATUS_STOP\\n    clearInterval(this._timer)\\n    return this\\n  }\\n  clear(){\\n    this.stop()\\n    this.ctx.clearRect(0, 0, this.w, this.h)\\n    this.ctx.draw()\\n    return this\\n  }\\n}\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"下雨效果的粒子系统\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#下雨效果的粒子系统\"}},[t._v(\"#\")]),t._v(\" 下雨效果的粒子系统\")]),t._v(\" \"),a(\"p\",[t._v(\"根据上面的内容，具体的子类只需要在 \"),a(\"code\",[t._v(\"_init\")]),t._v(\" 中，根据需要生成的粒子个数 \"),a(\"code\",[t._v(\"amount\")]),t._v(\" 循环随机生成每个粒子，放入 \"),a(\"code\",[t._v(\"this.particles\")]),t._v(\" 数组即可：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// lib/effect.js\\n// _init\\n\\nlet h = this.h\\nlet w = this.w\\n// 数量，根据不同雨大小，数量可调\\nlet amount = this._options.amount || 100\\n// 速度参数，调节下落速度\\nlet speedFactor = this._options.speedFactor || 0.03\\nlet speed = speedFactor * h\\nlet ps = (this.particles = [])\\nfor (let i = 0; i < amount; i++) {\\n  let p = {\\n    x: Math.random() * w,\\n    y: Math.random() * h,\\n    l: 2 * Math.random(),\\n    xs: -1,\\n    ys: 10 * Math.random() + speed,\\n    color: 'rgba(255, 255, 255, 0.1)'\\n  }\\n  ps.push(p)\\n}\\n\\n\")])])]),a(\"p\",[t._v(\"其中：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"x、y 代表单个粒子的位置，即雨滴开始绘图的位置\")]),t._v(\" \"),a(\"li\",[t._v(\"xs、ys 分别代表 x、y 方向上的加速度，即雨滴的下落速度和角度\")]),t._v(\" \"),a(\"li\",[t._v(\"l 代表雨滴的长度\")])]),t._v(\" \"),a(\"p\",[a(\"code\",[t._v(\"_draw\")]),t._v(\"的方法，是先将画布清空，然后遍历 \"),a(\"code\",[t._v(\"this.particles\")]),t._v(\" 数组取出单个雨滴并进行绘制，最后调用一个单独实现的 \"),a(\"code\",[t._v(\"_update\")]),t._v(\" 重新计算单个雨滴的位置：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// lib/effect.js\\n// _draw\\nlet ps = this.particles\\nlet ctx = this.ctx\\n// 清空画布\\nctx.clearRect(0, 0, this.w, this.h)\\n// 遍历绘制雨滴\\nfor (let i = 0; i < ps.length; i++) {\\n  let s = ps[i]\\n  ctx.beginPath()\\n  ctx.moveTo(s.x, s.y)\\n  // 画线绘制雨点效果\\n  ctx.lineTo(s.x + s.l * s.xs, s.y + s.l * s.ys)\\n  ctx.setStrokeStyle(s.color)\\n  ctx.stroke()\\n}\\nctx.draw()\\nreturn this._update()\\n\\n\")])])]),a(\"p\",[a(\"code\",[t._v(\"_update\")]),t._v(\" 的具体实现如下：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// lib/effect.js\\n\\n// _update\\nlet {w, h} = this // 获取画布大小\\nfor (let ps = this.particles, i = 0; i < ps.length; i++) {\\n  // 开始下一个周期的位置计算\\n  let s = ps[i]\\n  s.x += s.xs\\n  s.y += s.ys\\n  // 超出范围，重新回收，重复利用\\n  if (s.x > w || s.y > h) {\\n    s.x = Math.random() * w\\n    s.y = -10\\n  }\\n}\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"下雪效果子类实现\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#下雪效果子类实现\"}},[t._v(\"#\")]),t._v(\" 下雪效果子类实现\")]),t._v(\" \"),a(\"p\",[t._v(\"下雪的效果跟下雨不同的是，下雨是长条的线，雪花是圆形的雪片，另外为了增加「灵性」做出飘来飘去的效果，在 \"),a(\"code\",[t._v(\"_update\")]),t._v(\" 方法中，使用了 \"),a(\"code\",[t._v(\"Math.cos\")]),t._v(\" 来随机生成下一步 \"),a(\"code\",[t._v(\"x\")]),t._v(\" 轴的位置，这里就直接贴出代码来：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// lib/effect.js\\nclass Snow extends Particle {\\n  _init() {\\n    let {w, h} = this\\n    let colors = this._options._colors || ['#ccc', '#eee', '#fff', '#ddd']\\n    // 雪的大小用数量来计算\\n    let amount = this._options.amount || 100\\n\\n    let speedFactor = this._options.speedFactor || 0.03\\n    // 速度\\n    let speed = speedFactor * h * 0.15\\n\\n    let radius = this._options.radius || 2\\n    let ps = (this.particles = [])\\n\\n    for (let i = 0; i < amount; i++) {\\n      let x = Math.random() * w\\n      let y = Math.random() * h\\n      // console.log(x, y)\\n      ps.push({\\n        x,\\n        y,\\n        // 原始 x 坐标，后面计算随机雪摆动是以此为基础\\n        ox: x,\\n        // 向下运动动能变量\\n        ys: Math.random() + speed,\\n        // 雪的半径大小\\n        r: Math.floor(Math.random() * (radius + 0.5) + 0.5),\\n        // 颜色随机取\\n        color: colors[Math.floor(Math.random() * colors.length)],\\n        rs: Math.random() * 80\\n      })\\n    }\\n  }\\n  _draw() {\\n    let ps = this.particles\\n    let ctx = this.ctx\\n    ctx.clearRect(0, 0, this.w, this.h)\\n    for (let i = 0; i < ps.length; i++) {\\n      let {x, y, r, color} = ps[i]\\n      ctx.beginPath()\\n      // 绘制下雪的效果\\n      ctx.arc(x, y, r, 0, Math.PI * 2, false)\\n      ctx.setFillStyle(color)\\n      ctx.fill()\\n      ctx.closePath()\\n    }\\n\\n    ctx.draw()\\n    this._update()\\n  }\\n  _update() {\\n    let {w, h} = this\\n    let v = this._options.speedFactor / 10\\n    for (let ps = this.particles, i = 0; i < ps.length; i++) {\\n      let p = ps[i]\\n      let {ox, ys} = p\\n      p.rs += v\\n      // 这里使用了 cos，做成随机左右摆动的效果\\n      p.x = ox + Math.cos(p.rs) * w / 2\\n      p.y += ys\\n      // console.log(ys)\\n      // 重复利用\\n      if (p.x > w || p.y > h) {\\n        p.x = Math.random() * w\\n        p.y = -10\\n      }\\n    }\\n  }\\n}\\n\\n\")])])]),a(\"p\",[t._v(\"注意，不管是下雨还是下雪，在 \"),a(\"code\",[t._v(\"_draw\")]),t._v(\" 的最开始都是执行 \"),a(\"code\",[t._v(\"ctx.clearRect\")]),t._v(\" 清空画布，最后都是执行 \"),a(\"code\",[t._v(\"ctx.draw\")]),t._v(\" 使 native 对画布进行统一绘制。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"使用粒子系统\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用粒子系统\"}},[t._v(\"#\")]),t._v(\" 使用粒子系统\")]),t._v(\" \"),a(\"p\",[t._v(\"上面介绍了雨雪的粒子系统 JS 类实现，下面讲解怎样将 Canvas 效果画到网页上，首先看下效果图。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/8/17/165469d660043a27?w=400&h=718&f=png&s=257746\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"效果图的黄色框内为下雨的效果，这个红色框大小跟顶部「实时天气模块」是等大的。首先，在 WXML 代码中，给实时天气模块增加 \"),a(\"code\",[t._v(\"id\")]),t._v(\" 为 \"),a(\"code\",[t._v(\"effect\")]),t._v(\" 的 Canvas 组件：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('\\x3c!-- weather/index.wxml --\\x3e\\n<view class=\"container\" id=\"canvas-wrapper\">\\n  \\x3c!-- 下面是雨雪效果的 Canvas --\\x3e\\n  <canvas canvas-id=\"effect\" id=\"effect\"></canvas>\\n  <view class=\"now\">\\n    <view class=\"location\" bindtap=\"chooseLocation\">\\n      ...\\n    </view>\\n    <view class=\"air-quality\" wx:if=\"{{air.aqi}}\">\\n      ...\\n    </view>\\n    <view class=\"now-weather\">\\n      ...\\n    </view>\\n  </view>\\n  <view class=\"two-days\">\\n    ....\\n  </view>\\n</view>\\n\\n')])])]),a(\"p\",[t._v(\"在样式中，设置 Canvas 的大小跟实时天气模块大小一样，并且绝对定位，完全覆盖到实时天气模块上：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// weather/index.scss\\n#effect {\\n  width: 750rpx;\\n  height: 768rpx;\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n}\\n\\n\")])])]),a(\"p\",[a(\"strong\",[t._v(\"重点\")]),t._v(\"：在微信小程序内，绘图 API（Canvas）内的长宽单位为 px，而我们页面布局用的是 rpx，虽然我们在 CSS 内已经使用 rpx 设置了 Canvas 的大小，但是由于内部单位的缘故，在实例化 Rain/Snow 粒子系统的时候，传入的 \"),a(\"code\",[t._v(\"width\")]),t._v(\" 和 \"),a(\"code\",[t._v(\"height\")]),t._v(\" 参数应该是实际的 px 大小。\")]),t._v(\" \"),a(\"p\",[t._v(\"根据之前章节的介绍，rpx 转 px 是根据不同的设备屏幕尺寸转换的。虽然切图可以按照 \"),a(\"code\",[t._v(\"1rpx=2px\")]),t._v(\" 这样标准的 iPhone 6 视觉稿做页面，但是涉及实际 px 计算时，不能简单采用 \"),a(\"code\",[t._v(\"1rpx=2px\")]),t._v(\" 的方式来解决，需要我们按照实际的 rpx 对应 px 的比例进行转换。如何获取 rpx 和 px 的实际比例呢？我们知道微信小程序中默认规定了屏幕宽度为 750rpx，根据这个设计，我们可以通过 \"),a(\"code\",[t._v(\"wx.getSystemInfo\")]),t._v(\" 获取到的信息，找到手机屏幕的宽度大小 \"),a(\"code\",[t._v(\"windowWidth\")]),t._v(\" 即可算出对应的比例，代码如下：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// weather/index.js\\n// 在 onload 内\\nwx.getSystemInfo({\\n  success: (res) => {\\n    let width = res.windowWidth\\n    this.setData({\\n      width,\\n      scale: width / 375\\n    })\\n  }\\n})\\n\\n\")])])]),a(\"p\",[t._v(\"这样，上面的 \"),a(\"code\",[t._v(\"width\")]),t._v(\"就是屏幕的实际 \"),a(\"strong\",[t._v(\"px 宽度\")]),t._v(\"，而每个元素的实际 \"),a(\"strong\",[t._v(\"px 高度\")]),t._v(\"则由 \"),a(\"code\",[t._v(\"元素 rpx 高度 / 2 * scale\")]),t._v(\" 得到。\")]),t._v(\" \"),a(\"p\",[t._v(\"最后，我们在页面代码中，实际使用 \"),a(\"code\",[t._v(\"Rain/Snow\")]),t._v(\" 类时的代码是下面这样的：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v(\"// weather/index.js\\n// 下面是 canvas 的 canvas-id\\nconst canvasId = 'effect'\\nconst ctx = wx.createCanvasContext(canvasId)\\nlet {width, scale} = this.data\\n// 768 为 CSS 中设置的 rpx 值\\nlet height = 768 / 2 * scale\\nlet rain = new Rain(ctx, width, height, {\\n  amount: 100,\\n  speedFactor: 0.03\\n})\\n// 跑起来\\nrain.run()\\n// 如果切换了城市，不在下雨/雪，则执行\\nrain.clear()\\n\\n\")])])]),a(\"h2\",{attrs:{id:\"小结\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#小结\"}},[t._v(\"#\")]),t._v(\" 小结\")]),t._v(\" \"),a(\"p\",[t._v(\"本节介绍使用小程序绘图 API（Canvas）绘制雨雪效果的粒子系统，给整个天气页面添加动效。\")]),t._v(\" \"),a(\"p\",[t._v(\"在使用粒子系统中应该注意小程序绘图 API 的写法跟 HTML5 中 Canvas API 的差异。除了 API 的差异，还要在绘图结束后调用 \"),a(\"code\",[t._v(\"ctx.draw()\")]),t._v(\" 使绘制执行。最后介绍了怎样在 rpx 的布局中绘制不定宽高的效果，需要根据屏幕的宽度跟 rpx 的实际比例计算出元素的实际 px 宽高，然后给 Canvas 使用。\")])])}),[],!1,null,null,null);n.default=e.exports}}]);","extractedComments":[]}