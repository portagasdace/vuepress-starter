{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[259],{614:function(s,t,e){\"use strict\";e.r(t);var a=e(42),r=Object(a.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"_4-4-使用-npm-script-实现构建流水线\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-4-使用-npm-script-实现构建流水线\"}},[s._v(\"#\")]),s._v(\" 4.4 使用 npm script 实现构建流水线\")]),s._v(\" \"),e(\"p\",[s._v(\"在现代前端项目的交付工作流中，部署前最关键的环节就是构建，构建环节要完成的事情通常包括：\")]),s._v(\" \"),e(\"ul\",[e(\"li\",[s._v(\"源代码预编译：比如 less、sass、typescript；\")]),s._v(\" \"),e(\"li\",[s._v(\"图片优化、雪碧图生成；\")]),s._v(\" \"),e(\"li\",[s._v(\"JS、CSS 合并、压缩；\")]),s._v(\" \"),e(\"li\",[s._v(\"静态资源加版本号和引用替换；\")]),s._v(\" \"),e(\"li\",[s._v(\"静态资源传 CDN 等。\")])]),s._v(\" \"),e(\"p\",[s._v(\"现在大多数同学所接触的项目构建过程可能都是别人配置好的，但是对于构建过程中的某些考量可能并不是很清楚。\")]),s._v(\" \"),e(\"p\",[s._v(\"接下来，我们将组合 npm script 和简单的命令行工具为实际项目添加构建过程，以加深对构建过程的理解，同时也会用到前面很多章节的知识点。\")]),s._v(\" \"),e(\"h2\",{attrs:{id:\"项目目录结构\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#项目目录结构\"}},[s._v(\"#\")]),s._v(\" 项目目录结构\")]),s._v(\" \"),e(\"p\",[s._v(\"对之前的示例项目做简单改造，让目录结构包括典型的前端项目资源引用情况：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"client\\n├── images\\n│   └── schedule.png\\n├── index.html\\n├── scripts\\n│   └── main.js\\n└── styles\\n    └── main.css\\n\\n\")])])]),e(\"p\",[s._v(\"可能的资源依赖关系如下：\")]),s._v(\" \"),e(\"ul\",[e(\"li\",[s._v(\"css、html 文件中引用了图片；\")]),s._v(\" \"),e(\"li\",[s._v(\"html 文件中引用了 css、js；\")])]),s._v(\" \"),e(\"p\",[s._v(\"显而易见，我们的构建过程必须遵循下面的步骤才能不出错：\")]),s._v(\" \"),e(\"ol\",[e(\"li\",[s._v(\"压缩图片；\")]),s._v(\" \"),e(\"li\",[s._v(\"编译 less、压缩 css；\")]),s._v(\" \"),e(\"li\",[s._v(\"编译、压缩 js；\")]),s._v(\" \"),e(\"li\",[s._v(\"给图片加版本号并替换 js、css 中的引用；\")]),s._v(\" \"),e(\"li\",[s._v(\"给 js、css 加版本号并替换 html 中的引用；\")])]),s._v(\" \"),e(\"h2\",{attrs:{id:\"添加构建过程\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#添加构建过程\"}},[s._v(\"#\")]),s._v(\" 添加构建过程\")]),s._v(\" \"),e(\"p\",[s._v(\"下面介绍如何结合 npm script 正确的给这样的项目结构加上构建过程。\")]),s._v(\" \"),e(\"h3\",{attrs:{id:\"_1-准备构建目录\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-准备构建目录\"}},[s._v(\"#\")]),s._v(\" 1. 准备构建目录\")]),s._v(\" \"),e(\"p\",[s._v(\"我们约定构建产生的结果代码，放在 dist 目录下，与 client 的结构完全相同，每次构建前，清空之前的构建目录，利用 npm 的钩子机制添加 prebuild 命令如下：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v('-    \"client:static-server\": \"http-server client/\"\\n+    \"client:static-server\": \"http-server client/\",\\n+    \"prebuild\": \"rm -rf dist && mkdir -p dist/{images,styles,scripts}\",\\n\\n')])])]),e(\"h3\",{attrs:{id:\"_2-准备脚本目录\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-准备脚本目录\"}},[s._v(\"#\")]),s._v(\" 2. 准备脚本目录\")]),s._v(\" \"),e(\"p\",[s._v(\"构建过程需要的命令稍长，我们可以使用 scripty 来把这些脚本剥离到单独的文件中，为此需要准备单独的目录，并且我们的构建过程分为：images、styles、scripts、hash 四个步骤，每个步骤准备单独的文件。\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"mkdir scripts/build\\ntouch scripts/build.sh\\ntouch scripts/build/{images,styles,scripts}.sh\\nchmod -R a+x scripts\\n\\n\")])])]),e(\"p\",[e(\"strong\",[s._v(\"脚本文件的可执行权限必须添加正确，否则 scripty 会直接报错\")]),s._v(\"，上面命令执行完之后，scripts 目录包含如下内容：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"scripts\\n├── build\\n│   ├── hash.sh\\n│   ├── images.sh\\n│   ├── scripts.sh\\n│   └── styles.sh\\n├── build.sh\\n\\n\")])])]),e(\"h3\",{attrs:{id:\"_3-图片构建过程\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-图片构建过程\"}},[s._v(\"#\")]),s._v(\" 3. 图片构建过程\")]),s._v(\" \"),e(\"p\",[s._v(\"图片构建的经典工具是 \"),e(\"a\",{attrs:{href:\"https://github.com/imagemin/imagemin\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"imagemin\"),e(\"OutboundLink\")],1),s._v(\"，它也提供了命令行版本 \"),e(\"a\",{attrs:{href:\"https://github.com/imagemin/imagemin-cli\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"imagemin-cli\"),e(\"OutboundLink\")],1),s._v(\"，首先安装依赖：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"npm i imagemin-cli -D\\n# npm install imagemin-cli --save-dev\\n# yarn add imagemin-cli -D\\n\\n\")])])]),e(\"p\",[s._v(\"然后在 scripts/build/images.sh 中添加如下内容：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"imagemin client/images/* --out-dir=dist/images\\n\\n\")])])]),e(\"p\",[s._v(\"然后在 package.json 中添加 build:images 命令：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v('+    \"build:images\": \"scripty\",\\n\\n')])])]),e(\"p\",[s._v(\"尝试运行 npm run prebuild && npm run build:images，然后观察 dist 目录的变化。\")]),s._v(\" \"),e(\"h3\",{attrs:{id:\"_4-样式构建过程\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-样式构建过程\"}},[s._v(\"#\")]),s._v(\" 4. 样式构建过程\")]),s._v(\" \"),e(\"p\",[s._v(\"我们使用 \"),e(\"a\",{attrs:{href:\"http://lesscss.org/usage/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"less\"),e(\"OutboundLink\")],1),s._v(\" 编写样式，所以需要预编译样式代码，可以使用 less 官方库自带的命令行工具 lessc，使用 sass 的同学可以直接使用 \"),e(\"a\",{attrs:{href:\"https://github.com/sass/node-sass\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"node-sass\"),e(\"OutboundLink\")],1),s._v(\"。此外，样式预编译完成之后，我们需要使用 \"),e(\"a\",{attrs:{href:\"https://www.npmjs.com/package/cssmin\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"cssmin\"),e(\"OutboundLink\")],1),s._v(\" 来完成代码预压缩。首先安装依赖：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"npm i cssmin -D\\n# npm install cssmin --save-dev\\n# yarn add cssmin -D\\n\\n\")])])]),e(\"p\",[s._v(\"然后在 scripts/build/styles.sh 中添加如下内容，这里我们使用到了 shell 里面的管道操作符 \"),e(\"code\",[s._v(\"|\")]),s._v(\" 和输出重定向 \"),e(\"code\",[s._v(\">\")]),s._v(\"：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"for file in client/styles/*.css\\ndo\\n  lessc $file | cssmin > dist/styles/$(basename $file)\\ndone\\n\\n\")])])]),e(\"p\",[s._v(\"然后在 package.json 中添加 build:styles 命令：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v('+    \"build:styles\": \"scripty\",\\n\\n')])])]),e(\"p\",[s._v(\"尝试运行 npm run prebuild && npm run build:styles，然后观察 dist 目录的变化，应该能看到 less 编译之后再被压缩的 css 代码。\")]),s._v(\" \"),e(\"h3\",{attrs:{id:\"_4-js-构建过程\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-js-构建过程\"}},[s._v(\"#\")]),s._v(\" 4. JS 构建过程\")]),s._v(\" \"),e(\"p\",[s._v(\"我们使用 ES6 编写 JS 代码，所以需要 \"),e(\"a\",{attrs:{href:\"https://github.com/mishoo/UglifyJS2/tree/harmony\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"uglify-es\"),e(\"OutboundLink\")],1),s._v(\" 来进行代码压缩，如果你不使用 ES6，可以直接使用 \"),e(\"a\",{attrs:{href:\"https://github.com/mishoo/UglifyJS2\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"uglify-js\"),e(\"OutboundLink\")],1),s._v(\" 来压缩代码，首先安装依赖：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"npm i uglify-es -D\\n# npm install uglify-es --save-dev\\n# yarn add uglify-es -D\\n\\n\")])])]),e(\"p\",[s._v(\"然后在 scripts/build/scripts.sh 中添加如下内容，\"),e(\"strong\",[s._v(\"需要额外注意的是，这里我们需要手动指定 uglify-es 目录下的 bin 文件，否则识别不了 ES6 语法\")]),s._v(\"，因为 uglify-es 在 npm install 过程自动创建的软链是错误的。\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"for file in client/scripts/*.js\\ndo\\n  ./node_modules/uglify-es/bin/uglifyjs $file --mangle > dist/scripts/$(basename $file)\\ndone\\n\\n\")])])]),e(\"p\",[s._v(\"然后在 package.json 中添加 build:scripts 命令：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v('+    \"build:scripts\": \"scripty\",\\n\\n')])])]),e(\"p\",[s._v(\"尝试运行 npm run prebuild && npm run build:scripts，然后观察 dist 目录的变化，应该能看到被 uglify-es 压缩后的代码。\")]),s._v(\" \"),e(\"blockquote\",[e(\"p\",[e(\"strong\",[s._v(\"TIP#19\")]),s._v(\"：uglify-es 支持很多其他的选项，以及 sourcemap，对 JS 代码做极致的优化，详细\"),e(\"a\",{attrs:{href:\"https://github.com/mishoo/UglifyJS2/tree/harmony#command-line-options\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"参考\"),e(\"OutboundLink\")],1)])]),s._v(\" \"),e(\"h3\",{attrs:{id:\"_4-资源版本号和引用替换\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-资源版本号和引用替换\"}},[s._v(\"#\")]),s._v(\" 4. 资源版本号和引用替换\")]),s._v(\" \"),e(\"p\",[s._v(\"给静态资源加版本号的原因是线上环境的静态资源通常都放在 CDN 上，或者设置了很长时间的缓存，或者两者兼有，如果资源更新了但没有更新版本号，浏览器端是拿不到最新内容的，手动加版本号的过程很繁琐并且容易出错，为此自动化这个过程就显得非常\\b有价值，通常的做法是利用文件内容做哈希，比如 md5，然后以这个哈希值作为版本号，版本号附着在文件名里面，线上环境的资源引用全部是带版本号的。\")]),s._v(\" \"),e(\"p\",[s._v(\"为了\\b实现这个过程，我们需要引入两个小工具：\")]),s._v(\" \"),e(\"ul\",[e(\"li\",[e(\"a\",{attrs:{href:\"https://github.com/keithamus/hashmark\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"hashmark\"),e(\"OutboundLink\")],1),s._v(\"，自动添加版本号；\")]),s._v(\" \"),e(\"li\",[e(\"a\",{attrs:{href:\"https://github.com/songkick/replaceinfiles\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"replaceinfiles\"),e(\"OutboundLink\")],1),s._v(\"，自动完成引用替换，它需要将版本号过程的输出作为输入；\")])]),s._v(\" \"),e(\"p\",[s._v(\"首先安装\\b依赖：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"npm i hashmark replaceinfiles -D\\n# npm install hashmark replaceinfiles --save-dev\\n# yarn add hashmark replaceinfiles -D\\n\\n\")])])]),e(\"p\",[s._v(\"然后在 scripts/build/hash.sh 中添加如下内容：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"# 给图片资源加上版本号，并且替换引用\\nhashmark -c dist -r -l 8 '**/*.{png,jpg}' '{dir}/{name}.{hash}{ext}' | replaceinfiles -S -s 'dist/**/*.css' -d '{dir}/{base}'\\n\\n# 给 js、css 资源加上版本号，并且替换引用\\nhashmark -c dist -r -l 8 '**/*.{css,js}' '{dir}/{name}.{hash}{ext}' | replaceinfiles -S -s 'client/index.html' -d 'dist/index.html'\\n\\n\")])])]),e(\"p\",[s._v(\"然后在 package.json 中添加 build:hash 命令：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v('+    \"build:hash\": \"scripty\",\\n\\n')])])]),e(\"p\",[s._v(\"这个步骤需要依赖前几个步骤，不能单独运行，接下来我们需要增加完整的 build 命令把上面几个步骤串起来。\")]),s._v(\" \"),e(\"h3\",{attrs:{id:\"_5-完整的构建步骤\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-完整的构建步骤\"}},[s._v(\"#\")]),s._v(\" 5. 完整的构建步骤\")]),s._v(\" \"),e(\"p\",[s._v(\"最后我们在 package.json 中添加 build 命令把所有的步骤串起来，完整的 diff 如下：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v('-    \"client:static-server\": \"http-server client/\"\\n+    \"client:static-server\": \"http-server client/\",\\n+    \"prebuild\": \"rm -rf dist && mkdir -p dist/{images,styles,scripts}\",\\n+    \"build\": \"scripty\",\\n+    \"build:images\": \"scripty\",\\n+    \"build:scripts\": \"scripty\",\\n+    \"build:styles\": \"scripty\",\\n+    \"build:hash\": \"scripty\"\\n\\n')])])]),e(\"p\",[s._v(\"其中 scripts/build.sh 的内容如下：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[s._v(\"for step in 'images' 'scripts' 'styles' 'hash'\\ndo\\n  npm run build:$step\\ndone\\n\\n\")])])]),e(\"p\",[s._v(\"然后我们尝试运行 npm run build，完整的过程输出如下：\")]),s._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2017/12/18/16066e5912427543?w=984&h=1290&f=png&s=171783\",alt:\"\"}})]),s._v(\" \"),e(\"p\",[s._v(\"构建完成的 dist 目录内容如下：\")]),s._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2017/12/18/16066e5b824399a7?w=698&h=240&f=png&s=25460\",alt:\"\"}})]),s._v(\" \"),e(\"p\",[s._v(\"可以看到，所有的静态资源都加上了版本号。\")]),s._v(\" \"),e(\"p\",[s._v(\"构建完成的 dist/index.html 内容如下：\")]),s._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2017/12/18/16066e5e1a91e46c?w=875&h=416&f=png&s=74207\",alt:\"\"}})]),s._v(\" \"),e(\"p\",[s._v(\"可以看到，静态资源的版本号被正确替换了，为了验证构建出来的页面是否正常运行，可以运行 \"),e(\"code\",[s._v(\"./node_modules/.bin/http-server dist\")]),s._v(\"，然后浏览器打开：\"),e(\"code\",[s._v(\"http://127.0.0.1:8080\")]),s._v(\"，不出意外的话，浏览器显示如下：\")]),s._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2017/12/18/16066e60258d8eeb?w=865&h=688&f=png&s=192586\",alt:\"\"}})]),s._v(\" \"),e(\"blockquote\",[e(\"p\",[e(\"strong\",[s._v(\"好了，到这里，我们给简单但是五脏俱全的前端项目加上了构建过程，这些环节你是否都清楚？你觉得还缺失些什么环节？欢迎留言交流\")])])]),s._v(\" \"),e(\"hr\"),s._v(\" \"),e(\"blockquote\",[e(\"p\",[s._v(\"本节用到的代码见 \"),e(\"a\",{attrs:{href:\"https://github.com/wangshijun/automated-workflow-with-npm-script/tree/12-use-npm-script-as-build-pipeline\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"GitHub\"),e(\"OutboundLink\")],1),s._v(\"，想边看边动手练习的同学可以拉下来自己改，注意切换到正确的分支 \"),e(\"code\",[s._v(\"12-use-npm-script-as-build-pipeline\")]),s._v(\"。\")])]),s._v(\" \"),e(\"hr\")])}),[],!1,null,null,null);t.default=r.exports}}]);","extractedComments":[]}