{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{481:function(e,t,d){\"use strict\";d.r(t);var i=d(42),n=Object(i.a)({},(function(){var e=this,t=e.$createElement,d=e._self._c||t;return d(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[d(\"h1\",{attrs:{id:\"使用-scopedmodel-对豆瓣电影-app-进行重构\"}},[d(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-scopedmodel-对豆瓣电影-app-进行重构\"}},[e._v(\"#\")]),e._v(\" 使用 ScopedModel 对豆瓣电影 App 进行重构\")]),e._v(\" \"),d(\"p\",[e._v(\"本节使用 ScopedModel 对豆瓣电影 App 进行重构。\")]),e._v(\" \"),d(\"h2\",{attrs:{id:\"重构后的工程路径\"}},[d(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#重构后的工程路径\"}},[e._v(\"#\")]),e._v(\" 重构后的工程路径\")]),e._v(\" \"),d(\"p\",[e._v(\"StateManager/flutter_doubanmovie_scopedmodel\")]),e._v(\" \"),d(\"h2\",{attrs:{id:\"scopedmodel\"}},[d(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#scopedmodel\"}},[e._v(\"#\")]),e._v(\" ScopedModel\")]),e._v(\" \"),d(\"p\",[e._v(\"ScopedModel 是一个可以对状态进行管理的第三方库，该库是从 Fuchsia 的代码库中提取的。\")]),e._v(\" \"),d(\"h3\",{attrs:{id:\"scopedmodel-的使用\"}},[d(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#scopedmodel-的使用\"}},[e._v(\"#\")]),e._v(\" ScopedModel 的使用\")]),e._v(\" \"),d(\"p\",[e._v(\"使用 ScopedModel 进行状态管理，要用到这个库提供的三个类，掌握这三个类的使用，就掌握了 ScopedModel。这三个类分别是：\")]),e._v(\" \"),d(\"ul\",[d(\"li\",[e._v(\"Model\")]),e._v(\" \"),d(\"li\",[e._v(\"ScopedModel\")]),e._v(\" \"),d(\"li\",[e._v(\"ScopedModelDescendant\")])]),e._v(\" \"),d(\"h4\",{attrs:{id:\"model\"}},[d(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#model\"}},[e._v(\"#\")]),e._v(\" Model\")]),e._v(\" \"),d(\"p\",[e._v(\"Model 是类，用来存储全局状态，当状态发生变化时，调用 \"),d(\"code\",[e._v(\"notifyListeners()\")]),e._v(\" 方法，就会通知给依赖这个状态的子 Widget，引起子 Widget 的创建。我们需要继承 Model 类来写自己的 Models，例如 我们写一个 UserModel，里面可以用来存储用户的用户名和 token。\")]),e._v(\" \"),d(\"h4\",{attrs:{id:\"scopedmodel-2\"}},[d(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#scopedmodel-2\"}},[e._v(\"#\")]),e._v(\" ScopedModel\")]),e._v(\" \"),d(\"p\",[e._v(\"ScopedModel 是 Widget，用来共享全局状态，可以将 Model 里的状态传递给它的子 Widget。为了将状态传递给子 Widget，我们需要使用 ScopedModel 来包 Model。\")]),e._v(\" \"),d(\"h4\",{attrs:{id:\"scopedmodeldescendant\"}},[d(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#scopedmodeldescendant\"}},[e._v(\"#\")]),e._v(\" ScopedModelDescendant\")]),e._v(\" \"),d(\"p\",[e._v(\"ScopedModelDescendant 也是 Widget，用于需要依赖 Model 里状态的子 Widget 中，而且会自动订阅 Model 里状态的变化，当 Model 里状态发生变化时，就会触发 ScopedModelDescendant 的重建。\")]),e._v(\" \"),d(\"h3\",{attrs:{id:\"子widget-中获取-model-的方法\"}},[d(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#子widget-中获取-model-的方法\"}},[e._v(\"#\")]),e._v(\" 子Widget 中获取 Model 的方法\")]),e._v(\" \"),d(\"p\",[e._v(\"有两种方法可以在子 Widget 中获取 Model：\")]),e._v(\" \"),d(\"ol\",[d(\"li\",[e._v(\"使用 ScopedModelDescendant，可以获取 Model，并且在 Model 变化时会重建。\")]),e._v(\" \"),d(\"li\",[e._v(\"使用 \"),d(\"code\",[e._v(\"ScopedModel.of\")]),e._v(\" 的静态方法获取 Model 实例，但是无法收到 Model 变化的通知。如果需要频繁使用，可以在 Model 里写一个静态方法，下面会讲到。\")])]),e._v(\" \"),d(\"h2\",{attrs:{id:\"使用-scopedmodel-重构\"}},[d(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用-scopedmodel-重构\"}},[e._v(\"#\")]),e._v(\" 使用 ScopedModel 重构\")]),e._v(\" \"),d(\"p\",[e._v(\"在 pubspec.yaml 里添加 ScopedModel 库的依赖：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"dependencies:\\n  ...\\n  scoped_model: ^1.0.1\\n\\n\")])])]),d(\"p\",[e._v(\"在 VS Code 里选择保存后，会自动下载依赖库。\")]),e._v(\" \"),d(\"p\",[e._v(\"第一步，是创建 CityModel 类，里面存储 \"),d(\"code\",[e._v(\"curCity\")]),e._v(\" 的值，同时写一个可以设置 \"),d(\"code\",[e._v(\"curCity\")]),e._v(\" 值的方法，并且在这个方法里，当 \"),d(\"code\",[e._v(\"curCity\")]),e._v(\" 的值设置完后，还需要调用 \"),d(\"code\",[e._v(\"notifyListeners()\")]),e._v(\" ：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"class CityModel extends Model {\\n  String curCity;\\n\\n  void setCurCity(String city) {\\n    if (curCity != city) {\\n      curCity = city;\\n\\n      //通知状态发生变化\\n      notifyListeners();\\n    }\\n  }\\n}\\n\\n\")])])]),d(\"p\",[e._v(\"因为第一次打开的时候 \"),d(\"code\",[e._v(\"curCity\")]),e._v(\" 需要从本地读取数据，这个读取数据的操作比较耗时，所以必须得异步操作，所以 CityModel 里的 \"),d(\"code\",[e._v(\"curCity\")]),e._v(\" 的值默认只能是空的，读取到数据后在赋值，使得状态发生变化，从而触发 Widget 的重建，代码需要这么写：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"class CityModel extends Model {\\n  ...\\n  void initData() async {\\n    final prefs = await SharedPreferences.getInstance(); //获取 prefs\\n\\n    String city = prefs.getString('curCity'); //获取 key 为 curCity 的值\\n\\n    if (city != null && city.isNotEmpty) {\\n      //如果有值\\n      setCurCity(city);\\n    } else {\\n      //如果没有值，则使用默认值\\n      setCurCity('深圳');\\n    }\\n  }\\n  ...\\n}\\n\\n\")])])]),d(\"p\",[e._v(\"在 CityModel 在建一个静态方法，获取 CityModel 的实例：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"class CityModel extends Model {\\n  ...\\n\\n  static CityModel of(BuildContext context) => ScopedModel.of<CityModel>(context);\\n}\\n\\n\")])])]),d(\"p\",[e._v(\"第二步，使用 \"),d(\"code\",[e._v(\"ScopedModel<CityModel>()\")]),e._v(\" 作为父 Widget，代码如下：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"class _MyHomePageState extends State<MyHomePage> {\\n  ...\\n  @override\\n  Widget build(BuildContext context) {\\n    return Scaffold(\\n      body: ScopedModel<CityModel>(\\n        model: cityModel,\\n        child: _widgetItems[_selectedIndex],\\n      ), //选中不同的选项显示不同的界面,\\n      ...\\n    );\\n  }\\n\\n  ...\\n}\\n\\n\")])])]),d(\"p\",[e._v(\"第三步，开始对依赖 \"),d(\"code\",[e._v(\"curCity\")]),e._v(\" 的 Widget 进行重构，在 HotWidget 里需要使用 ScopedModelDescendant 来包原来的 HotWidget：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"class HotWidgetState extends State<HotWidget> {\\n  @override\\n  void initState() {\\n    // TODO: implement initState\\n    super.initState();\\n    print('HotWidgetState initState');\\n  }\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    // TODO: implement build\\n    print('HotWidgetState build');\\n    return ScopedModelDescendant<CityModel>(\\n          ...\\n    );\\n  }\\n}\\n\\n\")])])]),d(\"p\",[e._v(\"这里 ScopedModelDescendant 有三个参数：\")]),e._v(\" \"),d(\"ul\",[d(\"li\",[d(\"p\",[e._v(\"child\")]),e._v(\" \"),d(\"p\",[e._v(\"child 的类型为 Widget，是可选的，这个 child 是不需要依赖 Model 的 Widget，将会传递给 builder。\")])]),e._v(\" \"),d(\"li\",[d(\"p\",[e._v(\"builder\")]),e._v(\" \"),d(\"p\",[e._v(\"builder 的类型为 ScopedModelDescendantBuilder，是一个函数，是必选的，定义为：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"typedef Widget ScopedModelDescendantBuilder<T extends Model>(\\n  BuildContext context,\\n  Widget child,\\n  T model,\\n);\\n\\n\")])])]),d(\"p\",[e._v(\"函数的参数有 context、child、model，在函数的内部可以访问这三个参数，builder 里的 child 就是上面提到的 child，在 builder 通过 modle 参数访问状态数据，例如 \"),d(\"code\",[e._v(\"modle.curCity\")]),e._v(\"， 最后返回一个 Widget。\")])]),e._v(\" \"),d(\"li\",[d(\"p\",[e._v(\"rebuildOnChange\")]),e._v(\" \"),d(\"p\",[e._v(\"rebuildOnChange 是 bool 类型，是可选的，表示当状态发生变化的时候是否需要重建，默认是 true，除非特别情况，这里应该永远是 true。\")])])]),e._v(\" \"),d(\"p\",[e._v(\"所以继续重构代码，将 HotWidgetState 里的 \"),d(\"code\",[e._v(\"curCity\")]),e._v(\" 变量删掉，并替换成 \"),d(\"code\",[e._v(\"model.curCity\")]),e._v(\"：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"return ScopedModelDescendant<CityModel>(\\n      builder: (context, child, model) {\\n        if (model.curCity != null && model.curCity.isNotEmpty) {\\n          //如果 curCity 不为空\\n          return ...\\n        } else {\\n          //如果 curCity 为空\\n          return ...\\n        }\\n      },\\n    );\\n\\n\")])])]),d(\"p\",[e._v(\"这个时候 \"),d(\"code\",[e._v(\"_jumpToCitysWidget()\")]),e._v(\" 方法会报错，给这个方法增加一个 \"),d(\"code\",[e._v(\"city\")]),e._v(\" 的参数，从调用的地方传过来，因为这个方法里会改变 CityModel 里 \"),d(\"code\",[e._v(\"curCity\")]),e._v(\" 的值，需要调用 CityModel 的 \"),d(\"code\",[e._v(\"setCurCity()\")]),e._v(\" 方法，所以还要增加一个 CityModel 的参数，最后代码就是：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"  void _jumpToCitysWidget(CityModel model,String city) async {\\n    var selectCity =\\n        await Navigator.pushNamed(context, '/Citys', arguments: city);\\n    if (selectCity == null) return;\\n\\n    final prefs = await SharedPreferences.getInstance();\\n    prefs.setString('curCity', selectCity); //存取数据\\n\\n    model.setCurCity(selectCity);\\n  }\\n\\n\")])])]),d(\"p\",[e._v(\"调用 \"),d(\"code\",[e._v(\"_jumpToCitysWidget()\")]),e._v(\" 方法的代码就变为:\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"_jumpToCitysWidget(model,model.curCity);\\n\\n\")])])]),d(\"p\",[e._v(\"重构完 HotWidget 后，同理对 HotMoviesListWidget、CitysWidget 进行重构。\")]),e._v(\" \"),d(\"p\",[e._v(\"因为 HotMoviesListWidget 里的 \"),d(\"code\",[e._v(\"curCity\")]),e._v(\" 的值需要在 build 之前就要用到，而且 HotMoviesListWidget 也没必要监听 CityModel 的变化，因为 HotMoviesListWidget 的父 Widget 是 HotWidget，HotWidget 已经对 CityModel 进行了变化，HotWidget 重建的时候也会引起 HotMoviesListWidget 的重建，所以 HotMoviesListWidget 里就不用 \"),d(\"code\",[e._v(\"ScopedModelDescendant<CityModel>(...)\")]),e._v(\" 了，而是用 \"),d(\"code\",[e._v(\"CityModel.of(context)\")]),e._v(\"，而且因为要用到 context，和前面使用 InheritedWidget 一样的理由，\"),d(\"code\",[e._v(\"_getData()\")]),e._v(\" 放到 \"),d(\"code\",[e._v(\"didChangeDependencies()\")]),e._v(\"里，重构后的代码为：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"class HotMoviesListWidget extends StatefulWidget {\\n  HotMoviesListWidget() {}\\n\\n  @override\\n  State<StatefulWidget> createState() {\\n    // TODO: implement createState\\n    return HotMoviesListWidgetState();\\n  }\\n}\\n\\nclass HotMoviesListWidgetState extends State<HotMoviesListWidget>\\n    with AutomaticKeepAliveClientMixin {\\n  List<HotMovieData> hotMovies = new List<HotMovieData>();\\n\\n  @override\\n  void initState() {\\n    // TODO: implement initState\\n    super.initState();\\n  }\\n\\n  @override\\n  void didChangeDependencies() {\\n    // TODO: implement didChangeDependencies\\n    super.didChangeDependencies();\\n    _getData();\\n  }\\n\\n  void _getData() async {\\n    List<HotMovieData> serverDataList = new List();\\n    var response = await http.get(\\n        'https://api.douban.com/v2/movie/in_theaters?apikey=0b2bdeda43b5688921839c8ecb20399b&city=' +\\n            CityModel.of(context).curCity +\\n            '&start=0&count=10');\\n    //成功获取数据\\n    ...\\n  }\\n\\n  ...\\n}\\n\\n\")])])]),d(\"p\",[e._v(\"HotMoviesListWidget 的构造函数去掉了参数，所以之前调用的地方要把参数去掉。\")]),e._v(\" \"),d(\"p\",[e._v(\"CitysWidget 这里就可以重构，也可以不重构，因为原先这里的 \"),d(\"code\",[e._v(\"curCity\")]),e._v(\" 的值是通过参数传过来的，耦合性就比较低，但是传参还是挺麻烦的，这里我们还是重构一下吧。\")]),e._v(\" \"),d(\"p\",[e._v(\"CitysWidget 的重构有一点麻烦，因为 CitysWidget 是通过路由创建的，因此 CitysWidget 的父 Widget 和 HotWidget 的父 Widget 不同，所以为了让 CitysWidget 访问到 Model，一方面要用 \"),d(\"code\",[e._v(\"ScopedModel<CityModel>()\")]),e._v(\"，同时 HotWidget 和 CitysWidget 要公用同一个 CityModel 的实例，所以重构后的代码如下：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"CityModel cityModel = CityModel();\\n\\nclass MyApp extends StatelessWidget {\\n  // This widget is the root of your application.\\n  @override\\n  Widget build(BuildContext context) {\\n    return MaterialApp(\\n      ...\\n      routes: {\\n        '/Citys': (context) => ScopedModel<CityModel>(\\n              model: cityModel,\\n              child: ScopedModelDescendant<CityModel>(\\n                builder: (context, child, model) {\\n                  return CitysWidget();\\n                },\\n              ),\\n            ),\\n      },\\n    );\\n  }\\n}\\n\\nclass MyHomePage extends StatefulWidget {\\n   ...\\n}\\n\\nclass _MyHomePageState extends State<MyHomePage> {\\n  ...\\n  @override\\n  Widget build(BuildContext context) {\\n    return Scaffold(\\n      body: ScopedModel<CityModel>(\\n        model: cityModel,\\n        child: _widgetItems[_selectedIndex],\\n      ), //选中不同的选项显示不同的界面,\\n      ...\\n    );\\n  }\\n  ...\\n}\\n\\n\")])])]),d(\"p\",[d(\"code\",[e._v(\"curCity\")]),e._v(\" 就使用 \"),d(\"code\",[e._v(\"CityModel.of(context)\")]),e._v(\" 来获取，CitysWidget 重构后的代码为：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"class CityWidgtState extends State<CitysWidget> {\\n  String curCity;\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    // TODO: implement build\\n    curCity = CityModel.of(context).curCity;\\n    ...\\n  }\\n}\\n\\n\")])])]),d(\"p\",[e._v(\"同时把传递参数的代码删掉，在 HotWidget 的 \"),d(\"code\",[e._v(\"_jumpToCitysWidget()\")]),e._v(\" 方法，重构后的代码为：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\"void _jumpToCitysWidget(CityModel model,String city) async {\\n    var selectCity =\\n        await Navigator.pushNamed(context, '/Citys');\\n    ...\\n  }\\n\\n\")])])]),d(\"p\",[e._v(\"接下来在看一下，能不能把 UI 逻辑和业务逻辑分离，同样看一下 HotMoviesListWidget 里，既包含了一个请求数据，又包含了数据的显示，可以考虑把数据的请求和显示分开，数据请求部分如下：\")]),e._v(\" \"),d(\"div\",{staticClass:\"language- extra-class\"},[d(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[d(\"code\",[e._v(\" void _getData() async {\\n    List<HotMovieData> serverDataList = new List();\\n    var response = await http.get(\\n        'https://api.douban.com/v2/movie/in_theaters?apikey=0b2bdeda43b5688921839c8ecb20399b&city=' +\\n            ShareDataInheritedWidget.of(context).curCity +\\n            '&start=0&count=10');\\n    //成功获取数据\\n    if (response.statusCode == 200) {\\n      var responseJson = json.decode(response.body);\\n      for (dynamic data in responseJson['subjects']) {\\n        HotMovieData hotMovieData = HotMovieData.fromJson(data);\\n        serverDataList.add(hotMovieData);\\n      }\\n      setState(() {\\n        hotMovies = serverDataList;\\n      });\\n    }\\n  }\\n\\n\")])])]),d(\"p\",[e._v(\"但是这部分应该放在哪呢？其遇到的问题和 InheritedWidget 的状态管理框是一样的，这里既不能放在 CityModel 里，因为这部分其实是本地状态， 创建一个新的 Model，会把原来的本地状态变为全局状态，导致代码复杂话，不适合扩展，从中也可以看到 ScopedModel 的状态管理框架并没有考虑 UI 逻辑和业务逻辑分离的问题。\")]),e._v(\" \"),d(\"h2\",{attrs:{id:\"分析\"}},[d(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#分析\"}},[e._v(\"#\")]),e._v(\" 分析\")]),e._v(\" \"),d(\"p\",[e._v(\"在使用 ScopedModel 重构完后，对比一下一个好的状态管理框架应该具有的条件：\")]),e._v(\" \"),d(\"ul\",[d(\"li\",[e._v(\"能管理好全局状态和本地状态\")]),e._v(\" \"),d(\"li\",[e._v(\"UI 逻辑和业务逻辑应该是分离的\")]),e._v(\" \"),d(\"li\",[e._v(\"在框架的帮助下可以写出高质量的代码\")]),e._v(\" \"),d(\"li\",[e._v(\"框架应该提升 App 的性能\")]),e._v(\" \"),d(\"li\",[e._v(\"框架要容易理解，便于扩展\")])]),e._v(\" \"),d(\"p\",[e._v(\"我们发现 ScopedModel 只能管理全局状态，而且没有涉及到 UI 逻辑和业务逻辑的分离。\")]),e._v(\" \"),d(\"h2\",{attrs:{id:\"总结\"}},[d(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#总结\"}},[e._v(\"#\")]),e._v(\" 总结\")]),e._v(\" \"),d(\"p\",[e._v(\"通过 ScopedModel 对豆瓣电影 App 的重构，我们可以发现 ScopedModel 也可以对全局状态进行管理，相对于 InheritedWidget 来说，有如下优点：\")]),e._v(\" \"),d(\"ul\",[d(\"li\",[e._v(\"可以对全局状态进行管理\")]),e._v(\" \"),d(\"li\",[e._v(\"数据只能从上到下传递，也可以从下到上传递\")])]),e._v(\" \"),d(\"p\",[e._v(\"但是，依然有很多的缺点：\")]),e._v(\" \"),d(\"ul\",[d(\"li\",[e._v(\"UI 逻辑和业务逻辑没有分开\")]),e._v(\" \"),d(\"li\",[e._v(\"无法管理本地状态\")]),e._v(\" \"),d(\"li\",[e._v(\"随着 App 变大，代码维护也会变得越来越难。\")])]),e._v(\" \"),d(\"p\",[e._v(\"所以，ScopedModel 只能在简单的 App 里使用，大型 App 绝对不能使用 ScopedModel 对状态进行管理。\")])])}),[],!1,null,null,null);t.default=n.exports}}]);","extractedComments":[]}